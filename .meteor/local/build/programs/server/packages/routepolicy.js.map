{"version":3,"sources":["meteor://ðŸ’»app/packages/routepolicy/main.js","meteor://ðŸ’»app/packages/routepolicy/routepolicy.js"],"names":["module","export","RoutePolicy","RoutePolicyConstructor","watch","require","default","v","constructor","urlPrefixTypes","urlPrefixMatches","urlPrefix","url","startsWith","checkType","type","includes","checkUrlPrefix","existingType","checkForConflictWithStatic","_testManifest","Package","webapp","WebApp","clientPrograms","defaultArch","manifest","conflict","find","resource","where","declare","problem","Error","isValidUrl","classify","prefix","Object","keys","urlPrefixesFor","entries","filter","_prefix","_type","map","sort"],"mappings":"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","file":"/packages/routepolicy.js","sourcesContent":["import { default as RoutePolicyConstructor } from './routepolicy';\nexport const RoutePolicy = new RoutePolicyConstructor();\n","// In addition to listing specific files to be cached, the browser\n// application cache manifest allows URLs to be designated as NETWORK\n// (always fetched from the Internet) and FALLBACK (which we use to\n// serve app HTML on arbitrary URLs).\n//\n// The limitation of the manifest file format is that the designations\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n// will also be treated as a network route.\n//\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n//\n// \"network\": for network routes that should not conflict with static\n// resources.  (For example, if \"/sockjs/\" is a network route, we\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n//\n// \"static-online\": for static resources which should not be cached in\n// the app cache.  This is implemented by also adding them to the\n// NETWORK section (as otherwise the browser would receive app HTML\n// for them because of the FALLBACK section), but static-online routes\n// don't need to be checked for conflict with static resources.\n\n\nexport default class RoutePolicy {\n  constructor() {\n    // maps prefix to a type\n    this.urlPrefixTypes = {};\n  }\n\n  urlPrefixMatches(urlPrefix, url) {\n    return url.startsWith(urlPrefix);\n  }\n\n  checkType(type) {\n    if (!['network', 'static-online'].includes(type)) {\n      return 'the route type must be \"network\" or \"static-online\"';\n    }\n    return null;\n  }\n\n  checkUrlPrefix(urlPrefix, type) {\n    if (!urlPrefix.startsWith('/')) {\n      return 'a route URL prefix must begin with a slash';\n    }\n\n    if (urlPrefix === '/') {\n      return 'a route URL prefix cannot be /';\n    }\n\n    const existingType = this.urlPrefixTypes[urlPrefix];\n    if (existingType && existingType !== type) {\n      return `the route URL prefix ${urlPrefix} has already been declared ` +\n        `to be of type ${existingType}`;\n    }\n\n    return null;\n  }\n\n  checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n    if (type === 'static-online') {\n      return null;\n    }\n\n    if (!Package.webapp ||\n        !Package.webapp.WebApp ||\n        !Package.webapp.WebApp.clientPrograms ||\n        !Package.webapp.WebApp.clientPrograms[\n          Package.webapp.WebApp.defaultArch].manifest) {\n      // Hack: If we don't have a manifest, deal with it\n      // gracefully. This lets us load livedata into a nodejs\n      // environment that doesn't have a HTTP server (eg, a\n      // command-line tool).\n      return null;\n    }\n\n    const WebApp = Package.webapp.WebApp;\n    const manifest =\n      _testManifest || WebApp.clientPrograms[WebApp.defaultArch].manifest;\n    const conflict = manifest.find(resource => (\n      resource.type === 'static' &&\n      resource.where === 'client' &&\n      this.urlPrefixMatches(urlPrefix, resource.url)\n    ));\n\n    if (conflict) {\n      return `static resource ${conflict.url} conflicts with ${type} ` +\n        `route ${urlPrefix}`;\n    }\n    return null;\n  }\n\n  declare(urlPrefix, type) {\n    const problem =\n      this.checkType(type) ||\n      this.checkUrlPrefix(urlPrefix, type) ||\n      this.checkForConflictWithStatic(urlPrefix, type);\n    if (problem) {\n      throw new Error(problem);\n    }\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n    this.urlPrefixTypes[urlPrefix] = type;\n  }\n\n  isValidUrl(url) {\n    return url.startsWith('/');\n  }\n\n  classify(url) {\n    if (!this.isValidUrl(url)) {\n      throw new Error(`url must be a relative URL: ${url}`);\n    }\n\n    const prefix = Object.keys(this.urlPrefixTypes).find(prefix =>\n      this.urlPrefixMatches(prefix, url)\n    );\n\n    return prefix ? this.urlPrefixTypes[prefix] : null;\n  }\n\n  urlPrefixesFor(type) {\n    return Object.entries(this.urlPrefixTypes)\n      .filter(([_prefix, _type]) => _type === type)\n      .map(([_prefix]) => _prefix)\n      .sort();\n  }\n}\n"]}