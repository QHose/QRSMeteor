[{"type":"js","data":"(function () {\n\n/* Imports */\nvar _ = Package.underscore._;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar EJSON = Package.ejson.EJSON;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Iron = Package['iron:core'].Iron;\nvar HTML = Package.htmljs.HTML;\n\n/* Package-scope variables */\nvar CurrentOptions, HTTP_METHODS, RouteController, Route, Router;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/current_options.js                                                //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/**\n * Allows for dynamic scoping of options variables. Primarily intended to be\n * used in the RouteController.prototype.lookupOption method.\n */\nCurrentOptions = new Meteor.EnvironmentVariable;\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/http_methods.js                                                   //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nHTTP_METHODS = [\n  'get',\n  'post',\n  'put',\n  'delete',\n  'patch',\n  'head'\n];\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/route_controller.js                                               //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\nRouteController = Controller.extend({\n  constructor: function (options) {\n    RouteController.__super__.constructor.apply(this, arguments);\n    options = options || {};\n    this.options = options;\n    this._onStopCallbacks = [];\n    this.route = options.route;\n    this.params = [];\n\n    // Sometimes the data property can be defined on route options,\n    // or even on the global router config. And people will expect the\n    // data function to be available on the controller instance if it\n    // is defined anywhere in the chain. This ensure that if we have\n    // a data function somewhere in the chain, you can call this.data().\n    var data = this.lookupOption('data');\n\n    if (typeof data === 'function')\n      this.data = _.bind(data, this);\n    else if (typeof data !== 'undefined')\n      this.data = function () { return data; };\n\n    this.init(options);\n  }\n});\n\n/**\n * Returns an option value following an \"options chain\" which is this path:\n *\n *   this.options\n *   this (which includes the proto chain)\n *   this.route.options\n *   dynamic variable\n *   this.router.options\n */\nRouteController.prototype.lookupOption = function (key) {\n  // this.route.options\n  // NOTE: we've debated whether route options should come before controller but\n  // Tom has convinced me that it's easier for people to think about overriding\n  // controller stuff at the route option level. However, this has the possibly\n  // counterintuitive effect that if you define this.someprop = true on the\n  // controller instance, and you have someprop defined as an option on your\n  // Route, the route option will take precedence.\n  if (this.route && this.route.options && _.has(this.route.options, key))\n    return this.route.options[key];\n\n  // this.options\n  if (_.has(this.options, key))\n    return this.options[key];\n\n  // \"this\" object or its proto chain\n  if (typeof this[key] !== 'undefined')\n    return this[key];\n\n  // see if we have the CurrentOptions dynamic variable set.\n  var opts = CurrentOptions.get();\n  if (opts && _.has(opts, key))\n    return opts[key];\n\n  // this.router.options\n  if (this.router && this.router.options && _.has(this.router.options, key))\n    return this.router.options[key];\n};\n\nRouteController.prototype.configureFromUrl = function (url, context, options) {\n  assert(typeof url === 'string', 'url must be a string');\n  context = context || {};\n  this.request = context.request || {};\n  this.response = context.response || {};\n  this.url = context.url || url;\n  this.originalUrl = context.originalUrl || url;\n  this.method = this.request.method;\n  if (this.route) {\n    // pass options to that we can set reactive: false\n    this.setParams(this.route.params(url), options);\n  }\n};\n\n/**\n * Returns an array of hook functions for the given hook names. Hooks are\n * collected in this order:\n *\n * router global hooks\n * route option hooks\n * prototype of the controller\n * this object for the controller\n *\n * For example, this.collectHooks('onBeforeAction', 'before')\n * will return an array of hook functions where the key is either onBeforeAction\n * or before.\n *\n * Hook values can also be strings in which case they are looked up in the\n * Iron.Router.hooks object.\n *\n * TODO: Add an options last argument which can specify to only collect hooks\n * for a particular environment (client, server or both).\n */\nRouteController.prototype._collectHooks = function (/* hook1, alias1, ... */) {\n  var self = this;\n  var hookNames = _.toArray(arguments);\n\n  var getHookValues = function (value) {\n    if (!value)\n      return [];\n    var lookupHook = self.router.lookupHook;\n    var hooks = _.isArray(value) ? value : [value];\n    return _.map(hooks, function (h) { return lookupHook(h); });\n  };\n\n  var collectInheritedHooks = function (ctor, hookName) {\n    var hooks = [];\n\n    if (ctor.__super__)\n      hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor, hookName));\n\n    return _.has(ctor.prototype, hookName) ?\n      hooks.concat(getHookValues(ctor.prototype[hookName])) : hooks;\n  };\n\n  var eachHook = function (cb) {\n    for (var i = 0; i < hookNames.length; i++) {\n      cb(hookNames[i]);\n    }\n  };\n\n  var routerHooks = [];\n  eachHook(function (hook) {\n    var name = self.route && self.route.getName();\n    var hooks = self.router.getHooks(hook, name);\n    routerHooks = routerHooks.concat(hooks);\n  });\n\n  var protoHooks = [];\n  eachHook(function (hook) {\n    var hooks = collectInheritedHooks(self.constructor, hook);\n    protoHooks = protoHooks.concat(hooks);\n  });\n\n  var thisHooks = [];\n  eachHook(function (hook) {\n    if (_.has(self, hook)) {\n      var hooks = getHookValues(self[hook]);\n      thisHooks = thisHooks.concat(hooks);\n    }\n  });\n\n  var routeHooks = [];\n  if (self.route) {\n    eachHook(function (hook) {\n      var hooks = getHookValues(self.route.options[hook]);\n      routeHooks = routeHooks.concat(hooks);\n    });\n  }\n\n  var allHooks = routerHooks\n    .concat(routeHooks)\n    .concat(protoHooks)\n    .concat(thisHooks);\n\n  return allHooks;\n};\n\n/**\n * Runs each hook and returns the number of hooks that were run.\n */\nRouteController.prototype.runHooks = function (/* hook, alias1, ...*/ ) {\n  var hooks = this._collectHooks.apply(this, arguments);\n  for (var i = 0, l = hooks.length; i < l; i++) {\n    var h = hooks[i];\n    h.call(this);\n  }\n  return hooks.length;\n};\n\nRouteController.prototype.getParams = function () {\n  return this.params;\n};\n\nRouteController.prototype.setParams = function (value) {\n  this.params = value;\n  return this;\n};\n\nIron.RouteController = RouteController;\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/route_controller_server.js                                        //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar Fiber = Npm.require('fibers');\nvar Controller = Iron.Controller;\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\n\n/*****************************************************************************/\n/* RouteController */\n/*****************************************************************************/\n\n/**\n * Server specific initialization.\n */\nRouteController.prototype.init = function (options) {};\n\n/**\n * Let this controller run a dispatch process. This function will be called\n * from the router. That way, any state associated with the dispatch can go on\n * the controller instance. Note: no result returned from dispatch because its\n * run inside its own fiber. Might at some point move the fiber stuff to a\n * higher layer.\n */\nRouteController.prototype.dispatch = function (stack, url, done) {\n  var self = this;\n  Fiber(function () {\n    stack.dispatch(url, self, done);\n  }).run();\n};\n\n/**\n * Run a route on the server. When the router runs its middleware stack, it\n * can run regular middleware functions or it can run a route. There should\n * only one route object per path as where there may be many middleware\n * functions.\n *\n * For example:\n *\n *   \"/some/path\" => [middleware1, middleware2, route, middleware3]\n *\n * When a route is dispatched, it tells the controller to _runRoute so that\n * the controller can control the process. At this point we should already be\n * in a dispatch so a computation should already exist.\n */\nRouteController.prototype._runRoute = function (route, url, done) {\n  var self = this;\n  var stack = new MiddlewareStack;\n\n  var onRunHooks = this._collectHooks('onRun', 'load');\n  stack = stack.append(onRunHooks, {where: 'server'});\n\n  var beforeHooks = this._collectHooks('onBeforeAction', 'before');\n  stack.append(beforeHooks, {where: 'server'});\n\n  // make sure the action stack has at least one handler on it that defaults\n  // to the 'action' method\n  if (route._actionStack.length === 0) {\n    route._actionStack.push(route._path, 'action', route.options);\n  }\n\n  stack = stack.concat(route._actionStack);\n  stack.dispatch(url, this, done);\n\n  // run the after hooks.\n  this.next = function () {};\n  this.runHooks('onAfterAction', 'after');\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/route.js                                                          //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nvar Url = Iron.Url;\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* Both */\n/*****************************************************************************/\nRoute = function (path, fn, options) {\n  var route = function (req, res, next) {\n    var controller = this;\n    controller.request = req;\n    controller.response = res;\n    route.dispatch(req.url, controller, next);\n  }\n\n  if (typeof fn === 'object') {\n    options = fn;\n    fn = options.action;\n  }\n\n  options = options || {};\n\n  if (typeof path === 'string' && path.charAt(0) !== '/') {\n    path = options.path ? options.path : '/' + path\n  }\n\n  // extend the route function with properties from this instance and its\n  // prototype.\n  _.extend(route, this.constructor.prototype);\n\n  // always good to have options\n  options = route.options = options || {};\n\n  // the main action function as well as any HTTP VERB action functions will go\n  // onto this stack.\n  route._actionStack = new MiddlewareStack;\n\n  // any before hooks will go onto this stack to make sure they get executed\n  // before the action stack.\n  route._beforeStack = new MiddlewareStack;\n  route._beforeStack.append(route.options.onBeforeAction);\n  route._beforeStack.append(route.options.before);\n\n  // after hooks get run after the action stack\n  route._afterStack = new MiddlewareStack;\n  route._afterStack.append(route.options.onAfterAction);\n  route._afterStack.append(route.options.after);\n\n\n  // track which methods this route uses\n  route._methods = {};\n\n  if (typeof fn === 'string') {\n    route._actionStack.push(path, _.extend(options, {\n      template: fn\n    }));\n  } else if (typeof fn === 'function' || typeof fn === 'object') {\n    route._actionStack.push(path, fn, options);\n  }\n\n  route._path = path;\n  return route;\n};\n\n/**\n * The name of the route is actually stored on the handler since a route is a\n * function that has an unassignable \"name\" property.\n */\nRoute.prototype.getName = function () {\n  return this.handler && this.handler.name;\n};\n\n/**\n * Returns an appropriate RouteController constructor the this Route.\n *\n * There are three possibilities:\n *\n *  1. controller option provided as a string on the route\n *  2. a controller in the global namespace with the converted name of the route\n *  3. a default RouteController\n *\n */\nRoute.prototype.findControllerConstructor = function () {\n  var self = this;\n\n  var resolve = function (name, opts) {\n    opts = opts || {};\n    var C = Iron.utils.resolve(name);\n    if (!C || !RouteController.prototype.isPrototypeOf(C.prototype)) {\n      if (opts.supressErrors !== true)\n        throw new Error(\"RouteController '\" + name + \"' is not defined.\");\n      else\n        return undefined;\n    } else {\n      return C;\n    }\n  };\n\n  var convert = function (name) {\n    return self.router.toControllerName(name);\n  };\n\n  var result;\n  var name = this.getName();\n\n  // the controller was set directly\n  if (typeof this.options.controller === 'function')\n    return this.options.controller;\n\n  // was the controller specified precisely by name? then resolve to an actual\n  // javascript constructor value\n  else if (typeof this.options.controller === 'string')\n    return resolve(this.options.controller);\n\n  // is there a default route controller configured?\n  else if (this.router && this.router.options.controller) {\n    if (typeof this.router.options.controller === 'function')\n      return this.router.options.controller;\n\n    else if (typeof this.router.options.controller === 'string')\n      return resolve(this.router.options.controller);\n  }\n\n  // otherwise do we have a name? try to convert the name to a controller name\n  // and resolve it to a value\n  else if (name && (result = resolve(convert(name), {supressErrors: true})))\n    return result;\n\n  // otherwise just use an anonymous route controller\n  else\n    return RouteController;\n};\n\n\n/**\n * Create a new controller for the route.\n */\nRoute.prototype.createController = function (options) {\n  options = options || {};\n  var C = this.findControllerConstructor();\n  options.route = this;\n  var instance = new C(options);\n  return instance;\n};\n\nRoute.prototype.setControllerParams = function (controller, url) {\n};\n\n/**\n * Dispatch into the route's middleware stack.\n */\nRoute.prototype.dispatch = function (url, context, done) {\n  // call runRoute on the controller which will behave similarly to the previous\n  // version of IR.\n  assert(context._runRoute, \"context doesn't have a _runRoute method\");\n  return context._runRoute(this, url, done);\n};\n\n/**\n * Returns a relative path for the route.\n */\nRoute.prototype.path = function (params, options) {\n  return this.handler.resolve(params, options);\n};\n\n/**\n * Return a fully qualified url for the route, given a set of parmeters and\n * options like hash and query.\n */\nRoute.prototype.url = function (params, options) {\n  var path = this.path(params, options);\n  var host = (options && options.host) || Meteor.absoluteUrl();\n\n  if (host.charAt(host.length-1) === '/')\n    host = host.slice(0, host.length-1);\n  return host + path;\n};\n\n/**\n * Return a params object for the route given a path.\n */\nRoute.prototype.params = function (path) {\n  return this.handler.params(path);\n};\n\n/**\n * Add convenience methods for each HTTP verb.\n *\n * Example:\n *  var route = router.route('/item')\n *    .get(function () { })\n *    .post(function () { })\n *    .put(function () { })\n */\n_.each(HTTP_METHODS, function (method) {\n  Route.prototype[method] = function (fn) {\n    // track the method being used for OPTIONS requests.\n    this._methods[method] = true;\n\n    this._actionStack.push(this._path, fn, {\n      // give each method a unique name so it doesn't clash with the route's\n      // name in the action stack\n      name: this.getName() + '_' + method.toLowerCase(),\n      method: method,\n\n      // for now just make the handler where the same as the route, presumably a\n      // server route.\n      where: this.handler.where,\n      mount: false\n    });\n\n    return this;\n  };\n});\n\nIron.Route = Route;\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/router.js                                                         //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar MiddlewareStack = Iron.MiddlewareStack;\nvar Url = Iron.Url;\nvar Layout = Iron.Layout;\nvar warn = Iron.utils.warn;\nvar assert = Iron.utils.assert;\n\nRouter = function (options) {\n  // keep the same api throughout which is:\n  // fn(url, context, done);\n  function router (req, res, next) {\n    //XXX this assumes no other routers on the parent stack which we should probably fix\n    router.dispatch(req.url, {\n      request: req,\n      response: res\n    }, next);\n  }\n\n  // the main router stack\n  router._stack = new MiddlewareStack;\n\n  // for storing global hooks like before, after, etc.\n  router._globalHooks = {};\n\n  // backward compat and quicker lookup of Route handlers vs. regular function\n  // handlers.\n  router.routes = [];\n\n  // to make sure we don't have more than one route per path\n  router.routes._byPath = {};\n\n  // always good to have options\n  this.configure.call(router, options);\n\n  // add proto properties to the router function\n  _.extend(router, this.constructor.prototype);\n\n  // let client and server side routing doing different things here\n  this.init.call(router, options);\n\n  Meteor.startup(function () {\n    Meteor.defer(function () {\n      if (router.options.autoStart !== false)\n        router.start();\n    });\n  });\n\n  return router;\n};\n\nRouter.prototype.init = function (options) {};\n\nRouter.prototype.configure = function (options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (value) {\n    if (!value)\n      return [];\n\n    if (_.isArray(value))\n      return value;\n\n    return [value];\n  };\n\n  // e.g. before: fn OR before: [fn1, fn2]\n  _.each(Iron.Router.HOOK_TYPES, function eachHookType (type) {\n    if (options[type]) {\n      _.each(toArray(options[type]), function eachHook (hook) {\n        self.addHook(type, hook);\n      });\n\n      delete options[type];\n    }\n  });\n\n  this.options = this.options || {};\n  _.extend(this.options, options);\n\n  return this;\n};\n\n/**\n * Just to support legacy calling. Doesn't really serve much purpose.\n */\nRouter.prototype.map = function (fn) {\n  return fn.call(this);\n};\n\n/*\n * XXX removing for now until this is thought about more carefully.\nRouter.prototype.use = function (path, fn, opts) {\n  if (typeof path === 'function') {\n    opts = fn || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, opts);\n  } else {\n    opts = opts || {};\n    opts.mount = true;\n    opts.where = opts.where || 'server';\n    this._stack.push(path, fn, opts);\n  }\n\n  return this;\n};\n*/\n\n//XXX seems like we could put a params method on the route directly and make it reactive\nRouter.prototype.route = function (path, fn, opts) {\n  var typeOf = function (val) { return Object.prototype.toString.call(val); };\n  assert(typeOf(path) === '[object String]' || typeOf(path) === '[object RegExp]', \"Router.route requires a path that is a string or regular expression.\");\n\n  if (typeof fn === 'object') {\n    opts = fn;\n    fn = opts.action;\n  }\n\n  var route = new Route(path, fn, opts);\n\n  opts = opts || {};\n\n  // don't mount the route\n  opts.mount = false;\n\n  // stack expects a function which is exactly what a new Route returns!\n  var handler = this._stack.push(path, route, opts);\n\n  handler.route = route;\n  route.handler = handler;\n  route.router = this;\n\n  assert(!this.routes._byPath[handler.path],\n    \"A route for the path \" + JSON.stringify(handler.path) + \" already exists by the name of \" + JSON.stringify(handler.name) + \".\");\n  this.routes._byPath[handler.path] = route;\n\n  this.routes.push(route);\n\n  if (typeof handler.name === 'string')\n    this.routes[handler.name] = route;\n\n  return route;\n};\n\n/**\n * Find the first route for the given url and options.\n */\nRouter.prototype.findFirstRoute = function (url) {\n  var isMatch;\n  var route;\n  for (var i = 0; i < this.routes.length; i++) {\n    route = this.routes[i];\n\n    // only matches if the url matches AND the\n    // current environment matches.\n    isMatch = route.handler.test(url, {\n      where: Meteor.isServer ? 'server' : 'client'\n    });\n\n    if (isMatch)\n      return route;\n  }\n\n  return null;\n};\n\nRouter.prototype.path = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.path for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.path(params, options);\n};\n\nRouter.prototype.url = function (routeName, params, options) {\n  var route = this.routes[routeName];\n  warn(route, \"You called Router.url for a route named \" + JSON.stringify(routeName) + \" but that route doesn't seem to exist. Are you sure you created it?\");\n  return route && route.url(params, options);\n};\n\n/**\n * Create a new controller for a dispatch.\n */\nRouter.prototype.createController = function (url, context) {\n  // see if there's a route for this url and environment\n  // it's possible that we find a route but it's a client\n  // route so we don't instantiate its controller and instead\n  // use an anonymous controller to run the route.\n  var route = this.findFirstRoute(url);\n  var controller;\n\n  context = context || {};\n\n  if (route)\n    // let the route decide what controller to use\n    controller = route.createController({layout: this._layout});\n  else\n    // create an anonymous controller\n    controller = new RouteController({layout: this._layout});\n\n  controller.router = this;\n  controller.configureFromUrl(url, context, {reactive: false});\n  return controller;\n};\n\nRouter.prototype.setTemplateNameConverter = function (fn) {\n  this._templateNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.setControllerNameConverter = function (fn) {\n  this._controllerNameConverter = fn;\n  return this;\n};\n\nRouter.prototype.toTemplateName = function (str) {\n  if (this._templateNameConverter)\n    return this._templateNameConverter(str);\n  else\n    return Iron.utils.classCase(str);\n};\n\nRouter.prototype.toControllerName = function (str) {\n  if (this._controllerNameConverter)\n    return this._controllerNameConverter(str);\n  else\n    return Iron.utils.classCase(str) + 'Controller';\n};\n\n/**\n *\n * Add a hook to all routes. The hooks will apply to all routes,\n * unless you name routes to include or exclude via `only` and `except` options\n *\n * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n * @param {Object} [options] Options to controll the hooks [optional]\n * @param {Function} [hook] Callback to run\n * @return {IronRouter}\n * @api public\n *\n */\n\nRouter.prototype.addHook = function(type, hook, options) {\n  var self = this;\n\n  options = options || {};\n\n  var toArray = function (input) {\n    if (!input)\n      return [];\n    else if (_.isArray(input))\n      return input;\n    else\n      return [input];\n  }\n\n  if (options.only)\n    options.only = toArray(options.only);\n  if (options.except)\n    options.except = toArray(options.except);\n\n  var hooks = this._globalHooks[type] = this._globalHooks[type] || [];\n\n  var hookWithOptions = function () {\n    var thisArg = this;\n    var args = arguments;\n    // this allows us to bind hooks to options that get looked up when you call\n    // this.lookupOption from within the hook. And it looks better to keep\n    // plugin/hook related options close to their definitions instead of\n    // Router.configure. But we use a dynamic variable so we don't have to\n    // pass the options explicitly as an argument and plugin creators can\n    // just use this.lookupOption which will follow the proper lookup chain from\n    // \"this\", local options, dynamic variable options, route, router, etc.\n    return CurrentOptions.withValue(options, function () {\n      return self.lookupHook(hook).apply(thisArg, args);\n    });\n  };\n\n  hooks.push({options: options, hook: hookWithOptions});\n  return this;\n};\n\n/**\n * If the argument is a function return it directly. If it's a string, see if\n * there is a function in the Iron.Router.hooks namespace. Throw an error if we\n * can't find the hook.\n */\nRouter.prototype.lookupHook = function (nameOrFn) {\n  var fn = nameOrFn;\n\n  // if we already have a func just return it\n  if (_.isFunction(fn))\n    return fn;\n\n  // look up one of the out-of-box hooks like\n  // 'loaded or 'dataNotFound' if the nameOrFn is a\n  // string\n  if (_.isString(fn)) {\n    if (_.isFunction(Iron.Router.hooks[fn]))\n      return Iron.Router.hooks[fn];\n  }\n\n  // we couldn't find it so throw an error\n  throw new Error(\"No hook found named: \" + nameOrFn);\n};\n\n/**\n *\n * Fetch the list of global hooks that apply to the given route name.\n * Hooks are defined by the .addHook() function above.\n *\n * @param {String} [type] one of IronRouter.HOOK_TYPES\n * @param {String} [name] the name of the route we are interested in\n * @return {[Function]} [hooks] an array of hooks to run\n * @api public\n *\n */\n\nRouter.prototype.getHooks = function(type, name) {\n  var self = this;\n  var hooks = [];\n\n  _.each(this._globalHooks[type], function(hook) {\n    var options = hook.options;\n\n    if (options.except && _.include(options.except, name))\n      return [];\n\n    if (options.only && ! _.include(options.only, name))\n      return [];\n\n    hooks.push(hook.hook);\n  });\n\n  return hooks;\n};\n\nRouter.HOOK_TYPES = [\n  'onRun',\n  'onRerun',\n  'onBeforeAction',\n  'onAfterAction',\n  'onStop',\n\n  // not technically a hook but we'll use it\n  // in a similar way. This will cause waitOn\n  // to be added as a method to the Router and then\n  // it can be selectively applied to specific routes\n  'waitOn',\n  'subscriptions',\n\n  // legacy hook types but we'll let them slide\n  'load', // onRun\n  'before', // onBeforeAction\n  'after', // onAfterAction\n  'unload' // onStop\n];\n\n/**\n * A namespace for hooks keyed by name.\n */\nRouter.hooks = {};\n\n\n/**\n * A namespace for plugin functions keyed by name.\n */\nRouter.plugins = {};\n\n/**\n * Auto add helper mtehods for all the hooks.\n */\n\n_.each(Router.HOOK_TYPES, function (type) {\n  Router.prototype[type] = function (hook, options) {\n    this.addHook(type, hook, options);\n  };\n});\n\n/**\n * Add a plugin to the router instance.\n */\nRouter.prototype.plugin = function (nameOrFn, options) {\n  var func;\n\n  if (typeof nameOrFn === 'function')\n    func = nameOrFn;\n  else if (typeof nameOrFn === 'string')\n    func = Iron.Router.plugins[nameOrFn];\n\n  if (!func)\n    throw new Error(\"No plugin found named \" + JSON.stringify(nameOrFn));\n\n  // fn(router, options)\n  func.call(this, this, options);\n\n  return this;\n};\n\nIron.Router = Router;\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/hooks.js                                                          //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nif (typeof Template !== 'undefined') {\n  /**\n   * The default anonymous loading template.\n   */\n  var defaultLoadingTemplate = new Template('DefaultLoadingTemplate', function () {\n    return 'Loading...';\n  });\n\n  /**\n   * The default anonymous data not found template.\n   */\n  var defaultDataNotFoundTemplate = new Template('DefaultDataNotFoundTemplate', function () {\n    return 'Data not found...';\n  });\n}\n\n/**\n * Automatically render a loading template into the main region if the\n * controller is not ready (i.e. this.ready() is false). If no loadingTemplate\n * is defined use some default text.\n */\n\nRouter.hooks.loading = function () {\n  // if we're ready just pass through\n  if (this.ready()) {\n    this.next();\n    return;\n  }\n\n  var template = this.lookupOption('loadingTemplate');\n  this.render(template || defaultLoadingTemplate);\n  this.renderRegions();\n};\n\n/**\n * Render a \"data not found\" template if a global data function returns a falsey\n * value\n */\nRouter.hooks.dataNotFound = function () {\n  if (!this.ready()) {\n    this.next();\n    return;\n  }\n\n  var data = this.lookupOption('data');\n  var dataValue;\n  var template = this.lookupOption('notFoundTemplate');\n\n  if (typeof data === 'function') {\n    if (!(dataValue = data.call(this))) {\n      this.render(template || defaultDataNotFoundTemplate);\n      this.renderRegions();\n      return;\n    }\n  }\n\n  // okay never mind just pass along now\n  this.next();\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/helpers.js                                                        //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar warn = Iron.utils.warn;\nvar DynamicTemplate = Iron.DynamicTemplate;\nvar debug = Iron.utils.debug('iron:router <helpers>');\n\n/*****************************************************************************/\n/* UI Helpers */\n/*****************************************************************************/\n\n/**\n * Render the Router to a specific location on the page instead of the\n * document.body. \n */\nUI.registerHelper('Router', new Blaze.Template('Router', function () {\n  return Router.createView();\n}));\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('pathFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"pathFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  return path;\n});\n\n/**\n * Returns a relative path given a route name, data context and optional query\n * and hash parameters.\n */\nUI.registerHelper('urlFor', function (options) {\n  var routeName;\n\n  if (arguments.length > 1) {\n    routeName = arguments[0];\n    options = arguments[1] || {};\n  } \n\n  var opts = options && options.hash;\n\n  opts = opts || {};\n  var url = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = routeName || opts.route;\n  var data = _.extend({}, opts.data || this);\n\n  var route = Router.routes[routeName];\n  warn(route, \"urlFor couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    url = route.url(data, {query: query, hash: hash});\n  }\n\n  return url;\n});\n\n/**\n * Create a link with optional content block.\n *\n * Example:\n *   {{#linkTo route=\"one\" query=\"query\" hash=\"hash\" class=\"my-cls\"}}\n *    <div>My Custom Link Content</div>\n *   {{/linkTo}}\n */\nUI.registerHelper('linkTo', new Blaze.Template('linkTo', function () {\n  var self = this;\n  var opts = DynamicTemplate.getInclusionArguments(this);\n\n  if (typeof opts !== 'object')\n    throw new Error(\"linkTo options must be key value pairs such as {{#linkTo route='my.route.name'}}. You passed: \" + JSON.stringify(opts));\n\n  opts = opts || {};\n  var path = '';\n  var query = opts.query;\n  var hash = opts.hash;\n  var routeName = opts.route;\n  var data = _.extend({}, opts.data || DynamicTemplate.getParentDataContext(this));\n  var route = Router.routes[routeName];\n  var paramKeys;\n\n  warn(route, \"linkTo couldn't find a route named \" + JSON.stringify(routeName));\n\n  if (route) {\n    _.each(route.handler.compiledUrl.keys, function (keyConfig) {\n      var key = keyConfig.name;\n      if (_.has(opts, key)) {\n        data[key] = EJSON.clone(opts[key]);\n\n        // so the option doesn't end up on the element as an attribute\n        delete opts[key];\n      }\n    });\n\n    path = route.path(data, {query: query, hash: hash});\n  }\n\n  // anything that isn't one of our keywords we'll assume is an attributed\n  // intended for the <a> tag\n  var attrs = _.omit(opts, 'route', 'query', 'hash', 'data');\n  attrs.href = path;\n\n  return Blaze.With(function () {\n    return DynamicTemplate.getParentDataContext(self);\n  }, function () {\n    return HTML.A(attrs, self.templateContentBlock);\n  });\n}));\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/body_parser_server.js                                             //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nRouter.bodyParser = Npm.require('body-parser');\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/router_server.js                                                  //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nvar assert = Iron.utils.assert;\n\nvar env = process.env.NODE_ENV || 'development';\n\n/**\n * Server specific initialization.\n */\nRouter.prototype.init = function (options) {};\n\n/**\n * Give people a chance to customize the body parser\n * behavior.\n */\nRouter.prototype.configureBodyParsers = function () {\n  Router.onBeforeAction(Iron.Router.bodyParser.json());\n  Router.onBeforeAction(Iron.Router.bodyParser.urlencoded({extended: false}));\n};\n\n/**\n * Add the router to the server connect handlers.\n */\nRouter.prototype.start = function () {\n  WebApp.connectHandlers.use(this);\n  this.configureBodyParsers();\n};\n\n/**\n * Create a new controller and dispatch into the stack.\n */\nRouter.prototype.dispatch = function (url, context, done) {\n  var self = this;\n\n  assert(typeof url === 'string', \"expected url string in router dispatch\");\n  assert(typeof context === 'object', \"expected context object in router dispatch\");\n\n  // assumes there is only one router\n  // XXX need to initialize controller either from the context itself or if the\n  // context already has a controller on it, just use that one.\n  var controller = this.createController(url, context);\n\n  controller.dispatch(this._stack, url, function (err) {\n    var res = this.response;\n    var req = this.request;\n    var msg;\n\n    if (err) {\n      if (res.statusCode < 400) \n        res.statusCode = 500;\n\n      if (err.status)\n        res.statusCode = err.status;\n\n      if (env === 'development')\n        msg = (err.stack || err.toString()) + '\\n';\n      else\n        //XXX get this from standard dict of error messages?\n        msg = 'Server error.';\n\n      console.error(err.stack || err.toString());\n\n      if (res.headersSent)\n        return req.socket.destroy();\n\n      res.setHeader('Content-Type', 'text/html');\n      res.setHeader('Content-Length', Buffer.byteLength(msg));\n      if (req.method === 'HEAD')\n        return res.end();\n      res.end(msg);\n      return;\n    }\n\n    // if there are no client or server handlers for this dispatch\n    // then send a 404.\n    // XXX we need a solution here for 404s on bad routes.\n    //     one solution might be to provide a custom 404 page in the public\n    //     folder. But we need a proper way to handle 404s for search engines.\n    // XXX might be a PR to Meteor to use an existing status code if it's set\n    if (!controller.isHandled() && !controller.willBeHandledOnClient()) {\n      return done();\n      /*\n      res.statusCode = 404;\n      res.setHeader('Content-Type', 'text/html');\n      msg = req.method + ' ' + req.originalUrl + ' not found.';\n      console.error(msg);\n      if (req.method == 'HEAD')\n        return res.end();\n      res.end(msg + '\\n');\n      return;\n      */\n    }\n\n    // if for some reason there was a server handler but no client handler\n    // and the server handler called next() we might end up here. We\n    // want to make sure to end the response so it doesn't hang.\n    if (controller.isHandled() && !controller.willBeHandledOnClient()) {\n      res.setHeader('Content-Type', 'text/html');\n      if (req.method === 'HEAD')\n        res.end();\n      res.end(\"<p>It looks like you don't have any client routes defined, but you had at least one server handler. You probably want to define some client side routes!</p>\\n\");\n    }\n\n    // we'll have Meteor load the normal application so long as\n    // we have at least one client route/handler and the done() iterator\n    // function has been passed to us, presumably from Connect.\n    if (controller.willBeHandledOnClient() && done)\n      return done(err);\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/plugins.js                                                        //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\n/**\n * Simple plugin wrapper around the loading hook.\n */\nRouter.plugins.loading = function (router, options) {\n  router.onBeforeAction('loading', options);\n};\n\n/**\n * Simple plugin wrapper around the dataNotFound hook.\n */\nRouter.plugins.dataNotFound = function (router, options) {\n  router.onBeforeAction('dataNotFound', options);\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                            //\n// packages/iron_router/lib/global_router.js                                                  //\n//                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                              //\nRouter = new Iron.Router;\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"iron:router\", {\n  Router: Router,\n  RouteController: RouteController\n});\n\n})();\n","servePath":"/packages/iron_router.js"}]