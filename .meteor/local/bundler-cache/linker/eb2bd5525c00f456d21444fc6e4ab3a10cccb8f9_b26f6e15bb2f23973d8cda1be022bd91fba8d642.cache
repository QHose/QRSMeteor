[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Accounts = Package['accounts-base'].Accounts;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\nvar Hook = Package['callback-hook'].Hook;\nvar ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;\n\n/* Package-scope variables */\nvar LoginState;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/brettle_accounts-login-state/accounts-login-state-server.js         //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\n/* globals ServiceConfiguration, Hook, LoginState: true */\n\"use strict\";\n\nfunction LoginStateConstructor() {\n  var self = this;\n\n  self._signedUpHook = new Hook({\n    debugPrintExceptions: \"LoginState signedUp interceptor callback\",\n  });\n\n  self._interceptorsChangedHook = new Hook({\n    debugPrintExceptions: \"LoginState interceptorsChanged callback\"\n  });\n\n  // If accounts-password is installed and the user has a username, or at\n  // least one email address, then they are signed up.\n  if (Package['accounts-password']) {\n    self.addSignedUpInterceptor(function (u) {\n      if (u && u.services && u.services.password &&\n        (typeof (u.username) === 'string' ||\n          (u.emails && u.emails[0] &&\n            typeof (u.emails[0].address) === 'string'))) {\n        u.loginStateSignedUp = true;\n      }\n    });\n  }\n  self.addSignedUpInterceptor(function (u) {\n    var usedServices = _.keys(u.services);\n    var configuredServices =\n      ServiceConfiguration.configurations.find().map(function (config) {\n        return config.service;\n      });\n    if (_.intersection(configuredServices, usedServices).length > 0) {\n      u.loginStateSignedUp = true;\n    }\n  });\n}\n\nLoginStateConstructor.prototype.loggedIn = function () {\n  return (!! Meteor.userId());\n};\n\nLoginStateConstructor.prototype.signedUp = function (user) {\n  var self = this;\n  if (user === undefined) {\n    user = Meteor.user();\n  }\n  if (!user) {\n    return false;\n  }\n  user.loginStateSignedUp = false;\n  self._signedUpHook.each(function (cb) {\n    cb(user);\n    return true;\n  });\n\n  return user.loginStateSignedUp;\n};\n\nLoginStateConstructor.prototype.addSignedUpInterceptor = function (cb) {\n  var self = this;\n  var stopper = self._signedUpHook.register(cb);\n  self._fireInterceptorsChanged();\n\n  var origStop = stopper.stop;\n  stopper.stop = function ( /* arguments */ ) {\n    origStop.apply(this, arguments);\n    self._fireInterceptorsChanged();\n  };\n  return stopper;\n};\n\nLoginStateConstructor.prototype._onInterceptorsChanged = function (cb) {\n  var self = this;\n  return self._interceptorsChangedHook.register(cb);\n};\n\nLoginStateConstructor.prototype._fireInterceptorsChanged = function () {\n  var self = this;\n  self._interceptorsChangedHook.each(function (cb) {\n    cb();\n    return true;\n  });\n};\n\nLoginState = new LoginStateConstructor();\n\n// Add a client-only `loginStateSignedUp` property to the current user record\n// and keep it updated to refect whether the user has signed up according the\n// the callbacks registered with `LoginState.addSignedUpInterceptor()`.\nMeteor.publish(null, function () {\n  var self = this;\n  // The function to call to notify the subscriber. We initially set it to\n  // self.added to workaround meteorhacks:fast-render issue #142\n  // (https://github.com/kadirahq/fast-render/issues/142). Once self.added() is\n  // called once, we set it to self.changed().\n  var updateFunc = self.added.bind(self);\n  \n  if (!self.userId) {\n    return null;\n  }\n  var userObserverStopper = Meteor.users.find({\n    _id: self.userId\n  }).observeChanges({\n    added: updateLoginStateSignedUp,\n    changed: updateLoginStateSignedUp\n  });\n\n  var configsObserverStopper =\n    ServiceConfiguration.configurations.find().observe({\n      added: updateLoginStateSignedUp,\n      removed: updateLoginStateSignedUp\n    });\n\n  var interceptorsChangedStopper =\n    LoginState._onInterceptorsChanged(updateLoginStateSignedUp);\n\n  self.onStop(function () {\n    userObserverStopper.stop();\n    configsObserverStopper.stop();\n    interceptorsChangedStopper.stop();\n  });\n\n  self.ready();\n\n  function updateLoginStateSignedUp() {\n    var user = Meteor.users.findOne({\n      _id: self.userId\n    });\n    if (!user) {\n      // user has been removed, so no need to change.\n      // Also LoginState.signedUp() would call Meteor.user() if the user it is\n      // passed is falsey, and that would trigger an console error about\n      // needing to use this.userId instead.\n      return;\n    }\n    updateFunc('users', self.userId, {\n      loginStateSignedUp: LoginState.signedUp(user)\n    });\n    updateFunc = self.changed.bind(self);\n  }\n});\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"brettle:accounts-login-state\", {\n  LoginState: LoginState\n});\n\n})();\n","servePath":"/packages/brettle_accounts-login-state.js"}]