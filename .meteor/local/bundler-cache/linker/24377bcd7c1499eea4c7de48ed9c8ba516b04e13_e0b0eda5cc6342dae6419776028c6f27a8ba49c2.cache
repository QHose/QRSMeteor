[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar DDP = Package['ddp-client'].DDP;\nvar HTTP = Package.http.HTTP;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar _ = Package.underscore._;\nvar Promise = Package.promise.Promise;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Symbol = Package['ecmascript-runtime-client'].Symbol;\nvar Map = Package['ecmascript-runtime-client'].Map;\nvar Set = Package['ecmascript-runtime-client'].Set;\n\n/* Package-scope variables */\nvar denodeify, addReadyPromise, ReactivePromise, reactiveValue;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"deanius:promise\":{\"client\":{\"denodeifyFunctions.js\":function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/deanius_promise/client/denodeifyFunctions.js                                                        //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n// This implementation of denodeify, taken from\n// https://github.com/matthew-andrews/denodeify/blob/bbc334a90a4b036f491f766ce335fca7bd274109/index.js\n// works in ways that Promise.denodeify does not (meteor-promise-docs shows [Object object]),\n// Probably because the Object type returned doesn't pass the test of `instanceof Promise`\ndenodeify = function () {\n  function denodeify(nodeStyleFunction, filter) {\n    'use strict';\n\n    return function () {\n      var self = this;\n      var functionArguments = new Array(arguments.length + 1);\n\n      for (var i = 0; i < arguments.length; i += 1) {\n        functionArguments[i] = arguments[i];\n      }\n\n      function promiseHandler(resolve, reject) {\n        function callbackFunction() {\n          var args = new Array(arguments.length);\n\n          for (var i = 0; i < args.length; i += 1) {\n            args[i] = arguments[i];\n          }\n\n          if (filter) {\n            args = filter.apply(self, args);\n          }\n\n          var error = args[0];\n          var result = args[1];\n\n          if (error) {\n            return reject(error);\n          }\n\n          return resolve(result);\n        }\n\n        functionArguments[functionArguments.length - 1] = callbackFunction;\n        nodeStyleFunction.apply(self, functionArguments);\n      }\n\n      return new Promise(promiseHandler);\n    };\n  }\n\n  return denodeify;\n}();\n/**\n   * @memberOf Meteor\n   * @summary Gets a ES2015-compatible Promise for the result of a Meteor.promise\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @returns {Promise}\n   */\n\n\nMeteor.callPromise = denodeify(Meteor.call);\nMeteor.wrapPromise = denodeify;\nHTTP.callPromise = denodeify(HTTP.call);\nHTTP.getPromise = denodeify(HTTP.get);\nHTTP.postPromise = denodeify(HTTP.post);\nHTTP.putPromise = denodeify(HTTP.put);\nHTTP.deletePromise = denodeify(HTTP.delete);\n\naddReadyPromise = function (handle) {\n  handle.readyPromise = function () {\n    return new Promise(function (resolve) {\n      Tracker.autorun(function (computation) {\n        if (handle.ready()) {\n          //resolving invokes 'then' steps async, just like computation invalidations\n          resolve(true);\n          computation.stop();\n        }\n      });\n    });\n  };\n};\n\nMeteor._subscribe = Meteor.subscribe;\n\nMeteor.subscribe = function () {\n  var handle = Meteor._subscribe.apply(Meteor, arguments);\n\n  addReadyPromise(handle);\n  return handle;\n};\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"reactivePromise.js\":function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/deanius_promise/client/reactivePromise.js                                                           //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nReactivePromise = function (fn, loadingTextOrObj, errorTextOrFn) {\n  var loadingText = loadingTextOrObj && loadingTextOrObj.pending || loadingTextOrObj || \"\",\n      displayError = function (e) {\n    var errorHandler = loadingTextOrObj.rejected || errorTextOrFn;\n    return _.isFunction(errorHandler) ? errorHandler(e) : errorHandler || \"\";\n  },\n      refire = function (computation) {\n    computation.isPromiseResolve = true;\n    computation.depsNotDeleted = computation._onInvalidateCallbacks;\n    computation._onInvalidateCallbacks = [];\n    computation.invalidate();\n  },\n      cleanup = function (computation) {\n    computation._onInvalidateCallbacks = computation.depsNotDeleted;\n    delete computation.depsNotDeleted;\n    delete computation.isPromiseResolve;\n  },\n      returnValues = {};\n\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var promiseForResult;\n    var result = null;\n    args = args.slice(0, -1);\n    /*remove spacebars, the final arg*/\n\n    var argHash = EJSON.stringify(args, {\n      canonical: true\n    });\n    var helperComputation = Tracker.currentComputation;\n\n    if (helperComputation.isPromiseResolve) {\n      cleanup(helperComputation);\n      return returnValues[argHash];\n    }\n\n    reactiveValue = Tracker.autorun(function () {\n      delete returnValues[argHash];\n      result = fn.apply({}, args);\n      returnValues[argHash] = result;\n    });\n    reactiveValue.onInvalidate(function () {\n      if (!helperComputation.isPromiseResolve) {\n        delete returnValues[argHash];\n        helperComputation.invalidate();\n      }\n    });\n\n    if (returnValues[argHash] instanceof Promise) {\n      promiseForResult = result;\n      promiseForResult.then(function (v) {\n        returnValues[argHash] = v;\n        refire(helperComputation);\n        return v;\n      }, function (e) {\n        returnValues[argHash] = displayError(e);\n        refire(helperComputation);\n      }); //suppress display of [object Promise] message\n\n      returnValues[argHash] = loadingText;\n    }\n\n    return returnValues[argHash];\n  };\n};\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"runAsync.browserify.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/deanius_promise/client/runAsync.browserify.js                                                       //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar co = require('co')\n\nMeteor.runAsync = function (fn) {\n  if (fn.constructor.name !== \"GeneratorFunction\")\n    console.info(\"Meteor.runAsync can not tell if this is a generator function.\")\n\n  return co(fn)\n}\n\n},{\"co\":2}],2:[function(require,module,exports){\n\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co['default'] = co.co = co;\n\n/**\n * Wrap the given generator `fn` into a\n * function that returns a promise.\n * This is a separate function so that\n * every `co()` call doesn't create a new,\n * unnecessary closure.\n *\n * @param {GeneratorFunction} fn\n * @return {Function}\n * @api public\n */\n\nco.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n\n/**\n * Execute the generator function or a generator\n * and return a promise.\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nfunction co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1)\n\n  // we wrap everything in a promise to avoid promise chaining,\n  // which leads to memory leak errors.\n  // see https://github.com/tj/co/issues/180\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onFulfilled();\n\n    /**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     */\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     */\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     */\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n  });\n}\n\n/**\n * Convert a `yield`ed value into a promise.\n *\n * @param {Mixed} obj\n * @return {Promise}\n * @api private\n */\n\nfunction toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj;\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  if (isObject(obj)) return objectToPromise.call(this, obj);\n  return obj;\n}\n\n/**\n * Convert a thunk to a promise.\n *\n * @param {Function}\n * @return {Promise}\n * @api private\n */\n\nfunction thunkToPromise(fn) {\n  var ctx = this;\n  return new Promise(function (resolve, reject) {\n    fn.call(ctx, function (err, res) {\n      if (err) return reject(err);\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n      resolve(res);\n    });\n  });\n}\n\n/**\n * Convert an array of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Array} obj\n * @return {Promise}\n * @api private\n */\n\nfunction arrayToPromise(obj) {\n  return Promise.all(obj.map(toPromise, this));\n}\n\n/**\n * Convert an object of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Object} obj\n * @return {Promise}\n * @api private\n */\n\nfunction objectToPromise(obj){\n  var results = new obj.constructor();\n  var keys = Object.keys(obj);\n  var promises = [];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var promise = toPromise.call(this, obj[key]);\n    if (promise && isPromise(promise)) defer(promise, key);\n    else results[key] = obj[key];\n  }\n  return Promise.all(promises).then(function () {\n    return results;\n  });\n\n  function defer(promise, key) {\n    // predefine the key in the result\n    results[key] = undefined;\n    promises.push(promise.then(function (res) {\n      results[key] = res;\n    }));\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\nfunction isGeneratorFunction(obj) {\n  var constructor = obj.constructor;\n  if (!constructor) return false;\n  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;\n  return isGenerator(constructor.prototype);\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return Object == val.constructor;\n}\n\n},{}]},{},[1])\n//# sourceMappingURL=/packages/deanius_promise/client/runAsync.browserify.js\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".browserify.js\"\n  ]\n});\nrequire(\"/node_modules/meteor/deanius:promise/client/denodeifyFunctions.js\");\nrequire(\"/node_modules/meteor/deanius:promise/client/reactivePromise.js\");\nrequire(\"/node_modules/meteor/deanius:promise/client/runAsync.browserify.js\");\n\n/* Exports */\nPackage._define(\"deanius:promise\", {\n  ReactivePromise: ReactivePromise\n});\n\n})();\n","servePath":"/packages/deanius_promise.js","sourceMap":{"version":3,"sources":["packages/deanius:promise/client/denodeifyFunctions.js","packages/deanius:promise/client/reactivePromise.js","../../../cosmos_browserify/.0.8.4.vcyeo3.37en++os+web.browser+web.cordova/plugin.CosmosBrowserify.os/npm/node_modules/meteor/CosmosBrowserify/CosmosBrowserify/node_modules/browserify/node_modules/browser-pack/_prelude.js","_stream_0.js","node_modules/co/index.js"],"names":["denodeify","nodeStyleFunction","filter","self","functionArguments","Array","arguments","length","i","promiseHandler","resolve","reject","callbackFunction","args","apply","error","result","Promise","Meteor","callPromise","call","wrapPromise","HTTP","getPromise","get","postPromise","post","putPromise","put","deletePromise","delete","addReadyPromise","handle","readyPromise","Tracker","autorun","computation","ready","stop","_subscribe","subscribe","ReactivePromise","fn","loadingTextOrObj","errorTextOrFn","loadingText","pending","displayError","e","errorHandler","rejected","_","isFunction","refire","isPromiseResolve","depsNotDeleted","_onInvalidateCallbacks","invalidate","cleanup","returnValues","promiseForResult","slice","argHash","EJSON","stringify","canonical","helperComputation","currentComputation","reactiveValue","onInvalidate","then","v"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/deanius_promise.js","sourcesContent":["// This implementation of denodeify, taken from\n// https://github.com/matthew-andrews/denodeify/blob/bbc334a90a4b036f491f766ce335fca7bd274109/index.js\n// works in ways that Promise.denodeify does not (meteor-promise-docs shows [Object object]),\n// Probably because the Object type returned doesn't pass the test of `instanceof Promise`\ndenodeify = function denodeify (nodeStyleFunction, filter) {\n\t\t'use strict';\n\n\t\treturn function () {\n\t\t\tvar self = this;\n\t\t\tvar functionArguments = new Array(arguments.length + 1);\n\n\t\t\tfor (var i = 0; i < arguments.length; i += 1) {\n\t\t\t\tfunctionArguments[i] = arguments[i];\n\t\t\t}\n\n\t\t\tfunction promiseHandler (resolve, reject) {\n\t\t\t\tfunction callbackFunction () {\n\t\t\t\t\tvar args = new Array(arguments.length);\n\n\t\t\t\t\tfor (var i = 0; i < args.length; i += 1) {\n\t\t\t\t\t\targs[i] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filter) {\n\t\t\t\t\t\targs = filter.apply(self, args);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar error = args[0];\n\t\t\t\t\tvar result = args[1];\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t}\n\n\t\t\t\tfunctionArguments[functionArguments.length - 1] = callbackFunction;\n\t\t\t\tnodeStyleFunction.apply(self, functionArguments);\n\t\t\t}\n\n\t\t\treturn new Promise(promiseHandler);\n\t\t};\n\t};\n\n  /**\n     * @memberOf Meteor\n     * @summary Gets a ES2015-compatible Promise for the result of a Meteor.promise\n     * @param {String} name Name of method to invoke\n     * @param {EJSONable} [arg1,arg2...] Optional method arguments\n     * @returns {Promise}\n     */\n  Meteor.callPromise = denodeify(Meteor.call)\n\tMeteor.wrapPromise = denodeify\n\tHTTP.callPromise = denodeify(HTTP.call)\n\tHTTP.getPromise = denodeify(HTTP.get)\n\tHTTP.postPromise = denodeify(HTTP.post)\n\tHTTP.putPromise = denodeify(HTTP.put)\n\tHTTP.deletePromise = denodeify(HTTP.delete)\n\n\taddReadyPromise = (handle) => {\n\t\thandle.readyPromise = () =>\n      new Promise((resolve) => {\n  \t\t\tTracker.autorun((computation) => {\n  \t\t\t\tif (handle.ready()) {\n            //resolving invokes 'then' steps async, just like computation invalidations\n  \t\t\t\t\tresolve(true)\n  \t\t\t\t\tcomputation.stop()\n  \t\t\t\t}\n  \t\t\t})\n  \t\t})\n\t}\n\n\tMeteor._subscribe = Meteor.subscribe\n\tMeteor.subscribe = function () {\n\t\tvar handle = Meteor._subscribe.apply(Meteor, arguments);\n\t\taddReadyPromise(handle);\n\t\treturn handle;\n\t}\n","ReactivePromise = (fn, loadingTextOrObj, errorTextOrFn) => {\n  var loadingText = (loadingTextOrObj && loadingTextOrObj.pending) || loadingTextOrObj || \"\",\n      displayError = (e) => {\n        var errorHandler = loadingTextOrObj.rejected || errorTextOrFn;\n        return _.isFunction(errorHandler) ? errorHandler(e) : (errorHandler || \"\");\n      },\n      refire = (computation) => {\n        computation.isPromiseResolve = true;\n        computation.depsNotDeleted = computation._onInvalidateCallbacks;\n        computation._onInvalidateCallbacks = [];\n        computation.invalidate();\n      },\n      cleanup = (computation) => {\n        computation._onInvalidateCallbacks = computation.depsNotDeleted;\n        delete computation.depsNotDeleted;\n        delete computation.isPromiseResolve;\n      },\n      returnValues = {};\n  return ((...args) => {\n    let promiseForResult\n    let result = null\n    args = args.slice(0,-1)  /*remove spacebars, the final arg*/\n    let argHash = EJSON.stringify(args, {canonical: true})\n    let helperComputation = Tracker.currentComputation\n    if (helperComputation.isPromiseResolve) {\n      cleanup(helperComputation);\n      return returnValues[argHash];\n    }\n\n    reactiveValue = Tracker.autorun(function () {\n      delete returnValues[argHash];\n      result = fn.apply({}, args);\n      returnValues[argHash] = result;\n    });\n    reactiveValue.onInvalidate(function () {\n      if (!helperComputation.isPromiseResolve) {\n        delete returnValues[argHash];\n        helperComputation.invalidate();\n      }\n    });\n\n    if (returnValues[argHash] instanceof Promise) {\n      promiseForResult = result;\n      promiseForResult.then(function (v) {\n        returnValues[argHash] = v;\n        refire(helperComputation);\n        return v;\n      }, function (e) {\n        returnValues[argHash] = displayError(e);\n        refire(helperComputation);\n      });\n      //suppress display of [object Promise] message\n      returnValues[argHash] = loadingText;\n    }\n    return returnValues[argHash];\n  })\n\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var co = require('co')\n\nMeteor.runAsync = function (fn) {\n  if (fn.constructor.name !== \"GeneratorFunction\")\n    console.info(\"Meteor.runAsync can not tell if this is a generator function.\")\n\n  return co(fn)\n}\n","\n/**\n * slice() reference.\n */\n\nvar slice = Array.prototype.slice;\n\n/**\n * Expose `co`.\n */\n\nmodule.exports = co['default'] = co.co = co;\n\n/**\n * Wrap the given generator `fn` into a\n * function that returns a promise.\n * This is a separate function so that\n * every `co()` call doesn't create a new,\n * unnecessary closure.\n *\n * @param {GeneratorFunction} fn\n * @return {Function}\n * @api public\n */\n\nco.wrap = function (fn) {\n  createPromise.__generatorFunction__ = fn;\n  return createPromise;\n  function createPromise() {\n    return co.call(this, fn.apply(this, arguments));\n  }\n};\n\n/**\n * Execute the generator function or a generator\n * and return a promise.\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nfunction co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1)\n\n  // we wrap everything in a promise to avoid promise chaining,\n  // which leads to memory leak errors.\n  // see https://github.com/tj/co/issues/180\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onFulfilled();\n\n    /**\n     * @param {Mixed} res\n     * @return {Promise}\n     * @api private\n     */\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * @param {Error} err\n     * @return {Promise}\n     * @api private\n     */\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    /**\n     * Get the next value in the generator,\n     * return a promise.\n     *\n     * @param {Object} ret\n     * @return {Promise}\n     * @api private\n     */\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n  });\n}\n\n/**\n * Convert a `yield`ed value into a promise.\n *\n * @param {Mixed} obj\n * @return {Promise}\n * @api private\n */\n\nfunction toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj;\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj);\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n  if (isObject(obj)) return objectToPromise.call(this, obj);\n  return obj;\n}\n\n/**\n * Convert a thunk to a promise.\n *\n * @param {Function}\n * @return {Promise}\n * @api private\n */\n\nfunction thunkToPromise(fn) {\n  var ctx = this;\n  return new Promise(function (resolve, reject) {\n    fn.call(ctx, function (err, res) {\n      if (err) return reject(err);\n      if (arguments.length > 2) res = slice.call(arguments, 1);\n      resolve(res);\n    });\n  });\n}\n\n/**\n * Convert an array of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Array} obj\n * @return {Promise}\n * @api private\n */\n\nfunction arrayToPromise(obj) {\n  return Promise.all(obj.map(toPromise, this));\n}\n\n/**\n * Convert an object of \"yieldables\" to a promise.\n * Uses `Promise.all()` internally.\n *\n * @param {Object} obj\n * @return {Promise}\n * @api private\n */\n\nfunction objectToPromise(obj){\n  var results = new obj.constructor();\n  var keys = Object.keys(obj);\n  var promises = [];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var promise = toPromise.call(this, obj[key]);\n    if (promise && isPromise(promise)) defer(promise, key);\n    else results[key] = obj[key];\n  }\n  return Promise.all(promises).then(function () {\n    return results;\n  });\n\n  function defer(promise, key) {\n    // predefine the key in the result\n    results[key] = undefined;\n    promises.push(promise.then(function (res) {\n      results[key] = res;\n    }));\n  }\n}\n\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isPromise(obj) {\n  return 'function' == typeof obj.then;\n}\n\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isGenerator(obj) {\n  return 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\nfunction isGeneratorFunction(obj) {\n  var constructor = obj.constructor;\n  if (!constructor) return false;\n  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;\n  return isGenerator(constructor.prototype);\n}\n\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(val) {\n  return Object == val.constructor;\n}\n"]}}]