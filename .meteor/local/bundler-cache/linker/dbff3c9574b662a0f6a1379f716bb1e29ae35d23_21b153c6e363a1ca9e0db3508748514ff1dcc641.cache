[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Random = Package.random.Random;\nvar ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;\nvar OAuth = Package.oauth.OAuth;\nvar Oauth = Package.oauth.Oauth;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar HTTP = Package.http.HTTP;\nvar HTTPInternals = Package.http.HTTPInternals;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\n\n/* Package-scope variables */\nvar OAuth1Binding, OAuth1Test;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/oauth1/oauth1_binding.js                                                                    //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\nvar crypto = Npm.require(\"crypto\");\nvar querystring = Npm.require(\"querystring\");\nvar urlModule = Npm.require(\"url\");\n\n// An OAuth1 wrapper around http calls which helps get tokens and\n// takes care of HTTP headers\n//\n// @param config {Object}\n//   - consumerKey (String): oauth consumer key\n//   - secret (String): oauth consumer secret\n// @param urls {Object}\n//   - requestToken (String): url\n//   - authorize (String): url\n//   - accessToken (String): url\n//   - authenticate (String): url\nOAuth1Binding = function(config, urls) {\n  this._config = config;\n  this._urls = urls;\n};\n\nOAuth1Binding.prototype.prepareRequestToken = function(callbackUrl) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_callback: callbackUrl\n  });\n\n  var response = self._call('POST', self._urls.requestToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  if (! tokens.oauth_callback_confirmed)\n    throw _.extend(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"),\n                             {response: response});\n\n  self.requestToken = tokens.oauth_token;\n  self.requestTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.prepareAccessToken = function(query, requestTokenSecret) {\n  var self = this;\n\n  // support implementations that use request token secrets. This is\n  // read by self._call.\n  //\n  // XXX make it a param to call, not something stashed on self? It's\n  // kinda confusing right now, everything except this is passed as\n  // arguments, but this is stored.\n  if (requestTokenSecret)\n    self.accessTokenSecret = requestTokenSecret;\n\n  var headers = self._buildHeader({\n    oauth_token: query.oauth_token,\n    oauth_verifier: query.oauth_verifier\n  });\n\n  var response = self._call('POST', self._urls.accessToken, headers);\n  var tokens = querystring.parse(response.content);\n\n  if (! tokens.oauth_token || ! tokens.oauth_token_secret) {\n    var error = new Error(\"missing oauth token or secret\");\n    // We provide response only if no token is available, we do not want to leak any tokens\n    if (! tokens.oauth_token && ! tokens.oauth_token_secret) {\n      _.extend(error, {response: response});\n    }\n    throw error;\n  }\n\n  self.accessToken = tokens.oauth_token;\n  self.accessTokenSecret = tokens.oauth_token_secret;\n};\n\nOAuth1Binding.prototype.call = function(method, url, params, callback) {\n  var self = this;\n\n  var headers = self._buildHeader({\n    oauth_token: self.accessToken\n  });\n\n  if(! params) {\n    params = {};\n  }\n\n  return self._call(method, url, headers, params, callback);\n};\n\nOAuth1Binding.prototype.get = function(url, params, callback) {\n  return this.call('GET', url, params, callback);\n};\n\nOAuth1Binding.prototype.post = function(url, params, callback) {\n  return this.call('POST', url, params, callback);\n};\n\nOAuth1Binding.prototype._buildHeader = function(headers) {\n  var self = this;\n  return _.extend({\n    oauth_consumer_key: self._config.consumerKey,\n    oauth_nonce: Random.secret().replace(/\\W/g, ''),\n    oauth_signature_method: 'HMAC-SHA1',\n    oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\n    oauth_version: '1.0'\n  }, headers);\n};\n\nOAuth1Binding.prototype._getSignature = function(method, url, rawHeaders, accessTokenSecret, params) {\n  var self = this;\n  var headers = self._encodeHeader(_.extend({}, rawHeaders, params));\n\n  var parameters = _.map(headers, function(val, key) {\n    return key + '=' + val;\n  }).sort().join('&');\n\n  var signatureBase = [\n    method,\n    self._encodeString(url),\n    self._encodeString(parameters)\n  ].join('&');\n\n  var secret = OAuth.openSecret(self._config.secret);\n\n  var signingKey = self._encodeString(secret) + '&';\n  if (accessTokenSecret)\n    signingKey += self._encodeString(accessTokenSecret);\n\n  return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n};\n\nOAuth1Binding.prototype._call = function(method, url, headers, params, callback) {\n  var self = this;\n\n  // all URLs to be functions to support parameters/customization\n  if(typeof url === \"function\") {\n    url = url(self);\n  }\n\n  headers = headers || {};\n  params = params || {};\n\n  // Extract all query string parameters from the provided URL\n  var parsedUrl = urlModule.parse(url, true);\n  // Merge them in a way that params given to the method call have precedence\n  params = _.extend({}, parsedUrl.query, params);\n\n  // Reconstruct the URL back without any query string parameters\n  // (they are now in params)\n  parsedUrl.query = {};\n  parsedUrl.search = '';\n  url = urlModule.format(parsedUrl);\n\n  // Get the signature\n  headers.oauth_signature =\n    self._getSignature(method, url, headers, self.accessTokenSecret, params);\n\n  // Make a authorization string according to oauth1 spec\n  var authString = self._getAuthHeaderString(headers);\n\n  // Make signed request\n  try {\n    var response = HTTP.call(method, url, {\n      params: params,\n      headers: {\n        Authorization: authString\n      }\n    }, callback && function (error, response) {\n      if (! error) {\n        response.nonce = headers.oauth_nonce;\n      }\n      callback(error, response);\n    });\n    // We store nonce so that JWTs can be validated\n    if (response)\n      response.nonce = headers.oauth_nonce;\n    return response;\n  } catch (err) {\n    throw _.extend(new Error(\"Failed to send OAuth1 request to \" + url + \". \" + err.message),\n                   {response: err.response});\n  }\n};\n\nOAuth1Binding.prototype._encodeHeader = function(header) {\n  var self = this;\n  return _.reduce(header, function(memo, val, key) {\n    memo[self._encodeString(key)] = self._encodeString(val);\n    return memo;\n  }, {});\n};\n\nOAuth1Binding.prototype._encodeString = function(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\nOAuth1Binding.prototype._getAuthHeaderString = function(headers) {\n  var self = this;\n  return 'OAuth ' +  _.map(headers, function(val, key) {\n    return self._encodeString(key) + '=\"' + self._encodeString(val) + '\"';\n  }).sort().join(', ');\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/oauth1/oauth1_server.js                                                                     //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\nvar url = Npm.require(\"url\");\n\nOAuth._queryParamsWithAuthTokenUrl = function (authUrl, oauthBinding, params, whitelistedQueryParams) {\n  params = params || {};\n  var redirectUrlObj = url.parse(authUrl, true);\n\n  _.extend(\n    redirectUrlObj.query,\n    _.pick(params.query, whitelistedQueryParams),\n    {\n      oauth_token: oauthBinding.requestToken,\n    }\n  );\n\n  // Clear the `search` so it is rebuilt by Node's `url` from the `query` above.\n  // Using previous versions of the Node `url` module, this was just set to \"\"\n  // However, Node 6 docs seem to indicate that this should be `undefined`.\n  delete redirectUrlObj.search;\n\n  // Reconstruct the URL back with provided query parameters merged with oauth_token\n  return url.format(redirectUrlObj);\n};\n\n// connect middleware\nOAuth._requestHandlers['1'] = function (service, query, res) {\n  var config = ServiceConfiguration.configurations.findOne({service: service.serviceName});\n  if (! config) {\n    throw new ServiceConfiguration.ConfigError(service.serviceName);\n  }\n\n  var urls = service.urls;\n  var oauthBinding = new OAuth1Binding(config, urls);\n\n  var credentialSecret;\n\n  if (query.requestTokenAndRedirect) {\n    // step 1 - get and store a request token\n    var callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n      state: query.state,\n      cordova: (query.cordova === \"true\"),\n      android: (query.android === \"true\")\n    });\n\n    // Get a request token to start auth process\n    oauthBinding.prepareRequestToken(callbackUrl);\n\n    // Keep track of request token so we can verify it on the next step\n    OAuth._storeRequestToken(\n      OAuth._credentialTokenFromQuery(query),\n      oauthBinding.requestToken,\n      oauthBinding.requestTokenSecret);\n\n    // support for scope/name parameters\n    var redirectUrl;\n    var authParams = {\n      query: query\n    };\n\n    if(typeof urls.authenticate === \"function\") {\n      redirectUrl = urls.authenticate(oauthBinding, authParams);\n    } else {\n      redirectUrl = OAuth._queryParamsWithAuthTokenUrl(\n        urls.authenticate,\n        oauthBinding,\n        authParams\n      );\n    }\n\n    // redirect to provider login, which will redirect back to \"step 2\" below\n\n    res.writeHead(302, {'Location': redirectUrl});\n    res.end();\n  } else {\n    // step 2, redirected from provider login - store the result\n    // and close the window to allow the login handler to proceed\n\n    // Get the user's request token so we can verify it and clear it\n    var requestTokenInfo = OAuth._retrieveRequestToken(\n      OAuth._credentialTokenFromQuery(query));\n\n    if (! requestTokenInfo) {\n      throw new Error(\"Unable to retrieve request token\");\n    }\n\n    // Verify user authorized access and the oauth_token matches\n    // the requestToken from previous step\n    if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n\n      // Prepare the login results before returning.  This way the\n      // subsequent call to the `login` method will be immediate.\n\n      // Get the access token for signing requests\n      oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\n\n      // Run service-specific handler.\n      var oauthResult = service.handleOauthRequest(\n        oauthBinding, { query: query });\n\n      var credentialToken = OAuth._credentialTokenFromQuery(query);\n      credentialSecret = Random.secret();\n\n      // Store the login result so it can be retrieved in another\n      // browser tab by the result handler\n      OAuth._storePendingCredential(credentialToken, {\n        serviceName: service.serviceName,\n        serviceData: oauthResult.serviceData,\n        options: oauthResult.options\n      }, credentialSecret);\n    }\n\n    // Either close the window, redirect, or render nothing\n    // if all else fails\n    OAuth._renderOauthResults(res, query, credentialSecret);\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/oauth1/oauth1_pending_request_tokens.js                                                     //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\n//\n// _pendingRequestTokens are request tokens that have been received\n// but not yet fully authorized (processed).\n//\n// During the oauth1 authorization process, the Meteor App opens\n// a pop-up, requests a request token from the oauth1 service, and\n// redirects the browser to the oauth1 service for the user\n// to grant authorization.  The user is then returned to the\n// Meteor Apps' callback url and the request token is verified.\n//\n// When Meteor Apps run on multiple servers, it's possible that\n// 2 different servers may be used to generate the request token\n// and to verify it in the callback once the user has authorized.\n//\n// For this reason, the _pendingRequestTokens are stored in the database\n// so they can be shared across Meteor App servers.\n//\n// XXX This code is fairly similar to oauth/pending_credentials.js --\n// maybe we can combine them somehow.\n\n// Collection containing pending request tokens\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\nOAuth._pendingRequestTokens = new Mongo.Collection(\n  \"meteor_oauth_pendingRequestTokens\", {\n    _preventAutopublish: true\n  });\n\nOAuth._pendingRequestTokens._ensureIndex('key', {unique: 1});\nOAuth._pendingRequestTokens._ensureIndex('createdAt');\n\n\n\n// Periodically clear old entries that never got completed\nvar _cleanStaleResults = function() {\n  // Remove request tokens older than 5 minute\n  var timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n  OAuth._pendingRequestTokens.remove({ createdAt: { $lt: timeCutoff } });\n};\nvar _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and request token in the _pendingRequestTokens collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param requestToken {string}\n// @param requestTokenSecret {string}\n//\nOAuth._storeRequestToken = function (key, requestToken, requestTokenSecret) {\n  check(key, String);\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  OAuth._pendingRequestTokens.upsert({\n    key: key\n  }, {\n    key: key,\n    requestToken: OAuth.sealSecret(requestToken),\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a request token from the _pendingRequestTokens collection\n// Returns an object containing requestToken and requestTokenSecret properties\n//\n// @param key {string}\n//\nOAuth._retrieveRequestToken = function (key) {\n  check(key, String);\n\n  var pendingRequestToken = OAuth._pendingRequestTokens.findOne({ key: key });\n  if (pendingRequestToken) {\n    OAuth._pendingRequestTokens.remove({ _id: pendingRequestToken._id });\n    return {\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n      requestTokenSecret: OAuth.openSecret(\n        pendingRequestToken.requestTokenSecret)\n    };\n  } else {\n    return undefined;\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"oauth1\", {\n  OAuth1Binding: OAuth1Binding,\n  OAuth1Test: OAuth1Test\n});\n\n})();\n","servePath":"/packages/oauth1.js"}]