[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar Babel, BabelCompiler;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////\n//                                                                            //\n// packages/babel-compiler/babel.js                                           //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n                                                                              //\nvar meteorBabel = null;\nfunction getMeteorBabel() {\n  return meteorBabel || (meteorBabel = Npm.require(\"meteor-babel\"));\n}\n\n/**\n * Returns a new object containing default options appropriate for\n */\nfunction getDefaultOptions(extraFeatures) {\n  // See https://github.com/meteor/babel/blob/master/options.js for more\n  // information about what the default options are.\n  var options = getMeteorBabel().getDefaultOptions(extraFeatures);\n\n  // The sourceMap option should probably be removed from the default\n  // options returned by meteorBabel.getDefaultOptions.\n  delete options.sourceMap;\n\n  return options;\n}\n\nBabel = {\n  getDefaultOptions: getDefaultOptions,\n\n  // Deprecated, now a no-op.\n  validateExtraFeatures: Function.prototype,\n\n  parse: function (source) {\n    return getMeteorBabel().parse(source);\n  },\n\n  compile: function (source, options) {\n    options = options || getDefaultOptions();\n    return getMeteorBabel().compile(source, options);\n  },\n\n  setCacheDir: function (cacheDir) {\n    getMeteorBabel().setCacheDir(cacheDir);\n  },\n\n  minify: function (source, options) {\n    var options = options || getMeteorBabel().getMinifierOptions();\n    return getMeteorBabel().minify(source, options);\n  },\n\n  getMinifierOptions: function (extraFeatures) {\n    return getMeteorBabel().getMinifierOptions(extraFeatures);\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////\n//                                                                            //\n// packages/babel-compiler/babel-compiler.js                                  //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n                                                                              //\nvar semver = Npm.require(\"semver\");\n\n/**\n * A compiler that can be instantiated with features and used inside\n * Plugin.registerCompiler\n * @param {Object} extraFeatures The same object that getDefaultOptions takes\n */\nBabelCompiler = function BabelCompiler(extraFeatures) {\n  this.extraFeatures = extraFeatures;\n  this._babelrcCache = null;\n  this._babelrcWarnings = Object.create(null);\n};\n\nvar BCp = BabelCompiler.prototype;\nvar excludedFileExtensionPattern = /\\.(es5|min)\\.js$/i;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// There's no way to tell the current Meteor version, but we can infer\n// whether it's Meteor 1.4.4 or earlier by checking the Node version.\nvar isMeteorPre144 = semver.lt(process.version, \"4.8.1\");\n\nBCp.processFilesForTarget = function (inputFiles) {\n  // Reset this cache for each batch processed.\n  this._babelrcCache = null;\n\n  inputFiles.forEach(function (inputFile) {\n    var toBeAdded = this.processOneFileForTarget(inputFile);\n    if (toBeAdded) {\n      inputFile.addJavaScript(toBeAdded);\n    }\n  }, this);\n};\n\n// Returns an object suitable for passing to inputFile.addJavaScript, or\n// null to indicate there was an error, and nothing should be added.\nBCp.processOneFileForTarget = function (inputFile, source) {\n  this._babelrcCache = this._babelrcCache || Object.create(null);\n\n  if (typeof source !== \"string\") {\n    // Other compiler plugins can call processOneFileForTarget with a\n    // source string that's different from inputFile.getContentsAsString()\n    // if they've already done some processing.\n    source = inputFile.getContentsAsString();\n  }\n\n  var packageName = inputFile.getPackageName();\n  var inputFilePath = inputFile.getPathInPackage();\n  var outputFilePath = inputFilePath;\n  var fileOptions = inputFile.getFileOptions();\n  var toBeAdded = {\n    sourcePath: inputFilePath,\n    path: outputFilePath,\n    data: source,\n    hash: inputFile.getSourceHash(),\n    sourceMap: null,\n    bare: !! fileOptions.bare\n  };\n  var cacheDeps = {\n    sourceHash: toBeAdded.hash\n  };\n\n  // If you need to exclude a specific file within a package from Babel\n  // compilation, pass the { transpile: false } options to api.addFiles\n  // when you add that file.\n  if (fileOptions.transpile !== false &&\n      // Bare files should not be transpiled by Babel, because they do not\n      // have access to CommonJS APIs like `require`, `module`, `exports`.\n      ! toBeAdded.bare &&\n      // If you need to exclude a specific file within an app from Babel\n      // compilation, give it the following file extension: .es5.js\n      ! excludedFileExtensionPattern.test(inputFilePath)) {\n\n    var extraFeatures = Object.assign({}, this.extraFeatures);\n\n    if (inputFile.getArch().startsWith(\"os.\")) {\n      // Start with a much simpler set of Babel presets and plugins if\n      // we're compiling for Node 8.\n      extraFeatures.nodeMajorVersion = parseInt(process.versions.node);\n    }\n\n    if (! extraFeatures.hasOwnProperty(\"jscript\")) {\n      // Perform some additional transformations to improve compatibility\n      // in older browsers (e.g. wrapping named function expressions, per\n      // http://kiro.me/blog/nfe_dilemma.html).\n      extraFeatures.jscript = true;\n    }\n\n    var babelOptions = Babel.getDefaultOptions(extraFeatures);\n\n    this.inferExtraBabelOptions(inputFile, babelOptions, cacheDeps);\n\n    babelOptions.sourceMap = true;\n    babelOptions.filename =\n      babelOptions.sourceFileName = packageName\n      ? \"packages/\" + packageName + \"/\" + inputFilePath\n      : inputFilePath;\n\n    try {\n      var result = profile('Babel.compile', function () {\n        return Babel.compile(source, babelOptions, cacheDeps);\n      });\n    } catch (e) {\n      if (e.loc) {\n        inputFile.error({\n          message: e.message,\n          line: e.loc.line,\n          column: e.loc.column,\n        });\n\n        return null;\n      }\n\n      throw e;\n    }\n\n    if (isMeteorPre144) {\n      // Versions of meteor-tool earlier than 1.4.4 do not understand that\n      // module.importSync is synonymous with the deprecated module.import\n      // and thus fail to register dependencies for importSync calls.\n      // This string replacement may seem a bit hacky, but it will tide us\n      // over until everyone has updated to Meteor 1.4.4.\n      // https://github.com/meteor/meteor/issues/8572\n      result.code = result.code.replace(\n        /\\bmodule\\.importSync\\b/g,\n        \"module.import\"\n      );\n    }\n\n    toBeAdded.data = result.code;\n    toBeAdded.hash = result.hash;\n\n    // The babelOptions.sourceMapTarget option was deprecated in Babel\n    // 7.0.0-beta.41: https://github.com/babel/babel/pull/7500\n    result.map.file = babelOptions.filename + \".map\";\n\n    toBeAdded.sourceMap = result.map;\n  }\n\n  return toBeAdded;\n};\n\nBCp.setDiskCacheDirectory = function (cacheDir) {\n  Babel.setCacheDir(cacheDir);\n};\n\nfunction profile(name, func) {\n  if (typeof Profile !== 'undefined') {\n    return Profile.time(name, func);\n  } else {\n    return func();\n  }\n};\n\nBCp.inferExtraBabelOptions = function (inputFile, babelOptions, cacheDeps) {\n  if (! inputFile.require ||\n      ! inputFile.findControlFile ||\n      ! inputFile.readAndWatchFile) {\n    return false;\n  }\n\n  return (\n    // If a .babelrc exists, it takes precedence over package.json.\n    this._inferFromBabelRc(inputFile, babelOptions, cacheDeps) ||\n    this._inferFromPackageJson(inputFile, babelOptions, cacheDeps)\n  );\n};\n\nBCp._inferFromBabelRc = function (inputFile, babelOptions, cacheDeps) {\n  var babelrcPath = inputFile.findControlFile(\".babelrc\");\n  if (babelrcPath) {\n    if (! hasOwn.call(this._babelrcCache, babelrcPath)) {\n      try {\n        this._babelrcCache[babelrcPath] =\n          JSON.parse(inputFile.readAndWatchFile(babelrcPath));\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          e.message = \".babelrc is not a valid JSON file: \" + e.message;\n        }\n\n        throw e;\n      }\n    }\n\n    return this._inferHelper(\n      inputFile,\n      babelOptions,\n      babelrcPath,\n      this._babelrcCache[babelrcPath],\n      cacheDeps\n    );\n  }\n};\n\nBCp._inferFromPackageJson = function (inputFile, babelOptions, cacheDeps) {\n  var pkgJsonPath = inputFile.findControlFile(\"package.json\");\n  if (pkgJsonPath) {\n    if (! hasOwn.call(this._babelrcCache, pkgJsonPath)) {\n      this._babelrcCache[pkgJsonPath] = JSON.parse(\n        inputFile.readAndWatchFile(pkgJsonPath)\n      ).babel || null;\n    }\n\n    return this._inferHelper(\n      inputFile,\n      babelOptions,\n      pkgJsonPath,\n      this._babelrcCache[pkgJsonPath],\n      cacheDeps\n    );\n  }\n};\n\nBCp._inferHelper = function (\n  inputFile,\n  babelOptions,\n  controlFilePath,\n  babelrc,\n  cacheDeps\n) {\n  if (! babelrc) {\n    return false;\n  }\n\n  var compiler = this;\n\n  function walkBabelRC(obj, path) {\n    if (obj && typeof obj === \"object\") {\n      const copy = Object.create(null);\n\n      path = path || [];\n      const index = path.length;\n\n      if (obj.presets) {\n        path[index] = \"presets\";\n        copy.presets = walkHelper(obj.presets, path);\n      }\n\n      if (obj.plugins) {\n        path[index] = \"plugins\";\n        copy.plugins = walkHelper(obj.plugins, path);\n      }\n\n      path.pop();\n\n      return copy;\n    }\n\n    return obj;\n  }\n\n  function walkHelper(list, path) {\n    const copy = [];\n\n    list.forEach(function (pluginOrPreset) {\n      const res = resolveHelper(pluginOrPreset, path);\n      if (res) {\n        copy.push(res);\n      }\n    });\n\n    return copy;\n  }\n\n  function resolveHelper(value, path) {\n    if (value) {\n      if (typeof value === \"function\") {\n        // The value has already been resolved to a plugin function.\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        // The value is a [plugin, options] pair.\n        const res = resolveHelper(value[0], path);\n        if (res) {\n          const copy = value.slice(0);\n          copy[0] = res;\n          return copy;\n        }\n\n      } else if (typeof value === \"string\") {\n        // The value is a string that we need to require.\n        const result = requireWithPath(value, path);\n        if (result && result.module) {\n          cacheDeps[result.name] = result.version;\n          return walkBabelRC(result.module, path);\n        }\n\n      } else if (typeof value === \"object\") {\n        // The value is a { presets?, plugins? } preset object.\n        return walkBabelRC(value, path);\n      }\n    }\n\n    return null;\n  }\n\n  function requireWithPath(id, path) {\n    const prefixes = [];\n    const lastInPath = path[path.length - 1];\n    if (lastInPath === \"presets\") {\n      prefixes.push(\"@babel/preset-\", \"babel-preset-\");\n    } else if (lastInPath === \"plugins\") {\n      prefixes.push(\"@babel/plugin-\", \"babel-plugin-\");\n    }\n\n    // Try without a prefix if the prefixes fail.\n    prefixes.push(\"\");\n\n    try {\n      return requireWithPrefixes(inputFile, id, prefixes, controlFilePath);\n    } catch (e) {\n      if (e.code !== \"MODULE_NOT_FOUND\") {\n        throw e;\n      }\n\n      if (! hasOwn.call(compiler._babelrcWarnings, id)) {\n        compiler._babelrcWarnings[id] = controlFilePath;\n\n        console.error(\n          \"Warning: unable to resolve \" +\n            JSON.stringify(id) +\n            \" in \" + path.join(\".\") +\n            \" of \" + controlFilePath + \", due to:\"\n        );\n\n        console.error(e.stack || e);\n      }\n\n      return null;\n    }\n  }\n\n  const clean = walkBabelRC(babelrc);\n  merge(babelOptions, clean, \"presets\");\n  merge(babelOptions, clean, \"plugins\");\n\n  if (babelrc && babelrc.env) {\n    const envKey =\n      process.env.BABEL_ENV ||\n      process.env.NODE_ENV ||\n      \"development\";\n\n    const clean = walkBabelRC(babelrc.env[envKey]);\n\n    if (clean) {\n      merge(babelOptions, clean, \"presets\");\n      merge(babelOptions, clean, \"plugins\");\n    }\n  }\n\n  return !! (babelOptions.presets ||\n             babelOptions.plugins);\n};\n\nfunction merge(babelOptions, babelrc, name) {\n  if (babelrc[name]) {\n    var list = babelOptions[name] || [];\n    babelOptions[name] = list;\n    list.push.apply(list, babelrc[name]);\n  }\n}\n\nfunction requireWithPrefixes(inputFile, id, prefixes, controlFilePath) {\n  var isTopLevel = \"./\".indexOf(id.charAt(0)) < 0;\n  var presetOrPlugin;\n  var presetOrPluginMeta;\n\n  if (isTopLevel) {\n    var presetOrPluginId;\n\n    var found = prefixes.some(function (prefix) {\n      try {\n        // Call inputFile.resolve here rather than inputFile.require so\n        // that the import doesn't fail due to missing transitive\n        // dependencies imported by the preset or plugin.\n        if (inputFile.resolve(prefix + id)) {\n          presetOrPluginId = prefix + id;\n        }\n\n        presetOrPluginMeta = inputFile.require(\n          packageNameFromTopLevelModuleId(prefix + id) + \"/package.json\");\n\n        return true;\n\n      } catch (e) {\n        if (e.code !== \"MODULE_NOT_FOUND\") {\n          throw e;\n        }\n\n        return false;\n      }\n    });\n\n    if (found) {\n      if (presetOrPluginMeta.name === \"babel-preset-meteor\") {\n        // Since Meteor always includes babel-preset-meteor automatically,\n        // it's likely a mistake for that preset to appear in a custom\n        // .babelrc file. Previously we recommended that developers simply\n        // remove the preset (e.g. #9631), but we can easily just ignore\n        // it by returning null here, which seems like a better solution\n        // since it allows the same .babelrc file to be used for other\n        // purposes, such as running tests with a testing tool that needs\n        // to compile application code the same way Meteor does.\n        return null;\n      }\n      presetOrPlugin = inputFile.require(presetOrPluginId);\n    }\n\n  } else {\n    // If the identifier is not top-level, but relative or absolute,\n    // then it will be required as-is, so that you can implement your\n    // own Babel plugins locally, rather than always using plugins\n    // installed from npm.\n    presetOrPlugin = inputFile.require(id, controlFilePath);\n\n    // Note that inputFile.readAndWatchFileWithHash converts module\n    // identifers to OS-specific paths if necessary.\n    var absId = inputFile.resolve(id, controlFilePath);\n    var info = inputFile.readAndWatchFileWithHash(absId);\n\n    presetOrPluginMeta = {\n      name: absId,\n      version: info.hash\n    };\n  }\n\n  if (presetOrPlugin &&\n      presetOrPluginMeta) {\n    return {\n      name: presetOrPluginMeta.name,\n      version: presetOrPluginMeta.version,\n      module: presetOrPlugin.__esModule\n        ? presetOrPlugin.default\n        : presetOrPlugin\n    };\n  }\n\n  return null;\n}\n\n// react-hot-loader/babel => react-hot-loader\n// @babel/preset-env/lib/index.js => @babel/preset-env\nfunction packageNameFromTopLevelModuleId(id) {\n  const parts = id.split(\"/\", 2);\n  if (parts[0].charAt(0) === \"@\") {\n    return parts.join(\"/\");\n  }\n  return parts[0];\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"babel-compiler\", {\n  Babel: Babel,\n  BabelCompiler: BabelCompiler\n});\n\n})();\n","servePath":"/packages/babel-compiler.js"}]