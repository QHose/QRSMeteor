[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Iron = Package['iron:core'].Iron;\n\n/* Package-scope variables */\nvar compilePath, Url;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                          //\n// packages/iron_url/lib/compiler.js                                                                        //\n//                                                                                                          //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                            //\n/*\nBased on https://github.com/pillarjs/path-to-regexp\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar typeOf = function (o) { return Object.prototype.toString.call(o); };\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match already escaped characters that would otherwise incorrectly appear\n  // in future matches. This allows the user to escape special characters that\n  // shouldn't be transformed.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\" => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '([\\\\/.])?(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^)])*)\\\\))?|\\\\(((?:\\\\\\\\.|[^)])*)\\\\))([+*?])?',\n  // Match regexp special characters that should always be escaped.\n  '([.+*?=^!:${}()[\\\\]|\\\\/])'\n].join('|'), 'g');\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nvar attachKeys = function (re, keys) {\n  re.keys = keys;\n\n  return re;\n};\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array should be passed in, which will contain the placeholder key\n * names. For example `/user/:id` will then contain `[\"id\"]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 keys\n * @param  {Object}                options\n * @return {RegExp}\n */\nfunction pathtoRegexp (path, keys, options) {\n  if (keys && typeOf(keys) !== '[object Array]') {\n    options = keys;\n    keys = null;\n  }\n\n  keys = keys || [];\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var index = 0;\n\n  if (path instanceof RegExp) {\n    // Match all capturing groups of a regexp.\n    var groups = path.source.match(/\\((?!\\?)/g) || [];\n\n    // Map all the matches to their numeric keys and push into the keys.\n    keys.push.apply(keys, groups.map(function (match, index) {\n      return {\n        name:      index,\n        delimiter: null,\n        optional:  false,\n        repeat:    false\n      };\n    }));\n\n    // Return the source back to the user.\n    return attachKeys(path, keys);\n  }\n\n  if (typeOf(path) === '[object Array]') {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    // Generate a new regexp instance by joining all the parts together.\n    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);\n  }\n\n  // Alter the path string into a usable regexp.\n  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {\n    // Avoiding re-escaping escaped characters.\n    if (escaped) {\n      return escaped;\n    }\n\n    // Escape regexp special characters.\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    // Escape the prefix character.\n    prefix = prefix ? '\\\\' + prefix : '';\n\n    // Match using the custom capturing group, or fallback to capturing\n    // everything up to the next slash (or next period if the param was\n    // prefixed with a period).\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    // Allow parameters to be repeated more than once.\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    // Allow a parameter to be optional.\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  });\n\n  // Check whether the path ends in a slash as it alters some match behaviour.\n  var endsWithSlash = path[path.length - 1] === '/';\n\n  // In non-strict mode we allow an optional trailing slash in the match. If\n  // the path to match already ended with a slash, we need to remove it for\n  // consistency. The slash is only valid at the very end of a path match, not\n  // anywhere in the middle. This is important for non-ending mode, otherwise\n  // \"/test/\" will match \"/test//route\".\n  if (!strict) {\n    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\\\/(?=$))?';\n  }\n\n  // In non-ending mode, we need prompt the capturing groups to match as much\n  // as possible by using a positive lookahead for the end or next path segment.\n  if (!end) {\n    path += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);\n};\n\ncompilePath = pathtoRegexp;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                          //\n// packages/iron_url/lib/url.js                                                                             //\n//                                                                                                          //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                            //\n/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar warn = Iron.utils.warn;\n\n/*****************************************************************************/\n/* Url */\n/*****************************************************************************/\nfunction safeDecodeURIComponent (val) {\n  try {\n    return decodeURIComponent(val.replace(/\\+/g, ' '));\n  } catch (e) {\n    if (e.constructor == URIError) {\n      warn(\"Tried to decode an invalid URI component: \" + JSON.stringify(val) + \" \" + e.stack);\n    }\n\n    return undefined;\n  }\n}\n\nfunction safeDecodeURI (val) {\n  try {\n    return decodeURI(val.replace(/\\+/g, ' '));\n  } catch (e) {\n    if (e.constructor == URIError) {\n      warn(\"Tried to decode an invalid URI: \" + JSON.stringify(val) + \" \" + e.stack);\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Url utilities and the ability to compile a url into a regular expression.\n */\nUrl = function (url, options) {\n  options = options || {};\n  this.options = options;\n  this.keys = [];\n  this.regexp = compilePath(url, this.keys, options);\n  this._originalPath = url;\n  _.extend(this, Url.parse(url));\n};\n\n/**\n * Given a relative or absolute path return\n * a relative path with a leading forward slash and\n * no search string or hash fragment\n *\n * @param {String} path\n * @return {String}\n */\nUrl.normalize = function (url) {\n  if (url instanceof RegExp)\n    return url;\n  else if (typeof url !== 'string')\n    return '/';\n\n  var parts = Url.parse(url);\n  var pathname = parts.pathname;\n\n  if (pathname.charAt(0) !== '/')\n    pathname = '/' + pathname;\n\n  if (pathname.length > 1 && pathname.charAt(pathname.length - 1) === '/') {\n    pathname = pathname.slice(0, pathname.length - 1);\n  }\n\n  return pathname;\n};\n\n/**\n * Returns true if both a and b are of the same origin.\n */\nUrl.isSameOrigin = function (a, b) {\n  var aParts = Url.parse(a);\n  var bParts = Url.parse(b);\n  var result = aParts.origin === bParts.origin;\n  return result;\n};\n\n/**\n * Given a query string return an object of key value pairs.\n *\n * \"?p1=value1&p2=value2 => {p1: value1, p2: value2}\n */\nUrl.fromQueryString = function (query) {\n  if (!query)\n    return {};\n\n  if (typeof query !== 'string')\n    throw new Error(\"expected string\");\n\n  // get rid of the leading question mark\n  if (query.charAt(0) === '?')\n    query = query.slice(1);\n\n  var keyValuePairs = query.split('&');\n  var result = {};\n  var parts;\n\n  _.each(keyValuePairs, function (pair) {\n    var parts = pair.split('=');\n    var key = safeDecodeURIComponent(parts[0]);\n    var value = safeDecodeURIComponent(parts[1]);\n\n    if (typeof key !== 'undefined' &&\n        typeof value !== 'undefined' &&\n        key.slice(-2) === '[]') {\n      key = key.slice(0, -2);\n      result[key] = result[key] || [];\n      result[key].push(value);\n    } else {\n      result[key] = value;\n    }\n  });\n\n  return result;\n};\n\n/**\n * Given a query object return a query string.\n */\nUrl.toQueryString = function (queryObject) {\n  var result = [];\n\n  if (typeof queryObject === 'string') {\n    if (queryObject.charAt(0) !== '?')\n      return '?' + queryObject;\n    else\n      return queryObject;\n  }\n\n  _.each(queryObject, function (value, key) {\n    if (_.isArray(value)) {\n      _.each(value, function(valuePart) {\n        result.push(encodeURIComponent(key) + '[]=' + encodeURIComponent(valuePart));\n      });\n    } else {\n      result.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n    }\n  });\n\n  // no sense in adding a pointless question mark\n  if (result.length > 0)\n    return '?' + result.join('&');\n  else\n    return '';\n};\n\n/**\n * Given a string url return an object with all of the url parts.\n */\nUrl.parse = function (url) {\n  if (typeof url !== 'string')\n    return {};\n\n  //http://tools.ietf.org/html/rfc3986#page-50\n  //http://www.rfc-editor.org/errata_search.php?rfc=3986\n  var re = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n  var match = url.match(re);\n\n  var protocol = match[1] ? match[1].toLowerCase() : undefined;\n  var hostWithSlashes = match[3];\n  var slashes = !!hostWithSlashes;\n  var hostWithAuth= match[4] ? match[4].toLowerCase() : undefined;\n  var hostWithAuthParts = hostWithAuth ? hostWithAuth.split('@') : [];\n\n  var host, auth;\n\n  if (hostWithAuthParts.length == 2) {\n    auth = hostWithAuthParts[0];\n    host = hostWithAuthParts[1];\n  } else if (hostWithAuthParts.length == 1) {\n    host = hostWithAuthParts[0];\n    auth = undefined;\n  } else {\n    host = undefined;\n    auth = undefined;\n  }\n\n  var hostWithPortParts = (host && host.split(':')) || [];\n  var hostname = hostWithPortParts[0];\n  var port = hostWithPortParts[1];\n  var origin = (protocol && host) ? protocol + '//' + host : undefined;\n  var pathname = match[5];\n  var hash = match[8];\n  var originalUrl = url;\n\n  var search = match[6];\n\n  var query;\n  var indexOfSearch = (hash && hash.indexOf('?')) || -1;\n\n  // if we found a search string in the hash and there is no explicit search\n  // string\n  if (~indexOfSearch && !search) {\n    search = hash.slice(indexOfSearch);\n    hash = hash.substr(0, indexOfSearch);\n    // get rid of the ? character\n    query = search.slice(1);\n  } else {\n    query = match[7];\n  }\n\n  var path = pathname + (search || '');\n  var queryObject = Url.fromQueryString(query);\n\n  var rootUrl = [\n    protocol || '',\n    slashes ? '//' : '',\n    hostWithAuth || ''\n  ].join('');\n\n  var href = [\n    protocol || '',\n    slashes ? '//' : '',\n    hostWithAuth || '',\n    pathname || '',\n    search || '',\n    hash || ''\n  ].join('');\n\n  return {\n    rootUrl: rootUrl || '',\n    originalUrl: url || '',\n    href: href || '',\n    protocol: protocol || '',\n    auth: auth || '',\n    host: host || '',\n    hostname: hostname || '',\n    port: port || '',\n    origin: origin || '',\n    path: path || '',\n    pathname: pathname || '',\n    search: search || '',\n    query: query || '',\n    queryObject: queryObject || '',\n    hash: hash || '',\n    slashes: slashes\n  };\n};\n\n/**\n * Returns true if the path matches and false otherwise.\n */\nUrl.prototype.test = function (path) {\n  return this.regexp.test(Url.normalize(path));\n};\n\n/**\n * Returns the result of calling exec on the compiled path with\n * the given path.\n */\nUrl.prototype.exec = function (path) {\n  return this.regexp.exec(Url.normalize(path));\n};\n\n/**\n * Returns an array of parameters given a path. The array may have named\n * properties in addition to indexed values.\n */\nUrl.prototype.params = function (path) {\n  if (!path)\n    return [];\n\n  var params = [];\n  var m = this.exec(path);\n  var queryString;\n  var keys = this.keys;\n  var key;\n  var value;\n\n  if (!m)\n    throw new Error('The route named \"' + this.name + '\" does not match the path \"' + path + '\"');\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    key = keys[i - 1];\n    value = typeof m[i] == 'string' ? safeDecodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = params[key.name] !== undefined ?\n        params[key.name] : value;\n    } else\n      params.push(value);\n  }\n\n  if (typeof safeDecodeURI(path) !== 'undefined') {\n    queryString = path.split('?')[1];\n    if (queryString)\n      queryString = queryString.split('#')[0];\n\n    params.hash = path.split('#')[1] || null;\n    params.query = Url.fromQueryString(queryString);\n  }\n\n  return params;\n};\n\nUrl.prototype.resolve = function (params, options) {\n  var value;\n  var isValueDefined;\n  var result;\n  var wildCardCount = 0;\n  var path = this._originalPath;\n  var hash;\n  var query;\n  var missingParams = [];\n  var originalParams = params;\n\n  options = options || {};\n  params = params || [];\n  query = options.query;\n  hash = options.hash && options.hash.toString();\n\n  if (path instanceof RegExp) {\n    throw new Error('Cannot currently resolve a regular expression path');\n  } else {\n    path = path\n      .replace(\n        /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n        function (match, slash, format, key, capture, optional, offset) {\n          slash = slash || '';\n          format = format || '';\n          value = params[key];\n          isValueDefined = typeof value !== 'undefined';\n\n          if (optional && !isValueDefined) {\n            value = '';\n          } else if (!isValueDefined) {\n            missingParams.push(key);\n            return;\n          }\n\n          value = _.isFunction(value) ? value.call(params) : value;\n          var escapedValue = _.map(String(value).split('/'), function (segment) {\n            return encodeURIComponent(segment);\n          }).join('/');\n          return slash + format + escapedValue;\n        }\n      )\n      .replace(\n        /\\*/g,\n        function (match) {\n          if (typeof params[wildCardCount] === 'undefined') {\n            throw new Error(\n              'You are trying to access a wild card parameter at index ' +\n              wildCardCount +\n              ' but the value of params at that index is undefined');\n          }\n\n          var paramValue = String(params[wildCardCount++]);\n          return _.map(paramValue.split('/'), function (segment) {\n            return encodeURIComponent(segment);\n          }).join('/');\n        }\n      );\n\n    query = Url.toQueryString(query);\n\n    path = path + query;\n\n    if (hash) {\n      hash = encodeURI(hash.replace('#', ''));\n      path = path + '#' + hash;\n    }\n  }\n\n  // Because of optional possibly empty segments we normalize path here\n  path = path.replace(/\\/+/g, '/'); // Multiple / -> one /\n  path = path.replace(/^(.+)\\/$/g, '$1'); // Removal of trailing /\n\n  if (missingParams.length == 0)\n    return path;\n  else if (options.throwOnMissingParams === true)\n    throw new Error(\"Missing required parameters on path \" + JSON.stringify(this._originalPath) + \". The missing params are: \" + JSON.stringify(missingParams) + \". The params object passed in was: \" + JSON.stringify(originalParams) + \".\");\n  else\n    return null;\n};\n\n/*****************************************************************************/\n/* Namespacing */\n/*****************************************************************************/\nIron.Url = Url;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"iron:url\");\n\n})();\n","servePath":"/packages/iron_url.js"}]