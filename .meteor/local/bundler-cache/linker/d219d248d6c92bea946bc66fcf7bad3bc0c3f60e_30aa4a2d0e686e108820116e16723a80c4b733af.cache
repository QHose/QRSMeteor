[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar makeInstaller, makeInstallerOptions, meteorInstall;\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js     //\n// This file is in bare mode and is not in its own closure.                  //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmakeInstaller = function (options) {\n  \"use strict\";\n\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var defaultExtensions = options.extensions || [\".js\", \".json\"];\n\n  // If defined, the options.onInstall function will be called any time\n  // new modules are installed.\n  var onInstall = options.onInstall;\n\n  // If defined, each module-specific require function will be passed to\n  // this function, along with the module object of the parent module, and\n  // the result will be used in place of the original require function.\n  var wrapRequire = options.wrapRequire;\n\n  // If defined, the options.override function will be called before\n  // looking up any top-level package identifiers in node_modules\n  // directories. It can either return a string to provide an alternate\n  // package identifier, or a non-string value to prevent the lookup from\n  // proceeding.\n  var override = options.override;\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // List of fields to look for in package.json files to determine the\n  // main entry module of the package. The first field listed here whose\n  // value is a string will be used to resolve the entry module.\n  var mainFields = options.mainFields ||\n    // If options.mainFields is absent and options.browser is truthy,\n    // package resolution will prefer the \"browser\" field of package.json\n    // files to the \"main\" field. Note that this only supports\n    // string-valued \"browser\" fields for now, though in the future it\n    // might make sense to support the object version, a la browserify.\n    (options.browser ? [\"browser\", \"main\"] : [\"main\"]);\n\n  var hasOwn = {}.hasOwnProperty;\n  function strictHasOwn(obj, key) {\n    return isObject(obj) && isString(key) && hasOwn.call(obj, key);\n  }\n\n  // Cache for looking up File objects given absolute module identifiers.\n  // Invariants:\n  //   filesByModuleId[module.id] === fileAppendId(root, module.id)\n  //   filesByModuleId[module.id].module === module\n  var filesByModuleId = {};\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File(\"/\", new File(\"/..\"));\n  var rootRequire = makeRequire(root);\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree, options) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree, options);\n      if (isFunction(onInstall)) {\n        onInstall(rootRequire);\n      }\n    }\n    return rootRequire;\n  }\n\n  // Replace this function to enable Module.prototype.prefetch.\n  install.fetch = function (ids) {\n    throw new Error(\"fetch not implemented\");\n  };\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports), and is exposed as install.Module in case the\n  // caller of makeInstaller wishes to modify Module.prototype.\n  function Module(id) {\n    this.id = id;\n\n    // The Node implementation of module.children unfortunately includes\n    // only those child modules that were imported for the first time by\n    // this parent module (i.e., child.parent === this).\n    this.children = [];\n\n    // This object is an install.js extension that includes all child\n    // modules imported by this module, even if this module is not the\n    // first to import them.\n    this.childrenById = {};\n  }\n\n  Module.prototype.resolve = function (id) {\n    return this.require.resolve(id);\n  };\n\n  // Used to keep module.prefetch promise resolutions well-ordered.\n  var lastPrefetchPromise;\n\n  // May be shared by multiple sequential calls to module.prefetch.\n  // Initialized to {} only when necessary.\n  var missing;\n\n  Module.prototype.prefetch = function (id) {\n    var module = this;\n    var parentFile = getOwn(filesByModuleId, module.id);\n\n    lastPrefetchPromise = lastPrefetchPromise || Promise.resolve();\n    var previousPromise = lastPrefetchPromise;\n\n    function walk(module) {\n      var file = getOwn(filesByModuleId, module.id);\n      if (fileIsDynamic(file) && ! file.pending) {\n        file.pending = true;\n        missing = missing || {};\n\n        // These are the data that will be exposed to the install.fetch\n        // callback, so it's worth documenting each item with a comment.\n        missing[module.id] = {\n          // The CommonJS module object that will be exposed to this\n          // dynamic module when it is evaluated. Note that install.fetch\n          // could decide to populate module.exports directly, instead of\n          // fetching anything. In that case, install.fetch should omit\n          // this module from the tree that it produces.\n          module: file.module,\n          // List of module identifier strings imported by this module.\n          // Note that the missing object already contains all available\n          // dependencies (including transitive dependencies), so\n          // install.fetch should not need to traverse these dependencies\n          // in most cases; however, they may be useful for other reasons.\n          // Though the strings are unique, note that two different\n          // strings could resolve to the same module.\n          deps: Object.keys(file.deps),\n          // The options (if any) that were passed as the second argument\n          // to the install(tree, options) function when this stub was\n          // first registered. Typically contains options.extensions, but\n          // could contain any information appropriate for the entire tree\n          // as originally installed. These options will be automatically\n          // inherited by the newly fetched modules, so install.fetch\n          // should not need to modify them.\n          options: file.options,\n          // Any stub data included in the array notation from the\n          // original entry for this dynamic module. Typically contains\n          // \"main\" and/or \"browser\" fields for package.json files, and is\n          // otherwise undefined.\n          stub: file.stub\n        };\n\n        each(file.deps, function (parentId, id) {\n          fileResolve(file, id);\n        });\n\n        each(module.childrenById, walk);\n      }\n    }\n\n    return lastPrefetchPromise = new Promise(function (resolve) {\n      var absChildId = module.resolve(id);\n      each(module.childrenById, walk);\n      resolve(absChildId);\n\n    }).then(function (absChildId) {\n      // Grab the current missing object and fetch its contents.\n      var toBeFetched = missing;\n      missing = null;\n\n      return Promise.resolve(\n        // The install.fetch function takes an object mapping missing\n        // dynamic module identifiers to options objects, and should\n        // return a Promise that resolves to a module tree that can be\n        // installed. As an optimization, if there were no missing dynamic\n        // modules, then we can skip calling install.fetch entirely.\n        toBeFetched && install.fetch(toBeFetched)\n\n      ).then(function (tree) {\n        function both() {\n          install(tree);\n          return absChildId;\n        }\n\n        // Although we want multiple install.fetch calls to run in\n        // parallel, it is important that the promises returned by\n        // module.prefetch are resolved in the same order as the original\n        // calls to module.prefetch, because previous fetches may include\n        // modules assumed to exist by more recent module.prefetch calls.\n        // Whether previousPromise was resolved or rejected, carry on with\n        // the installation regardless.\n        return previousPromise.then(both, both);\n      });\n    });\n  };\n\n  install.Module = Module;\n\n  function getOwn(obj, key) {\n    return strictHasOwn(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeMissingError(id) {\n    return new Error(\"Cannot find module '\" + id + \"'\");\n  }\n\n  function makeRequire(file) {\n    function require(id) {\n      var result = fileResolve(file, id);\n      if (result) {\n        return fileEvaluate(result, file.module);\n      }\n\n      var error = makeMissingError(id);\n\n      if (isFunction(fallback)) {\n        return fallback(\n          id, // The missing module identifier.\n          file.module.id, // The path of the requiring file.\n          error // The error we would have thrown.\n        );\n      }\n\n      throw error;\n    }\n\n    if (isFunction(wrapRequire)) {\n      require = wrapRequire(require, file.module);\n    }\n\n    require.extensions = fileGetExtensions(file).slice(0);\n\n    require.resolve = function (id) {\n      var f = fileResolve(file, id);\n      if (f) return f.module.id;\n      var error = makeMissingError(id);\n      if (fallback && isFunction(fallback.resolve)) {\n        return fallback.resolve(id, file.module.id, error);\n      }\n      throw error;\n    };\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.contents`\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.contents` property is a function that can be invoked with the\n  // appropriate `(require, exports, module)` arguments to evaluate the\n  // module. If the `.contents` property is a string, that string will be\n  // resolved as a module identifier, and the exports of the resulting\n  // module will provide the exports of the original file. The `.parent`\n  // property of a File is either a directory `File` or `null`. Note that\n  // a child may claim another `File` as its parent even if the parent\n  // does not have an entry for that child in its `.contents` object.\n  // This is important for implementing anonymous files, and preventing\n  // child modules from using `../relative/identifier` syntax to examine\n  // unrelated modules.\n  function File(moduleId, parent) {\n    var file = this;\n\n    // Link to the parent file.\n    file.parent = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.module = new Module(moduleId);\n    filesByModuleId[moduleId] = file;\n\n    // The .contents of the file can be either (1) an object, if the file\n    // represents a directory containing other files; (2) a factory\n    // function, if the file represents a module that can be imported; (3)\n    // a string, if the file is an alias for another file; or (4) null, if\n    // the file's contents are not (yet) available.\n    file.contents = null;\n\n    // Set of module identifiers imported by this module. Note that this\n    // set is not necessarily complete, so don't rely on it unless you\n    // know what you're doing.\n    file.deps = {};\n  }\n\n  function fileEvaluate(file, parentModule) {\n    var module = file.module;\n    if (! strictHasOwn(module, \"exports\")) {\n      var contents = file.contents;\n      if (! contents) {\n        // If this file was installed with array notation, and the array\n        // contained one or more objects but no functions, then the combined\n        // properties of the objects are treated as a temporary stub for\n        // file.module.exports. This is particularly important for partial\n        // package.json modules, so that the resolution logic can know the\n        // value of the \"main\" and/or \"browser\" fields, at least, even if\n        // the rest of the package.json file is not (yet) available.\n        if (file.stub) {\n          return file.stub;\n        }\n\n        throw makeMissingError(module.id);\n      }\n\n      if (parentModule) {\n        module.parent = parentModule;\n        var children = parentModule.children;\n        if (Array.isArray(children)) {\n          children.push(module);\n        }\n      }\n\n      // If a Module.prototype.useNode method is defined, give it a chance\n      // to define module.exports based on module.id using Node.\n      if (! isFunction(module.useNode) ||\n          ! module.useNode()) {\n        contents(\n          module.require = module.require || makeRequire(file),\n          // If the file had a .stub, reuse the same object for exports.\n          module.exports = file.stub || {},\n          module,\n          file.module.id,\n          file.parent.module.id\n        );\n      }\n\n      module.loaded = true;\n    }\n\n    // The module.runModuleSetters method will be deprecated in favor of\n    // just module.runSetters: https://github.com/benjamn/reify/pull/160\n    var runSetters = module.runSetters || module.runModuleSetters;\n    if (isFunction(runSetters)) {\n      runSetters.call(module);\n    }\n\n    return module.exports;\n  }\n\n  function fileIsDirectory(file) {\n    return file && isObject(file.contents);\n  }\n\n  function fileIsDynamic(file) {\n    return file && file.contents === null;\n  }\n\n  function fileMergeContents(file, contents, options) {\n    if (Array.isArray(contents)) {\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          file.deps[item] = file.module.id;\n        } else if (isFunction(item)) {\n          contents = item;\n        } else if (isObject(item)) {\n          file.stub = file.stub || {};\n          each(item, function (value, key) {\n            file.stub[key] = value;\n          });\n        }\n      });\n\n      if (! isFunction(contents)) {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (! isFunction(contents) &&\n               ! isString(contents) &&\n               ! isObject(contents)) {\n      // If contents is neither an array nor a function nor a string nor\n      // an object, just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      file.contents = file.contents || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {\n        each(contents, function (value, key) {\n          if (key === \"..\") {\n            child = file.parent;\n\n          } else {\n            var child = getOwn(file.contents, key);\n\n            if (! child) {\n              child = file.contents[key] = new File(\n                file.module.id.replace(/\\/*$/, \"/\") + key,\n                file\n              );\n\n              child.options = options;\n            }\n          }\n\n          fileMergeContents(child, value, options);\n        });\n      }\n    }\n  }\n\n  function each(obj, callback, context) {\n    Object.keys(obj).forEach(function (key) {\n      callback.call(this, obj[key], key);\n    }, context);\n  }\n\n  function fileGetExtensions(file) {\n    return file.options\n      && file.options.extensions\n      || defaultExtensions;\n  }\n\n  function fileAppendIdPart(file, part, extensions) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.parent;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.parent;\n    }\n\n    var exactChild = getOwn(file.contents, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.contents, part + extensions[e]);\n        if (child && ! fileIsDirectory(child)) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id, extensions) {\n    var parts = id.split(\"/\");\n\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = i < parts.length - 1\n        ? fileAppendIdPart(file, part)\n        : fileAppendIdPart(file, part, extensions);\n    });\n\n    return file;\n  }\n\n  function recordChild(parentModule, childFile) {\n    var childModule = childFile && childFile.module;\n    if (parentModule && childModule) {\n      parentModule.childrenById[childModule.id] = childModule;\n    }\n  }\n\n  function fileResolve(file, id, parentModule, seenDirFiles) {\n    var parentModule = parentModule || file.module;\n    var extensions = fileGetExtensions(file);\n\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (fileIsDirectory(file)) {\n      seenDirFiles = seenDirFiles || [];\n\n      // If the \"main\" field of a `package.json` file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same `package.json` file again. Using an array as a set\n      // is acceptable here because the number of directories to consider\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to\n      // store File objects instead of strings.\n      if (seenDirFiles.indexOf(file) < 0) {\n        seenDirFiles.push(file);\n\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\"), main;\n        var pkg = pkgJsonFile && fileEvaluate(pkgJsonFile, parentModule);\n        if (pkg &&\n            mainFields.some(function (name) {\n              return isString(main = pkg[name]);\n            })) {\n          // The \"main\" field of package.json does not have to begin with\n          // ./ to be considered relative, so first we try simply\n          // appending it to the directory path before falling back to a\n          // full fileResolve, which might return a package from a\n          // node_modules directory.\n          var mainFile = fileAppendId(file, main, extensions) ||\n            fileResolve(file, main, parentModule, seenDirFiles);\n\n          if (mainFile) {\n            file = mainFile;\n            recordChild(parentModule, pkgJsonFile);\n            // The fileAppendId call above may have returned a directory,\n            // so continue the loop to make sure we resolve it to a\n            // non-directory file.\n            continue;\n          }\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance `fileIsDirectory(file)` will be true\n      // for the result of `fileAppendIdPart(file, \"index.js\")`. However,\n      // in principle it is remotely possible that a file called\n      // `index.js` could be a directory instead of a file.\n      file = fileAppendIdPart(file, \"index.js\");\n    }\n\n    if (file && isString(file.contents)) {\n      file = fileResolve(file, file.contents, parentModule, seenDirFiles);\n    }\n\n    recordChild(parentModule, file);\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id, extensions) {\n    if (isFunction(override)) {\n      id = override(id, file.module.id);\n    }\n\n    if (isString(id)) {\n      for (var resolved; file && ! resolved; file = file.parent) {\n        resolved = fileIsDirectory(file) &&\n          fileAppendId(file, \"node_modules/\" + id, extensions);\n      }\n\n      return resolved;\n    }\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/options.js                                       //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmakeInstallerOptions = {};\n\nif (typeof Profile === \"function\" &&\n    process.env.METEOR_PROFILE) {\n  makeInstallerOptions.wrapRequire = function (require) {\n    return Profile(function (id) {\n      return \"require(\" + JSON.stringify(id) + \")\";\n    }, require);\n  };\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/server.js                                        //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\n// RegExp matching strings that don't start with a `.` or a `/`.\nvar topLevelIdPattern = /^[^./]/;\n\n// This function will be called whenever a module identifier that hasn't\n// been installed is required. For backwards compatibility, and so that we\n// can require binary dependencies on the server, we implement the\n// fallback in terms of Npm.require.\nmakeInstallerOptions.fallback = function (id, parentId, error) {\n  // For simplicity, we honor only top-level module identifiers here.\n  // We could try to honor relative and absolute module identifiers by\n  // somehow combining `id` with `dir`, but we'd have to be really careful\n  // that the resulting modules were located in a known directory (not\n  // some arbitrary location on the file system), and we only really need\n  // the fallback for dependencies installed in node_modules directories.\n  if (topLevelIdPattern.test(id)) {\n    if (typeof Npm === \"object\" &&\n        typeof Npm.require === \"function\") {\n      return Npm.require(id, error);\n    }\n  }\n\n  throw error;\n};\n\nmakeInstallerOptions.fallback.resolve = function (id, parentId, error) {\n  if (topLevelIdPattern.test(id)) {\n    // Allow any top-level identifier to resolve to itself on the server,\n    // so that makeInstallerOptions.fallback has a chance to handle it.\n    return id;\n  }\n\n  throw error;\n};\n\nmeteorInstall = makeInstaller(makeInstallerOptions);\nvar Module = meteorInstall.Module;\n\nModule.prototype.useNode = function () {\n  if (typeof npmRequire !== \"function\") {\n    // Can't use Node if npmRequire is not defined.\n    return false;\n  }\n\n  var parts = this.id.split(\"/\");\n  var start = 0;\n  if (parts[start] === \"\") ++start;\n  if (parts[start] === \"node_modules\" &&\n      parts[start + 1] === \"meteor\") {\n    start += 2;\n  }\n\n  if (parts.indexOf(\"node_modules\", start) < 0) {\n    // Don't try to use Node for modules that aren't in node_modules\n    // directories.\n    return false;\n  }\n\n  try {\n    npmRequire.resolve(this.id);\n  } catch (e) {\n    return false;\n  }\n\n  this.exports = npmRequire(this.id);\n\n  return true;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"modules-runtime\", {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules-runtime.js"}]