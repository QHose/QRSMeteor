[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar $ = Package.jquery.$;\nvar jQuery = Package.jquery.jQuery;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar ReactiveDict = Package['reactive-dict'].ReactiveDict;\nvar Session = Package.session.Session;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar PersistentSession;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/u2622_persistent-session/lib/persistent_session.js                                                  //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n// This file uses code direct from Meteor's reactive-dict package, mostly from\n// this file: https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js\n//\n// helpers: https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L1-L16\nvar stringify = function (value) {\n  if (value === undefined)\n    return 'undefined';\n  return EJSON.stringify(value);\n};\nvar parse = function (serialized) {\n  if (serialized === undefined || serialized === 'undefined')\n    return undefined;\n  return EJSON.parse(serialized);\n};\n\nvar changed = function (v) {\n  v && v.changed();\n};\n\n\nPersistentSession = function (dictName) {\n  if (_.isString(dictName)) {\n    this._dictName = dictName;\n\n    // when \"session\", use the existing dict\n    if (dictName == \"session\") {\n      this._dictName = \"\"   // we don't need a name for session\n      this._dict = oldSession; // we also want to use the global (incase something was set previously)\n\n    // not session? create a new dict\n    } else {\n      this._dict = new ReactiveDict(dictName);\n    }\n\n  } else {\n    throw new Error(\"dictName must be a string\");\n  }\n\n\n  /*\n   * Used to determine if we need to migrate how the data is stored.\n   * Each time the data format changes, change this number.\n   *\n   * It should match the current major + minor version:\n   * EG: 0.3 = 3, 1.2 = 12, 2.0 = 20, or for 0.3.x: 3, or 1.x: 10\n   *\n   */\n  var PSA_DATA_VERSION = 4;\n\n  // === INITIALIZE KEY TRACKING ===\n  this.psKeys     = {};\n  this.psKeyList  = [];\n  this.psaKeys    = {};\n  this.psaKeyList = [];\n\n  // initialize default method setting\n  this.default_method = 'temporary'; // valid options: 'temporary', 'persistent', 'authenticated'\n  if (Meteor.settings &&\n      Meteor.settings.public &&\n      Meteor.settings.public.persistent_session) {\n    this.default_method = Meteor.settings.public.persistent_session.default_method;\n  }\n\n\n  var self = this;\n\n  // === HOUSEKEEPING ===\n  /*\n   * Converts previously stored values into EJSON compatible formats.\n   */\n  function migrateToEJSON() {\n    if (amplify.store('__PSDATAVERSION__' + self._dictName) >= 1) {\n      return;\n    }\n\n    var psKeyList = amplify.store('__PSKEYS__' + self._dictName);\n    var psaKeyList = amplify.store('__PSAKEYS__' + self._dictName);\n\n    _.each([psKeyList, psaKeyList], function(list) {\n      _.each(list, function(key) {\n        amplify.store(key, EJSON.stringify(amplify.store(key)));\n      });\n    });\n\n    amplify.store('__PSDATAVERSION__' + self._dictName, 2);\n  };\n\n  function migrate3Xto4X() {\n    if (amplify.store('__PSDATAVERSION__' + self._dictName) >= PSA_DATA_VERSION) {\n      return;\n    }\n\n    var psKeyList = amplify.store('__PSKEYS__' + self._dictName);\n    var psaKeyList = amplify.store('__PSAKEYS__' + self._dictName);\n\n    _.each([psKeyList, psaKeyList], function(list) {\n      _.each(list, function(key) {\n        var invalid = false;\n        try {\n          EJSON.parse(amplify.store(self._dictName+key));\n        } catch (error) {\n          //The data is already in the format that we expect\n          //Unfortunately there is no EJSON.canParse method\n          invalid = true;\n        }\n        if (!invalid) {\n          var parsed = EJSON.parse(amplify.store(self._dictName+key));\n          var jsoned = EJSON.toJSONValue(parsed);\n          amplify.store(self._dictName+key, jsoned);\n        }\n      });\n    });\n\n    amplify.store('__PSDATAVERSION__' + self._dictName, 4);\n  }\n\n  if (Meteor.isClient) {\n\n    // --- on startup, load persistent data back into meteor session ---\n    Meteor.startup(function(){\n      var val;\n\n      migrateToEJSON();\n      migrate3Xto4X();\n\n      // persistent data\n      var psList = amplify.store('__PSKEYS__' + self._dictName);\n      if ( typeof psList == \"object\" && psList.length!==undefined ) {\n        for (var i=0; i<psList.length; i++) {\n          if (!_.has(self._dict.keys, psList[i])) {\n            val = self.get(psList[i]);\n            self.set(psList[i], val, true, false);\n          }\n        }\n      }\n\n      // authenticated data\n      var psaList = amplify.store('__PSAKEYS__' + self._dictName);\n      if ( typeof psaList == \"object\" && psaList.length!==undefined ) {\n        for (var i=0; i<psaList.length; i++) {\n          if (!_.has(self._dict.keys, psaList[i])) {\n            val = self.get(psaList[i]);\n            self.setAuth(psaList[i], val, true, true);\n          }\n        }\n      }\n\n    });\n\n  };\n\n  Tracker.autorun(function () {\n    // lazy check for accounts-base\n    if (Meteor.userId) {\n      var userId = Meteor.userId()\n      if (userId) {\n        // user is logged in, leave session in tacted\n      } else {\n        // user is unset, clear authencated keys\n        self.clearAuth()\n      }\n    }\n  });\n\n  return this;\n};\n\n// === LOCAL STORAGE INTERACTION ===\nPersistentSession.prototype.store = function _psStore(type, key, value) {\n  // use dict name for uniqueness\n  this.psKeyList  = amplify.store('__PSKEYS__' + this._dictName) || [];\n  this.psaKeyList = amplify.store('__PSAKEYS__' + this._dictName)|| [];\n\n  if (type == 'get') {\n    return amplify.store(this._dictName + key);\n  } else {\n\n    this.psKeyList  = _.without(this.psKeyList, key);\n    this.psaKeyList = _.without(this.psaKeyList, key);\n    delete this.psKeys[key];\n    delete this.psaKeys[key];\n\n    if (value===undefined || value===null || type=='temporary') {\n      value = null;\n\n    } else if (type=='persistent') {\n      this.psKeys[key] = EJSON.toJSONValue(value);\n      this.psKeyList = _.union(this.psKeyList, [key]);\n\n    } else if (type=='authenticated') {\n      this.psaKeys[key] = EJSON.toJSONValue(value);\n      this.psaKeyList = _.union(this.psaKeyList, [key]);\n    }\n\n    amplify.store('__PSKEYS__', this.psKeyList);\n    amplify.store('__PSAKEYS__', this.psaKeyList);\n    amplify.store(this._dictName + key, EJSON.toJSONValue(value));\n  }\n};\n\n\n// === GET ===\n// keep for backwards compability, redirect to this._dict\nPersistentSession.prototype.old_get = function (/* arguments */){\n  return this._dict.get.apply(this._dict, arguments);\n};\nPersistentSession.prototype.get = function _psGet(key) {\n  var val = this.old_get(key);\n  var psVal;\n  var unparsedPsVal = this.store('get', key);\n  if (unparsedPsVal !== undefined) {\n    psVal = EJSON.fromJSONValue(this.store('get', key));\n  }\n\n  /*\n   * We can't do `return psVal || val;` here, as when psVal = undefined and\n   * val = 0, it will return undefined, even though 0 is the correct value.\n   */\n  if (psVal === undefined || psVal === null) {\n    return val;\n  }\n  return psVal;\n};\n\n\n// === SET ===\nPersistentSession.prototype.old_set = function (/* arguments */){\n  // defaults to a persistent, non-authenticated variable\n  return this._dict.set.apply(this._dict, arguments);\n};\nPersistentSession.prototype.set = function _psSet(keyOrObject, value, persist, auth) {\n\n  // Taken from https://github.com/meteor/meteor/blob/107d858/packages/reactive-dict/reactive-dict.js\n  if ((typeof keyOrObject === 'object') && (value === undefined)) {\n    this._setObject(keyOrObject, persist, auth);\n    return;\n  }\n\n  var key = keyOrObject;\n  var type = 'temporary';\n  if (persist || (persist===undefined && (this.default_method=='persistent' || this.default_method=='authenticated'))) {\n    if (auth || (persist===undefined && auth===undefined && this.default_method=='authenticated')) {\n      type = 'authenticated';\n    } else {\n      type = 'persistent';\n    }\n  }\n  this.store(type, key, value);\n  this.old_set(key, value);\n};\n\n\n// Taken from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L144-L151\n// Backwords compat:\nPersistentSession.prototype.all = function _psAll() {\n  if (this._dict.allDeps) {\n    this._dict.allDeps.depend();\n  }\n  var ret = {};\n  _.each(this._dict.keys, function(value, key) {\n    ret[key] = parse(value);\n  });\n  return ret;\n}\n\nPersistentSession.prototype._setObject = function _psSetObject(object, persist, auth) {\n  var self = this;\n\n  _.each(object, function (value, key){\n    self.set(key, value, persist, auth);\n  });\n};\n\nPersistentSession.prototype._ensureKey = function _psEnsureKey(key) {\n  var self = this._dict;\n  if (!(key in self.keyDeps)) {\n    self.keyDeps[key] = new Tracker.Dependency;\n    self.keyValueDeps[key] = {};\n  }\n}\n\n// === EQUALS ===\n// Taken from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L93-L137\nPersistentSession.prototype.equals = function _psEquals(key, value) {\n\n  // Mongo.ObjectID is in the 'mongo' package\n  var ObjectID = null;\n  if (Package.mongo) {\n    ObjectID = Package.mongo.Mongo.ObjectID;\n  }\n\n  // We don't allow objects (or arrays that might include objects) for\n  // .equals, because JSON.stringify doesn't canonicalize object key\n  // order. (We can make equals have the right return value by parsing the\n  // current value and using EJSON.equals, but we won't have a canonical\n  // element of keyValueDeps[key] to store the dependency.) You can still use\n  // \"EJSON.equals(reactiveDict.get(key), value)\".\n  //\n  // XXX we could allow arrays as long as we recursively check that there\n  // are no objects\n  if (typeof value !== 'string' &&\n      typeof value !== 'number' &&\n      typeof value !== 'boolean' &&\n      typeof value !== 'undefined' &&\n      !(value instanceof Date) &&\n      !(ObjectID && value instanceof ObjectID) &&\n      value !== null) {\n    throw new Error(\"ReactiveDict.equals: value must be scalar\");\n  }\n  var serializedValue = stringify(value);\n\n  if (Tracker.active) {\n    this._ensureKey(key);\n\n    if (! _.has(this._dict.keyValueDeps[key], serializedValue))\n      this._dict.keyValueDeps[key][serializedValue] = new Tracker.Dependency;\n\n    var isNew = this._dict.keyValueDeps[key][serializedValue].depend();\n    if (isNew) {\n      var that = this;\n      Tracker.onInvalidate(function () {\n        // clean up [key][serializedValue] if it's now empty, so we don't\n        // use O(n) memory for n = values seen ever\n        if (! that._dict.keyValueDeps[key][serializedValue].hasDependents())\n          delete that._dict.keyValueDeps[key][serializedValue];\n      });\n    }\n  }\n\n  var oldValue = this.get(key);\n\n  return EJSON.equals(oldValue, value);\n};\n\n// === SET TEMPORARY ===\n// alias to .set(); sets a non-persistent variable\nPersistentSession.prototype.setTemporary = function _psSetTemp(keyOrObject, value) {\n  this.set(keyOrObject, value, false, false);\n};\nPersistentSession.prototype.setTemp = function _psSetTemp(keyOrObject, value) {\n  this.set(keyOrObject, value, false, false);\n};\n\n// === SET PERSISTENT ===\n// alias to .set(); sets a persistent variable\nPersistentSession.prototype.setPersistent = function _psSetPersistent(keyOrObject, value) {\n  this.set(keyOrObject, value, true, false);\n};\n\n// === SET AUTHENTICATED ===\n// alias to .set(); sets a persistent variable that will be removed on logout\nPersistentSession.prototype.setAuth = function _psSetAuth(keyOrObject, value) {\n  this.set(keyOrObject, value, true, true);\n};\n\n\n// === MAKE TEMP / PERSISTENT / AUTH ===\n// change the type of session var\nPersistentSession.prototype.makeTemp = function _psMakeTemp(key) {\n  this.store('temporary', key);\n};\nPersistentSession.prototype.makePersistent = function _psMakePersistent(key) {\n  var val = this.get(key);\n  this.store('persistent', key, val);\n};\nPersistentSession.prototype.makeAuth = function _psMakeAuth(key) {\n  var val = this.get(key);\n  this.store('authenticated', key, val);\n};\n\n\n\n// === CLEAR ===\nPersistentSession.prototype.old_clear = function (/* arguments */){\n  return this._dict.clear.apply(this._dict, arguments);\n};\n\n// more or less how it's implemented in reactive dict, but add support for removing single or arrays of keys\n// Derived from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L153-L167\nPersistentSession.prototype.clear = function _psClear(key, list) {\n  var self = this;\n  var oldKeys = self._dict.keys;\n\n  if ((key === undefined) && (list === undefined)) {\n    list = oldKeys;\n  } else if (!(key === undefined)) {\n    list = [key]\n  } else {\n    // list = list\n  }\n\n  // okay, if it was an array of keys, find the old key pairings for reactivity\n  if (_.isArray(list)){\n    var oldList = list;\n    var list = {}\n    _.each(oldList, function (key) {\n      list[key] = oldKeys[key];\n    });\n  }\n\n  _.each(list, function(value, akey) {\n    self.set(akey, undefined, false, false);\n\n    changed(self._dict.keyDeps[akey]);\n    if (self._dict.keyValueDeps[akey]) {\n      changed(self._dict.keyValueDeps[akey][value]);\n      changed(self._dict.keyValueDeps[akey]['undefined']);\n    }\n\n    delete self._dict.keys[akey]; // remove the key\n  });\n\n  // reactive-dict 1.1.0+\n  if (self._dict.allDeps) {\n    self._dict.allDeps.changed();\n  }\n};\n\n\n// === CLEAR TEMP ===\n// clears all the temporary keys\nPersistentSession.prototype.clearTemp = function _psClearTemp() {\n  this.clear(undefined, _.keys(_.omit(this._dict.keys, this.psKeys, this.psaKeys)));\n};\n\n// === CLEAR PERSISTENT ===\n// clears all persistent keys\nPersistentSession.prototype.clearPersistent = function _psClearPersistent() {\n  this.clear(undefined, this.psKeys);\n};\n\n// === CLEAR AUTH ===\n// clears all authenticated keys\nPersistentSession.prototype.clearAuth = function _psClearAuth() {\n  this.clear(undefined, this.psaKeys);\n};\n\n\n\n\n// === UPDATE ===\n// updates the value of a session var without changing its type\nPersistentSession.prototype.update = function _psUpdate(key, value) {\n  var persist, auth;\n  if ( _.indexOf(this.psaKeyList, key) >= 0 ) { auth = true; }\n  if ( auth || _.indexOf(this.psKeyList, key) >= 0 ) { persist = true; }\n  this.set(key, value, persist, auth);\n};\n\n// === SET DEFAULT ===\nPersistentSession.prototype.old_setDefault = function (/* arguments */){\n  return this._dict.setDefault.apply(this._dict, arguments);\n};\nPersistentSession.prototype.setDefault = function _psSetDefault(keyOrObject, value, persist, auth) {\n  var self = this;\n\n  if (_.isObject(keyOrObject)) {\n    _.each(keyOrObject, function(value, key) {\n      self.setDefault(key, value, persist, auth);\n    });\n    return;\n  }\n\n  if ( this.get(keyOrObject) === undefined) {\n    this.set(keyOrObject, value, persist, auth);\n  }\n};\n\n// === SET DEFAULT TEMP ===\nPersistentSession.prototype.setDefaultTemp = function _psSetDefaultTemp(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, false, false);\n};\n\n// === SET DEFAULT PERSISTENT ===\nPersistentSession.prototype.setDefaultPersistent = function _psSetDefaultPersistent(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, true, false);\n};\n\n// === SET DEFAULT AUTH ===\nPersistentSession.prototype.setDefaultAuth = function _psSetDefaultAuth(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, true, true);\n};\n\n// automatically apply PersistentSession to Session\nvar oldSession = _.clone(Session);\n_.extend(Session, new PersistentSession(\"session\"))\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"u2622:persistent-session\", {\n  PersistentSession: PersistentSession\n});\n\n})();\n","servePath":"/packages/u2622_persistent-session.js"}]