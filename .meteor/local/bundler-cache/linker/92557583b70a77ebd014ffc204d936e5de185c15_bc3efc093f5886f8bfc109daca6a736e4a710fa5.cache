[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"server-render\":{\"server.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/server-render/server.js                                                                               //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nmodule.export({\n  onPageLoad: () => onPageLoad\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nmodule.watch(require(\"./server-register.js\"));\nconst startupPromise = new Promise(Meteor.startup);\nconst pageLoadCallbacks = new Set();\n\nfunction onPageLoad(callback) {\n  if (typeof callback === \"function\") {\n    pageLoadCallbacks.add(callback);\n  } // Return the callback so that it can be more easily removed later.\n\n\n  return callback;\n}\n\nonPageLoad.remove = function (callback) {\n  pageLoadCallbacks.delete(callback);\n};\n\nonPageLoad.clear = function () {\n  pageLoadCallbacks.clear();\n};\n\nonPageLoad.chain = function (handler) {\n  return startupPromise.then(() => {\n    let promise = Promise.resolve();\n    pageLoadCallbacks.forEach(callback => {\n      promise = promise.then(() => handler(callback));\n    });\n    return promise;\n  });\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"server-register.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/server-render/server-register.js                                                                      //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nlet WebAppInternals;\nmodule.watch(require(\"meteor/webapp\"), {\n  WebAppInternals(v) {\n    WebAppInternals = v;\n  }\n\n}, 0);\nlet MagicString;\nmodule.watch(require(\"magic-string\"), {\n  default(v) {\n    MagicString = v;\n  }\n\n}, 1);\nlet SAXParser;\nmodule.watch(require(\"parse5\"), {\n  SAXParser(v) {\n    SAXParser = v;\n  }\n\n}, 2);\nlet createStream;\nmodule.watch(require(\"combined-stream2\"), {\n  create(v) {\n    createStream = v;\n  }\n\n}, 3);\nlet ServerSink, isReadable;\nmodule.watch(require(\"./server-sink.js\"), {\n  ServerSink(v) {\n    ServerSink = v;\n  },\n\n  isReadable(v) {\n    isReadable = v;\n  }\n\n}, 4);\nlet onPageLoad;\nmodule.watch(require(\"./server.js\"), {\n  onPageLoad(v) {\n    onPageLoad = v;\n  }\n\n}, 5);\nWebAppInternals.registerBoilerplateDataCallback(\"meteor/server-render\", (request, data, arch) => {\n  const sink = new ServerSink(request, arch);\n  return onPageLoad.chain(callback => callback(sink, request)).then(() => {\n    if (!sink.maybeMadeChanges) {\n      return false;\n    }\n\n    let reallyMadeChanges = false;\n\n    function rewrite(property) {\n      const html = data[property];\n\n      if (typeof html !== \"string\") {\n        return;\n      }\n\n      const magic = new MagicString(html);\n      const parser = new SAXParser({\n        locationInfo: true\n      });\n      data[property] = parser;\n\n      if (Object.keys(sink.htmlById).length) {\n        const stream = createStream();\n        let lastStart = magic.start;\n        parser.on(\"startTag\", (name, attrs, selfClosing, loc) => {\n          attrs.some(attr => {\n            if (attr.name === \"id\") {\n              let html = sink.htmlById[attr.value];\n\n              if (html) {\n                reallyMadeChanges = true;\n                const start = magic.slice(lastStart, loc.endOffset);\n                stream.append(Buffer.from(start, \"utf8\"));\n                stream.append(typeof html === \"string\" ? Buffer.from(html, \"utf8\") : html);\n                lastStart = loc.endOffset;\n              }\n\n              return true;\n            }\n          });\n        });\n        parser.on(\"endTag\", (name, location) => {\n          if (location.endOffset === html.length) {\n            // reached the end of the template\n            const end = magic.slice(lastStart);\n            stream.append(Buffer.from(end, \"utf8\"));\n          }\n        });\n        data[property] = stream;\n      }\n\n      parser.write(html, parser.end.bind(parser));\n    }\n\n    if (sink.head) {\n      data.dynamicHead = (data.dynamicHead || \"\") + sink.head;\n      reallyMadeChanges = true;\n    }\n\n    if (Object.keys(sink.htmlById).length > 0) {\n      // We don't currently allow injecting HTML into the <head> except\n      // by calling sink.appendHead(html).\n      rewrite(\"body\");\n      rewrite(\"dynamicBody\");\n    }\n\n    if (sink.body) {\n      data.dynamicBody = (data.dynamicBody || \"\") + sink.body;\n      reallyMadeChanges = true;\n    }\n\n    if (sink.statusCode) {\n      data.statusCode = sink.statusCode;\n      reallyMadeChanges = true;\n    }\n\n    if (Object.keys(sink.responseHeaders)) {\n      data.headers = sink.responseHeaders;\n      reallyMadeChanges = true;\n    }\n\n    return reallyMadeChanges;\n  });\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"server-sink.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/server-render/server-sink.js                                                                          //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nmodule.export({\n  ServerSink: () => ServerSink,\n  isReadable: () => isReadable\n});\n\nclass ServerSink {\n  constructor(request, arch) {\n    this.request = request;\n    this.arch = arch;\n    this.head = \"\";\n    this.body = \"\";\n    this.htmlById = Object.create(null);\n    this.maybeMadeChanges = false;\n    this.statusCode = null;\n    this.responseHeaders = {};\n  }\n\n  appendToHead(html) {\n    if (appendContent(this, \"head\", html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  appendToBody(html) {\n    if (appendContent(this, \"body\", html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  appendToElementById(id, html) {\n    if (appendContent(this.htmlById, id, html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  renderIntoElementById(id, html) {\n    this.htmlById[id] = \"\";\n    this.appendToElementById(id, html);\n  }\n\n  redirect(location, code = 301) {\n    this.maybeMadeChanges = true;\n    this.statusCode = code;\n    this.responseHeaders.Location = location;\n  } // server only methods\n\n\n  setStatusCode(code) {\n    this.maybeMadeChanges = true;\n    this.statusCode = code;\n  }\n\n  setHeader(key, value) {\n    this.maybeMadeChanges = true;\n    this.responseHeaders[key] = value;\n  }\n\n  getHeaders() {\n    return this.request.headers;\n  }\n\n  getCookies() {\n    return this.request.cookies;\n  }\n\n}\n\nfunction isReadable(stream) {\n  return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function' && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';\n}\n\nfunction appendContent(object, property, content) {\n  let madeChanges = false;\n\n  if (Array.isArray(content)) {\n    content.forEach(elem => {\n      if (appendContent(object, property, elem)) {\n        madeChanges = true;\n      }\n    });\n  } else if (isReadable(content)) {\n    object[property] = content;\n    madeChanges = true;\n  } else if (content = content && content.toString(\"utf8\")) {\n    object[property] = (object[property] || \"\") + content;\n    madeChanges = true;\n  }\n\n  return madeChanges;\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"magic-string\":{\"package.json\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/magic-string/package.json                                       //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nexports.name = \"magic-string\";\nexports.version = \"0.21.3\";\nexports.main = \"dist/magic-string.cjs.js\";\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dist\":{\"magic-string.cjs.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/magic-string/dist/magic-string.cjs.js                           //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n'use strict';\n\nvar vlq = require('vlq');\n\nfunction Chunk ( start, end, content ) {\n\tthis.start = start;\n\tthis.end = end;\n\tthis.original = content;\n\n\tthis.intro = '';\n\tthis.outro = '';\n\n\tthis.content = content;\n\tthis.storeName = false;\n\tthis.edited = false;\n\n\t// we make these non-enumerable, for sanity while debugging\n\tObject.defineProperties( this, {\n\t\tprevious: { writable: true, value: null },\n\t\tnext: { writable: true, value: null }\n\t});\n}\n\nChunk.prototype = {\n\tappendLeft: function appendLeft ( content ) {\n\t\tthis.outro += content;\n\t},\n\n\tappendRight: function appendRight ( content ) {\n\t\tthis.intro = this.intro + content;\n\t},\n\n\tclone: function clone () {\n\t\tvar chunk = new Chunk( this.start, this.end, this.original );\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t},\n\n\tcontains: function contains ( index ) {\n\t\treturn this.start < index && index < this.end;\n\t},\n\n\teachNext: function eachNext ( fn ) {\n\t\tvar chunk = this;\n\t\twhile ( chunk ) {\n\t\t\tfn( chunk );\n\t\t\tchunk = chunk.next;\n\t\t}\n\t},\n\n\teachPrevious: function eachPrevious ( fn ) {\n\t\tvar chunk = this;\n\t\twhile ( chunk ) {\n\t\t\tfn( chunk );\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t},\n\n\tedit: function edit ( content, storeName, contentOnly ) {\n\t\tthis.content = content;\n\t\tif ( !contentOnly ) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t},\n\n\tprependLeft: function prependLeft ( content ) {\n\t\tthis.outro = content + this.outro;\n\t},\n\n\tprependRight: function prependRight ( content ) {\n\t\tthis.intro = content + this.intro;\n\t},\n\n\tsplit: function split ( index ) {\n\t\tvar sliceIndex = index - this.start;\n\n\t\tvar originalBefore = this.original.slice( 0, sliceIndex );\n\t\tvar originalAfter = this.original.slice( sliceIndex );\n\n\t\tthis.original = originalBefore;\n\n\t\tvar newChunk = new Chunk( index, this.end, originalAfter );\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif ( this.edited ) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit( '', false );\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif ( newChunk.next ) { newChunk.next.previous = newChunk; }\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t},\n\n\ttoString: function toString () {\n\t\treturn this.intro + this.content + this.outro;\n\t},\n\n\ttrimEnd: function trimEnd ( rx ) {\n\t\tthis.outro = this.outro.replace( rx, '' );\n\t\tif ( this.outro.length ) { return true; }\n\n\t\tvar trimmed = this.content.replace( rx, '' );\n\n\t\tif ( trimmed.length ) {\n\t\t\tif ( trimmed !== this.content ) {\n\t\t\t\tthis.split( this.start + trimmed.length ).edit( '', false );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit( '', false );\n\n\t\t\tthis.intro = this.intro.replace( rx, '' );\n\t\t\tif ( this.intro.length ) { return true; }\n\t\t}\n\t},\n\n\ttrimStart: function trimStart ( rx ) {\n\t\tthis.intro = this.intro.replace( rx, '' );\n\t\tif ( this.intro.length ) { return true; }\n\n\t\tvar trimmed = this.content.replace( rx, '' );\n\n\t\tif ( trimmed.length ) {\n\t\t\tif ( trimmed !== this.content ) {\n\t\t\t\tthis.split( this.end - trimmed.length );\n\t\t\t\tthis.edit( '', false );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit( '', false );\n\n\t\t\tthis.outro = this.outro.replace( rx, '' );\n\t\t\tif ( this.outro.length ) { return true; }\n\t\t}\n\t}\n};\n\nvar _btoa;\n\nif ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {\n\t_btoa = window.btoa;\n} else if ( typeof Buffer === 'function' ) {\n\t_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };\n} else {\n\t_btoa = function () {\n\t\tthrow new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );\n\t};\n}\n\nvar btoa = _btoa;\n\nfunction SourceMap ( properties ) {\n\tthis.version = 3;\n\n\tthis.file           = properties.file;\n\tthis.sources        = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names          = properties.names;\n\tthis.mappings       = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString: function toString () {\n\t\treturn JSON.stringify( this );\n\t},\n\n\ttoUrl: function toUrl () {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\n\t}\n};\n\nfunction guessIndent ( code ) {\n\tvar lines = code.split( '\\n' );\n\n\tvar tabbed = lines.filter( function (line) { return /^\\t+/.test( line ); } );\n\tvar spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );\n\n\tif ( tabbed.length === 0 && spaced.length === 0 ) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif ( tabbed.length >= spaced.length ) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tvar min = spaced.reduce( function ( previous, current ) {\n\t\tvar numSpaces = /^ +/.exec( current )[0].length;\n\t\treturn Math.min( numSpaces, previous );\n\t}, Infinity );\n\n\treturn new Array( min + 1 ).join( ' ' );\n}\n\nfunction getRelativePath ( from, to ) {\n\tvar fromParts = from.split( /[\\/\\\\]/ );\n\tvar toParts = to.split( /[\\/\\\\]/ );\n\n\tfromParts.pop(); // get dirname\n\n\twhile ( fromParts[0] === toParts[0] ) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif ( fromParts.length ) {\n\t\tvar i = fromParts.length;\n\t\twhile ( i-- ) { fromParts[i] = '..'; }\n\t}\n\n\treturn fromParts.concat( toParts ).join( '/' );\n}\n\nvar toString$1 = Object.prototype.toString;\n\nfunction isObject ( thing ) {\n\treturn toString$1.call( thing ) === '[object Object]';\n}\n\nfunction getLocator ( source ) {\n\tvar originalLines = source.split( '\\n' );\n\n\tvar start = 0;\n\tvar lineRanges = originalLines.map( function ( line, i ) {\n\t\tvar end = start + line.length + 1;\n\t\tvar range = { start: start, end: end, line: i };\n\n\t\tstart = end;\n\t\treturn range;\n\t});\n\n\tvar i = 0;\n\n\tfunction rangeContains ( range, index ) {\n\t\treturn range.start <= index && index < range.end;\n\t}\n\n\tfunction getLocation ( range, index ) {\n\t\treturn { line: range.line, column: index - range.start };\n\t}\n\n\treturn function locate ( index ) {\n\t\tvar range = lineRanges[i];\n\n\t\tvar d = index >= range.end ? 1 : -1;\n\n\t\twhile ( range ) {\n\t\t\tif ( rangeContains( range, index ) ) { return getLocation( range, index ); }\n\n\t\t\ti += d;\n\t\t\trange = lineRanges[i];\n\t\t}\n\t};\n}\n\nfunction Mappings ( hires ) {\n\tvar this$1 = this;\n\n\tvar offsets = {\n\t\tgeneratedCodeColumn: 0,\n\t\tsourceIndex: 0,\n\t\tsourceCodeLine: 0,\n\t\tsourceCodeColumn: 0,\n\t\tsourceCodeName: 0\n\t};\n\n\tvar generatedCodeLine = 0;\n\tvar generatedCodeColumn = 0;\n\n\tthis.raw = [];\n\tvar rawSegments = this.raw[ generatedCodeLine ] = [];\n\n\tvar pending = null;\n\n\tthis.addEdit = function ( sourceIndex, content, original, loc, nameIndex ) {\n\t\tif ( content.length ) {\n\t\t\trawSegments.push([\n\t\t\t\tgeneratedCodeColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\tloc.line,\n\t\t\t\tloc.column,\n\t\t\t\tnameIndex ]);\n\t\t} else if ( pending ) {\n\t\t\trawSegments.push( pending );\n\t\t}\n\n\t\tthis$1.advance( content );\n\t\tpending = null;\n\t};\n\n\tthis.addUneditedChunk = function ( sourceIndex, chunk, original, loc, sourcemapLocations ) {\n\t\tvar originalCharIndex = chunk.start;\n\t\tvar first = true;\n\n\t\twhile ( originalCharIndex < chunk.end ) {\n\t\t\tif ( hires || first || sourcemapLocations[ originalCharIndex ] ) {\n\t\t\t\trawSegments.push([\n\t\t\t\t\tgeneratedCodeColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tloc.line,\n\t\t\t\t\tloc.column,\n\t\t\t\t\t-1\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tif ( original[ originalCharIndex ] === '\\n' ) {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tgeneratedCodeLine += 1;\n\t\t\t\tthis$1.raw[ generatedCodeLine ] = rawSegments = [];\n\t\t\t\tgeneratedCodeColumn = 0;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tgeneratedCodeColumn += 1;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t\tfirst = false;\n\t\t}\n\n\t\tpending = [\n\t\t\tgeneratedCodeColumn,\n\t\t\tsourceIndex,\n\t\t\tloc.line,\n\t\t\tloc.column,\n\t\t\t-1 ];\n\t};\n\n\tthis.advance = function (str) {\n\t\tif ( !str ) { return; }\n\n\t\tvar lines = str.split( '\\n' );\n\t\tvar lastLine = lines.pop();\n\n\t\tif ( lines.length ) {\n\t\t\tgeneratedCodeLine += lines.length;\n\t\t\tthis$1.raw[ generatedCodeLine ] = rawSegments = [];\n\t\t\tgeneratedCodeColumn = lastLine.length;\n\t\t} else {\n\t\t\tgeneratedCodeColumn += lastLine.length;\n\t\t}\n\t};\n\n\tthis.encode = function () {\n\t\treturn this$1.raw.map( function (segments) {\n\t\t\tvar generatedCodeColumn = 0;\n\n\t\t\treturn segments.map( function (segment) {\n\t\t\t\tvar arr = [\n\t\t\t\t\tsegment[0] - generatedCodeColumn,\n\t\t\t\t\tsegment[1] - offsets.sourceIndex,\n\t\t\t\t\tsegment[2] - offsets.sourceCodeLine,\n\t\t\t\t\tsegment[3] - offsets.sourceCodeColumn\n\t\t\t\t];\n\n\t\t\t\tgeneratedCodeColumn = segment[0];\n\t\t\t\toffsets.sourceIndex = segment[1];\n\t\t\t\toffsets.sourceCodeLine = segment[2];\n\t\t\t\toffsets.sourceCodeColumn = segment[3];\n\n\t\t\t\tif ( ~segment[4] ) {\n\t\t\t\t\tarr.push( segment[4] - offsets.sourceCodeName );\n\t\t\t\t\toffsets.sourceCodeName = segment[4];\n\t\t\t\t}\n\n\t\t\t\treturn vlq.encode( arr );\n\t\t\t}).join( ',' );\n\t\t}).join( ';' );\n\t};\n}\n\nvar Stats = function Stats () {\n\tObject.defineProperties( this, {\n\t\tstartTimes: { value: {} }\n\t});\n};\n\nStats.prototype.time = function time ( label ) {\n\tthis.startTimes[ label ] = process.hrtime();\n};\n\nStats.prototype.timeEnd = function timeEnd ( label ) {\n\tvar elapsed = process.hrtime( this.startTimes[ label ] );\n\n\tif ( !this[ label ] ) { this[ label ] = 0; }\n\tthis[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;\n};\n\nvar warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nfunction MagicString$1 ( string, options ) {\n\tif ( options === void 0 ) options = {};\n\n\tvar chunk = new Chunk( 0, string.length, string );\n\n\tObject.defineProperties( this, {\n\t\toriginal:              { writable: true, value: string },\n\t\toutro:                 { writable: true, value: '' },\n\t\tintro:                 { writable: true, value: '' },\n\t\tfirstChunk:            { writable: true, value: chunk },\n\t\tlastChunk:             { writable: true, value: chunk },\n\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\tbyStart:               { writable: true, value: {} },\n\t\tbyEnd:                 { writable: true, value: {} },\n\t\tfilename:              { writable: true, value: options.filename },\n\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\tsourcemapLocations:    { writable: true, value: {} },\n\t\tstoredNames:           { writable: true, value: {} },\n\t\tindentStr:             { writable: true, value: guessIndent( string ) }\n\t});\n\n\tthis.byStart[ 0 ] = chunk;\n\tthis.byEnd[ string.length ] = chunk;\n}\n\nMagicString$1.prototype = {\n\taddSourcemapLocation: function addSourcemapLocation ( char ) {\n\t\tthis.sourcemapLocations[ char ] = true;\n\t},\n\n\tappend: function append ( content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t},\n\n\tappendLeft: function appendLeft ( index, content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }\n\n\t\tthis._split( index );\n\n\t\tvar chunk = this.byEnd[ index ];\n\n\t\tif ( chunk ) {\n\t\t\tchunk.appendLeft( content );\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tappendRight: function appendRight ( index, content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }\n\n\t\tthis._split( index );\n\n\t\tvar chunk = this.byStart[ index ];\n\n\t\tif ( chunk ) {\n\t\t\tchunk.appendRight( content );\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function clone () {\n\t\tvar cloned = new MagicString$1( this.original, { filename: this.filename });\n\n\t\tvar originalChunk = this.firstChunk;\n\t\tvar clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n\t\twhile ( originalChunk ) {\n\t\t\tcloned.byStart[ clonedChunk.start ] = clonedChunk;\n\t\t\tcloned.byEnd[ clonedChunk.end ] = clonedChunk;\n\n\t\t\tvar nextOriginalChunk = originalChunk.next;\n\t\t\tvar nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif ( nextClonedChunk ) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif ( this.indentExclusionRanges ) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tObject.keys( this.sourcemapLocations ).forEach( function (loc) {\n\t\t\tcloned.sourcemapLocations[ loc ] = true;\n\t\t});\n\n\t\treturn cloned;\n\t},\n\n\tgenerateMap: function generateMap ( options ) {\n\t\tvar this$1 = this;\n\n\t\toptions = options || {};\n\n\t\tvar sourceIndex = 0;\n\t\tvar names = Object.keys( this.storedNames );\n\t\tvar mappings = new Mappings( options.hires );\n\n\t\tvar locate = getLocator( this.original );\n\n\t\tif ( this.intro ) {\n\t\t\tmappings.advance( this.intro );\n\t\t}\n\n\t\tthis.firstChunk.eachNext( function (chunk) {\n\t\t\tvar loc = locate( chunk.start );\n\n\t\t\tif ( chunk.intro.length ) { mappings.advance( chunk.intro ); }\n\n\t\t\tif ( chunk.edited ) {\n\t\t\t\tmappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk( sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations );\n\t\t\t}\n\n\t\t\tif ( chunk.outro.length ) { mappings.advance( chunk.outro ); }\n\t\t});\n\n\t\tvar map = new SourceMap({\n\t\t\tfile: ( options.file ? options.file.split( /[\\/\\\\]/ ).pop() : null ),\n\t\t\tsources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],\n\t\t\tsourcesContent: options.includeContent ? [ this.original ] : [ null ],\n\t\t\tnames: names,\n\t\t\tmappings: mappings.encode()\n\t\t});\n\t\treturn map;\n\t},\n\n\tgetIndentString: function getIndentString () {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t},\n\n\tindent: function indent ( indentStr, options ) {\n\t\tvar this$1 = this;\n\n\t\tvar pattern = /^[^\\r\\n]/gm;\n\n\t\tif ( isObject( indentStr ) ) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\\t' );\n\n\t\tif ( indentStr === '' ) { return this; } // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tvar isExcluded = {};\n\n\t\tif ( options.exclude ) {\n\t\t\tvar exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;\n\t\t\texclusions.forEach( function (exclusion) {\n\t\t\t\tfor ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar shouldIndentNextCharacter = options.indentStart !== false;\n\t\tvar replacer = function (match) {\n\t\t\tif ( shouldIndentNextCharacter ) { return (\"\" + indentStr + match); }\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace( pattern, replacer );\n\n\t\tvar charIndex = 0;\n\n\t\tvar chunk = this.firstChunk;\n\n\t\twhile ( chunk ) {\n\t\t\tvar end = chunk.end;\n\n\t\t\tif ( chunk.edited ) {\n\t\t\t\tif ( !isExcluded[ charIndex ] ) {\n\t\t\t\t\tchunk.content = chunk.content.replace( pattern, replacer );\n\n\t\t\t\t\tif ( chunk.content.length ) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile ( charIndex < end ) {\n\t\t\t\t\tif ( !isExcluded[ charIndex ] ) {\n\t\t\t\t\t\tvar char = this$1.original[ charIndex ];\n\n\t\t\t\t\t\tif ( char === '\\n' ) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if ( char !== '\\r' && shouldIndentNextCharacter ) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif ( charIndex === chunk.start ) {\n\t\t\t\t\t\t\t\tchunk.prependRight( indentStr );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar rhs = chunk.split( charIndex );\n\t\t\t\t\t\t\t\trhs.prependRight( indentStr );\n\n\t\t\t\t\t\t\t\tthis$1.byStart[ charIndex ] = rhs;\n\t\t\t\t\t\t\t\tthis$1.byEnd[ charIndex ] = chunk;\n\n\t\t\t\t\t\t\t\tchunk = rhs;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace( pattern, replacer );\n\n\t\treturn this;\n\t},\n\n\tinsert: function insert () {\n\t\tthrow new Error( 'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)' );\n\t},\n\n\tinsertLeft: function insertLeft ( index, content ) {\n\t\tif ( !warned.insertLeft ) {\n\t\t\tconsole.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft( index, content );\n\t},\n\n\tinsertRight: function insertRight ( index, content ) {\n\t\tif ( !warned.insertRight ) {\n\t\t\tconsole.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight( index, content );\n\t},\n\n\tmove: function move ( start, end, index ) {\n\t\tif ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }\n\n\t\tthis._split( start );\n\t\tthis._split( end );\n\t\tthis._split( index );\n\n\t\tvar first = this.byStart[ start ];\n\t\tvar last = this.byEnd[ end ];\n\n\t\tvar oldLeft = first.previous;\n\t\tvar oldRight = last.next;\n\n\t\tvar newRight = this.byStart[ index ];\n\t\tif ( !newRight && last === this.lastChunk ) { return this; }\n\t\tvar newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif ( oldLeft ) { oldLeft.next = oldRight; }\n\t\tif ( oldRight ) { oldRight.previous = oldLeft; }\n\n\t\tif ( newLeft ) { newLeft.next = first; }\n\t\tif ( newRight ) { newRight.previous = last; }\n\n\t\tif ( !first.previous ) { this.firstChunk = last.next; }\n\t\tif ( !last.next ) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight;\n\n\t\tif ( !newLeft ) { this.firstChunk = first; }\n\t\tif ( !newRight ) { this.lastChunk = last; }\n\n\t\treturn this;\n\t},\n\n\toverwrite: function overwrite ( start, end, content, options ) {\n\t\tvar this$1 = this;\n\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }\n\n\t\twhile ( start < 0 ) { start += this$1.original.length; }\n\t\twhile ( end < 0 ) { end += this$1.original.length; }\n\n\t\tif ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }\n\t\tif ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range – use appendLeft or prependRight instead' ); }\n\n\t\tthis._split( start );\n\t\tthis._split( end );\n\n\t\tif ( options === true ) {\n\t\t\tif ( !warned.storeName ) {\n\t\t\t\tconsole.warn( 'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string' ); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tvar storeName = options !== undefined ? options.storeName : false;\n\t\tvar contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif ( storeName ) {\n\t\t\tvar original = this.original.slice( start, end );\n\t\t\tthis.storedNames[ original ] = true;\n\t\t}\n\n\t\tvar first = this.byStart[ start ];\n\t\tvar last = this.byEnd[ end ];\n\n\t\tif ( first ) {\n\t\t\tif ( end > first.end && first.next !== this.byStart[ first.end ] ) {\n\t\t\t\tthrow new Error( 'Cannot overwrite across a split point' );\n\t\t\t}\n\n\t\t\tfirst.edit( content, storeName, contentOnly );\n\n\t\t\tif ( last ) {\n\t\t\t\tfirst.next = last.next;\n\t\t\t} else {\n\t\t\t\tfirst.next = null;\n\t\t\t\tthis.lastChunk = first;\n\t\t\t}\n\n\t\t\tfirst.original = this.original.slice( start, end );\n\t\t\tfirst.end = end;\n\t\t}\n\n\t\telse {\n\t\t\t// must be inserting at the end\n\t\t\tvar newChunk = new Chunk( start, end, '' ).edit( content, storeName );\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tprepend: function prepend ( content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t},\n\n\tprependLeft: function prependLeft ( index, content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }\n\n\t\tthis._split( index );\n\n\t\tvar chunk = this.byEnd[ index ];\n\n\t\tif ( chunk ) {\n\t\t\tchunk.prependLeft( content );\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tprependRight: function prependRight ( index, content ) {\n\t\tif ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }\n\n\t\tthis._split( index );\n\n\t\tvar chunk = this.byStart[ index ];\n\n\t\tif ( chunk ) {\n\t\t\tchunk.prependRight( content );\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremove: function remove ( start, end ) {\n\t\tvar this$1 = this;\n\n\t\twhile ( start < 0 ) { start += this$1.original.length; }\n\t\twhile ( end < 0 ) { end += this$1.original.length; }\n\n\t\tif ( start === end ) { return this; }\n\n\t\tif ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }\n\t\tif ( start > end ) { throw new Error( 'end must be greater than start' ); }\n\n\t\tthis._split( start );\n\t\tthis._split( end );\n\n\t\tvar chunk = this.byStart[ start ];\n\n\t\twhile ( chunk ) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit( '' );\n\n\t\t\tchunk = end > chunk.end ? this$1.byStart[ chunk.end ] : null;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tslice: function slice ( start, end ) {\n\t\tvar this$1 = this;\n\t\tif ( start === void 0 ) start = 0;\n\t\tif ( end === void 0 ) end = this.original.length;\n\n\t\twhile ( start < 0 ) { start += this$1.original.length; }\n\t\twhile ( end < 0 ) { end += this$1.original.length; }\n\n\t\tvar result = '';\n\n\t\t// find start chunk\n\t\tvar chunk = this.firstChunk;\n\t\twhile ( chunk && ( chunk.start > start || chunk.end <= start ) ) {\n\n\t\t\t// found end chunk before start\n\t\t\tif ( chunk.start < end && chunk.end >= end ) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif ( chunk && chunk.edited && chunk.start !== start ) { throw new Error((\"Cannot use replaced character \" + start + \" as slice start anchor.\")); }\n\n\t\tvar startChunk = chunk;\n\t\twhile ( chunk ) {\n\t\t\tif ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tvar containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error((\"Cannot use replaced character \" + end + \" as slice end anchor.\")); }\n\n\t\t\tvar sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tvar sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice( sliceStart, sliceEnd );\n\n\t\t\tif ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif ( containsEnd ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t// TODO deprecate this? not really very useful\n\tsnip: function snip ( start, end ) {\n\t\tvar clone = this.clone();\n\t\tclone.remove( 0, start );\n\t\tclone.remove( end, clone.original.length );\n\n\t\treturn clone;\n\t},\n\n\t_split: function _split ( index ) {\n\t\tvar this$1 = this;\n\n\t\tif ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }\n\n\t\tvar chunk = this.lastSearchedChunk;\n\t\tvar searchForward = index > chunk.end;\n\n\t\twhile ( true ) {\n\t\t\tif ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }\n\n\t\t\tchunk = searchForward ?\n\t\t\t\tthis$1.byStart[ chunk.end ] :\n\t\t\t\tthis$1.byEnd[ chunk.start ];\n\t\t}\n\t},\n\n\t_splitChunk: function _splitChunk ( chunk, index ) {\n\t\tif ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tvar loc = getLocator( this.original )( index );\n\t\t\tthrow new Error( (\"Cannot split a chunk that has already been edited (\" + (loc.line) + \":\" + (loc.column) + \" – \\\"\" + (chunk.original) + \"\\\")\") );\n\t\t}\n\n\t\tvar newChunk = chunk.split( index );\n\n\t\tthis.byEnd[ index ] = chunk;\n\t\tthis.byStart[ index ] = newChunk;\n\t\tthis.byEnd[ newChunk.end ] = newChunk;\n\n\t\tif ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t},\n\n\ttoString: function toString () {\n\t\tvar str = this.intro;\n\n\t\tvar chunk = this.firstChunk;\n\t\twhile ( chunk ) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t},\n\n\ttrimLines: function trimLines () {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t},\n\n\ttrim: function trim ( charType ) {\n\t\treturn this.trimStart( charType ).trimEnd( charType );\n\t},\n\n\ttrimEnd: function trimEnd ( charType ) {\n\t\tvar this$1 = this;\n\n\t\tvar rx = new RegExp( ( charType || '\\\\s' ) + '+$' );\n\n\t\tthis.outro = this.outro.replace( rx, '' );\n\t\tif ( this.outro.length ) { return this; }\n\n\t\tvar chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tvar end = chunk.end;\n\t\t\tvar aborted = chunk.trimEnd( rx );\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif ( chunk.end !== end ) {\n\t\t\t\tthis$1.lastChunk = chunk.next;\n\n\t\t\t\tthis$1.byEnd[ chunk.end ] = chunk;\n\t\t\t\tthis$1.byStart[ chunk.next.start ] = chunk.next;\n\t\t\t}\n\n\t\t\tif ( aborted ) { return this$1; }\n\t\t\tchunk = chunk.previous;\n\t\t} while ( chunk );\n\n\t\treturn this;\n\t},\n\n\ttrimStart: function trimStart ( charType ) {\n\t\tvar this$1 = this;\n\n\t\tvar rx = new RegExp( '^' + ( charType || '\\\\s' ) + '+' );\n\n\t\tthis.intro = this.intro.replace( rx, '' );\n\t\tif ( this.intro.length ) { return this; }\n\n\t\tvar chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tvar end = chunk.end;\n\t\t\tvar aborted = chunk.trimStart( rx );\n\n\t\t\tif ( chunk.end !== end ) {\n\t\t\t\t// special case...\n\t\t\t\tif ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }\n\n\t\t\t\tthis$1.byEnd[ chunk.end ] = chunk;\n\t\t\t\tthis$1.byStart[ chunk.next.start ] = chunk.next;\n\t\t\t}\n\n\t\t\tif ( aborted ) { return this$1; }\n\t\t\tchunk = chunk.next;\n\t\t} while ( chunk );\n\n\t\treturn this;\n\t}\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction Bundle ( options ) {\n\tif ( options === void 0 ) options = {};\n\n\tthis.intro = options.intro || '';\n\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\n\tthis.sources = [];\n\n\tthis.uniqueSources = [];\n\tthis.uniqueSourceIndexByFilename = {};\n}\n\nBundle.prototype = {\n\taddSource: function addSource ( source ) {\n\t\tif ( source instanceof MagicString$1 ) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif ( !isObject( source ) || !source.content ) {\n\t\t\tthrow new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );\n\t\t}\n\n\t\t[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {\n\t\t\tif ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }\n\t\t});\n\n\t\tif ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif ( source.filename ) {\n\t\t\tif ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tvar uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];\n\t\t\t\tif ( source.content.original !== uniqueSource.content ) {\n\t\t\t\t\tthrow new Error( (\"Illegal source: same filename (\" + (source.filename) + \"), different contents\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push( source );\n\t\treturn this;\n\t},\n\n\tappend: function append ( str, options ) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString$1( str ),\n\t\t\tseparator: ( options && options.separator ) || ''\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tclone: function clone () {\n\t\tvar bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach( function (source) {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t},\n\n\tgenerateMap: function generateMap ( options ) {\n\t\tvar this$1 = this;\n\t\tif ( options === void 0 ) options = {};\n\n\t\tvar names = [];\n\t\tthis.sources.forEach( function (source) {\n\t\t\tObject.keys( source.content.storedNames ).forEach( function (name) {\n\t\t\t\tif ( !~names.indexOf( name ) ) { names.push( name ); }\n\t\t\t});\n\t\t});\n\n\t\tvar mappings = new Mappings( options.hires );\n\n\t\tif ( this.intro ) {\n\t\t\tmappings.advance( this.intro );\n\t\t}\n\n\t\tthis.sources.forEach( function ( source, i ) {\n\t\t\tif ( i > 0 ) {\n\t\t\t\tmappings.advance( this$1.separator );\n\t\t\t}\n\n\t\t\tvar sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[ source.filename ] : -1;\n\t\t\tvar magicString = source.content;\n\t\t\tvar locate = getLocator( magicString.original );\n\n\t\t\tif ( magicString.intro ) {\n\t\t\t\tmappings.advance( magicString.intro );\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext( function (chunk) {\n\t\t\t\tvar loc = locate( chunk.start );\n\n\t\t\t\tif ( chunk.intro.length ) { mappings.advance( chunk.intro ); }\n\n\t\t\t\tif ( source.filename ) {\n\t\t\t\t\tif ( chunk.edited ) {\n\t\t\t\t\t\tmappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk( sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tmappings.advance( chunk.content );\n\t\t\t\t}\n\n\t\t\t\tif ( chunk.outro.length ) { mappings.advance( chunk.outro ); }\n\t\t\t});\n\n\t\t\tif ( magicString.outro ) {\n\t\t\t\tmappings.advance( magicString.outro );\n\t\t\t}\n\t\t});\n\n\t\treturn new SourceMap({\n\t\t\tfile: ( options.file ? options.file.split( /[\\/\\\\]/ ).pop() : null ),\n\t\t\tsources: this.uniqueSources.map( function (source) {\n\t\t\t\treturn options.file ? getRelativePath( options.file, source.filename ) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map( function (source) {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames: names,\n\t\t\tmappings: mappings.encode()\n\t\t});\n\t},\n\n\tgetIndentString: function getIndentString () {\n\t\tvar indentStringCounts = {};\n\n\t\tthis.sources.forEach( function (source) {\n\t\t\tvar indentStr = source.content.indentStr;\n\n\t\t\tif ( indentStr === null ) { return; }\n\n\t\t\tif ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }\n\t\t\tindentStringCounts[ indentStr ] += 1;\n\t\t});\n\n\t\treturn ( Object.keys( indentStringCounts ).sort( function ( a, b ) {\n\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t})[0] ) || '\\t';\n\t},\n\n\tindent: function indent ( indentStr ) {\n\t\tvar this$1 = this;\n\n\t\tif ( !arguments.length ) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif ( indentStr === '' ) { return this; } // noop\n\n\t\tvar trailingNewline = !this.intro || this.intro.slice( -1 ) === '\\n';\n\n\t\tthis.sources.forEach( function ( source, i ) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : this$1.separator;\n\t\t\tvar indentStart = trailingNewline || ( i > 0 && /\\r?\\n$/.test( separator ) );\n\n\t\t\tsource.content.indent( indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart: indentStart//: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\t// TODO this is a very slow way to determine this\n\t\t\ttrailingNewline = source.content.toString().slice( 0, -1 ) === '\\n';\n\t\t});\n\n\t\tif ( this.intro ) {\n\t\t\tthis.intro = indentStr + this.intro.replace( /^[^\\n]/gm, function ( match, index ) {\n\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tprepend: function prepend ( str ) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t},\n\n\ttoString: function toString () {\n\t\tvar this$1 = this;\n\n\t\tvar body = this.sources.map( function ( source, i ) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : this$1.separator;\n\t\t\tvar str = ( i > 0 ? separator : '' ) + source.content.toString();\n\n\t\t\treturn str;\n\t\t}).join( '' );\n\n\t\treturn this.intro + body;\n\t},\n\n\ttrimLines: function trimLines () {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t},\n\n\ttrim: function trim ( charType ) {\n\t\treturn this.trimStart( charType ).trimEnd( charType );\n\t},\n\n\ttrimStart: function trimStart ( charType ) {\n\t\tvar this$1 = this;\n\n\t\tvar rx = new RegExp( '^' + ( charType || '\\\\s' ) + '+' );\n\t\tthis.intro = this.intro.replace( rx, '' );\n\n\t\tif ( !this.intro ) {\n\t\t\tvar source;\n\t\t\tvar i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this$1.sources[i];\n\n\t\t\t\tif ( !source ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsource.content.trimStart( charType );\n\t\t\t\ti += 1;\n\t\t\t} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttrimEnd: function trimEnd ( charType ) {\n\t\tvar this$1 = this;\n\n\t\tvar rx = new RegExp( ( charType || '\\\\s' ) + '+$' );\n\n\t\tvar source;\n\t\tvar i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this$1.sources[i];\n\n\t\t\tif ( !source ) {\n\t\t\t\tthis$1.intro = this$1.intro.replace( rx, '' );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsource.content.trimEnd( charType );\n\t\t\ti -= 1;\n\t\t} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?\n\n\t\treturn this;\n\t}\n};\n\nMagicString$1.Bundle = Bundle;\nMagicString$1.default = MagicString$1; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString$1;\n//# sourceMappingURL=magic-string.cjs.js.map\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"parse5\":{\"package.json\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/parse5/package.json                                             //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nexports.name = \"parse5\";\nexports.version = \"3.0.2\";\nexports.main = \"./lib/index.js\";\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"index.js\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/parse5/lib/index.js                                             //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n'use strict';\n\nvar Parser = require('./parser'),\n    Serializer = require('./serializer');\n\n\n// Shorthands\nexports.parse = function parse(html, options) {\n    var parser = new Parser(options);\n\n    return parser.parse(html);\n};\n\nexports.parseFragment = function parseFragment(fragmentContext, html, options) {\n    if (typeof fragmentContext === 'string') {\n        options = html;\n        html = fragmentContext;\n        fragmentContext = null;\n    }\n\n    var parser = new Parser(options);\n\n    return parser.parseFragment(html, fragmentContext);\n};\n\nexports.serialize = function (node, options) {\n    var serializer = new Serializer(node, options);\n\n    return serializer.serialize();\n};\n\n\n// Tree adapters\nexports.treeAdapters = {\n    default: require('./tree_adapters/default'),\n    htmlparser2: require('./tree_adapters/htmlparser2')\n};\n\n\n// Streaming\nexports.ParserStream = require('./parser/parser_stream');\nexports.PlainTextConversionStream = require('./parser/plain_text_conversion_stream');\nexports.SerializerStream = require('./serializer/serializer_stream');\nexports.SAXParser = require('./sax');\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"combined-stream2\":{\"package.json\":function(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/combined-stream2/package.json                                   //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nexports.name = \"combined-stream2\";\nexports.version = \"1.1.2\";\nexports.main = \"index.js\";\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// node_modules/meteor/server-render/node_modules/combined-stream2/index.js                                       //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\nmodule.exports = require(\"./lib/combined-stream2\");\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/server-render/server.js\");\n\n/* Exports */\nPackage._define(\"server-render\", exports);\n\n})();\n","servePath":"/packages/server-render.js","sourceMap":{"version":3,"sources":["packages/server-render/server.js","packages/server-render/server-register.js","packages/server-render/server-sink.js"],"names":["module","export","onPageLoad","Meteor","watch","require","v","startupPromise","Promise","startup","pageLoadCallbacks","Set","callback","add","remove","delete","clear","chain","handler","then","promise","resolve","forEach","WebAppInternals","MagicString","default","SAXParser","createStream","create","ServerSink","isReadable","registerBoilerplateDataCallback","request","data","arch","sink","maybeMadeChanges","reallyMadeChanges","rewrite","property","html","magic","parser","locationInfo","Object","keys","htmlById","length","stream","lastStart","start","on","name","attrs","selfClosing","loc","some","attr","value","slice","endOffset","append","Buffer","from","location","end","write","bind","head","dynamicHead","body","dynamicBody","statusCode","responseHeaders","headers","constructor","appendToHead","appendContent","appendToBody","appendToElementById","id","renderIntoElementById","redirect","code","Location","setStatusCode","setHeader","key","getHeaders","getCookies","cookies","pipe","readable","_read","_readableState","object","content","madeChanges","Array","isArray","elem","toString"],"mappings":"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","file":"/packages/server-render.js","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport \"./server-register.js\";\n\nconst startupPromise = new Promise(Meteor.startup);\nconst pageLoadCallbacks = new Set;\n\nexport function onPageLoad(callback) {\n  if (typeof callback === \"function\") {\n    pageLoadCallbacks.add(callback);\n  }\n\n  // Return the callback so that it can be more easily removed later.\n  return callback;\n}\n\nonPageLoad.remove = function (callback) {\n  pageLoadCallbacks.delete(callback);\n};\n\nonPageLoad.clear = function () {\n  pageLoadCallbacks.clear();\n};\n\nonPageLoad.chain = function (handler) {\n  return startupPromise.then(() => {\n    let promise = Promise.resolve();\n    pageLoadCallbacks.forEach(callback => {\n      promise = promise.then(() => handler(callback));\n    });\n    return promise;\n  });\n};\n","import { WebAppInternals } from \"meteor/webapp\";\nimport MagicString from \"magic-string\";\nimport { SAXParser } from \"parse5\";\nimport { create as createStream } from \"combined-stream2\";\nimport { ServerSink, isReadable } from \"./server-sink.js\";\nimport { onPageLoad } from \"./server.js\";\n\nWebAppInternals.registerBoilerplateDataCallback(\n  \"meteor/server-render\",\n  (request, data, arch) => {\n    const sink = new ServerSink(request, arch);\n\n    return onPageLoad.chain(\n      callback => callback(sink, request)\n    ).then(() => {\n      if (! sink.maybeMadeChanges) {\n        return false;\n      }\n\n      let reallyMadeChanges = false;\n\n      function rewrite(property) {\n        const html = data[property];\n        if (typeof html !== \"string\") {\n          return;\n        }\n\n        const magic = new MagicString(html);\n        const parser = new SAXParser({\n          locationInfo: true\n        });\n\n        data[property] = parser;\n\n        if (Object.keys(sink.htmlById).length) {\n          const stream = createStream();\n\n          let lastStart = magic.start;\n          parser.on(\"startTag\", (name, attrs, selfClosing, loc) => {\n            attrs.some(attr => {\n              if (attr.name === \"id\") {\n                let html = sink.htmlById[attr.value];\n                if (html) {\n                  reallyMadeChanges = true;\n                  const start = magic.slice(lastStart, loc.endOffset);\n                  stream.append(Buffer.from(start, \"utf8\"));\n                  stream.append(\n                    typeof html === \"string\"\n                      ? Buffer.from(html, \"utf8\")\n                      : html\n                  );\n                  lastStart = loc.endOffset;\n                }\n                return true;\n              }\n            });\n          });\n\n          parser.on(\"endTag\", (name, location) => {\n            if (location.endOffset === html.length) {\n              // reached the end of the template\n              const end = magic.slice(lastStart);\n              stream.append(Buffer.from(end, \"utf8\"));\n            }\n          })\n\n          data[property] = stream;\n        }\n\n        parser.write(html, parser.end.bind(parser));\n      }\n\n      if (sink.head) {\n        data.dynamicHead = (data.dynamicHead || \"\") + sink.head;\n        reallyMadeChanges = true;\n      }\n\n      if (Object.keys(sink.htmlById).length > 0) {\n        // We don't currently allow injecting HTML into the <head> except\n        // by calling sink.appendHead(html).\n        rewrite(\"body\");\n        rewrite(\"dynamicBody\");\n      }\n\n      if (sink.body) {\n        data.dynamicBody = (data.dynamicBody || \"\") + sink.body;\n        reallyMadeChanges = true;\n      }\n\n      if (sink.statusCode) {\n        data.statusCode = sink.statusCode;\n        reallyMadeChanges = true;\n      }\n\n      if (Object.keys(sink.responseHeaders)){\n        data.headers = sink.responseHeaders;\n        reallyMadeChanges = true;\n      }\n\n      return reallyMadeChanges;\n    });\n  }\n);\n","export class ServerSink {\n  constructor(request, arch) {\n    this.request = request;\n    this.arch = arch;\n    this.head = \"\";\n    this.body = \"\";\n    this.htmlById = Object.create(null);\n    this.maybeMadeChanges = false;\n    this.statusCode = null;\n    this.responseHeaders = {};\n  }\n\n  appendToHead(html) {\n    if (appendContent(this, \"head\", html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  appendToBody(html) {\n    if (appendContent(this, \"body\", html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  appendToElementById(id, html) {\n    if (appendContent(this.htmlById, id, html)) {\n      this.maybeMadeChanges = true;\n    }\n  }\n\n  renderIntoElementById(id, html) {\n    this.htmlById[id] = \"\";\n    this.appendToElementById(id, html);\n  }\n\n  redirect(location, code = 301) {\n    this.maybeMadeChanges = true;\n    this.statusCode = code;\n    this.responseHeaders.Location = location;\n  }\n\n  // server only methods\n  setStatusCode(code) {\n    this.maybeMadeChanges = true;\n    this.statusCode = code;\n  }\n\n  setHeader(key, value) {\n    this.maybeMadeChanges = true;\n    this.responseHeaders[key] = value;\n  }\n\n  getHeaders() {\n    return this.request.headers;\n  }\n\n  getCookies() {\n    return this.request.cookies;\n  }\n}\n\nexport function isReadable(stream) {\n  return (\n    stream !== null &&\n    typeof stream === 'object' &&\n    typeof stream.pipe === 'function' &&\n    stream.readable !== false &&\n    typeof stream._read === 'function' &&\n    typeof stream._readableState === 'object'\n  );\n}\n\nfunction appendContent(object, property, content) {\n  let madeChanges = false;\n\n  if (Array.isArray(content)) {\n    content.forEach(elem => {\n      if (appendContent(object, property, elem)) {\n        madeChanges = true;\n      }\n    });\n  } else if (isReadable(content)) {\n    object[property] = content;\n    madeChanges = true;\n  } else if ((content = content && content.toString(\"utf8\"))) {\n    object[property] = (object[property] || \"\") + content;\n    madeChanges = true;\n  } \n  return madeChanges;\n}\n"]}}]