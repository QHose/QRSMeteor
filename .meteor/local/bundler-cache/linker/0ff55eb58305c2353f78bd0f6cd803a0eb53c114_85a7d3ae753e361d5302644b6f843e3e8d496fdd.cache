[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\nvar HTTP = Package.http.HTTP;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"dynamic-import\":{\"client.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/client.js                                           //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nvar Module = module.constructor;\nvar cache = require(\"./cache.js\");\nvar HTTP = require(\"meteor/http\").HTTP;\nvar meteorInstall = require(\"meteor/modules\").meteorInstall;\n\n// Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n};\n\n// Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n  var missing;\n\n  function addSource(id, source) {\n    addToTree(tree, id, makeModuleFunction(id, source, ids[id].options));\n  }\n\n  function addMissing(id) {\n    addToTree(missing = missing || Object.create(null), id, 1);\n  }\n\n  Object.keys(ids).forEach(function (id) {\n    var version = dynamicVersions.get(id);\n    if (version) {\n      versions[id] = version;\n    } else {\n      addMissing(id);\n    }\n  });\n\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n      if (source) {\n        addSource(id, source);\n      } else {\n        addMissing(id);\n      }\n    });\n\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        addSource(id, source);\n\n        var version = dynamicVersions.get(id);\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n\n      cache.setMany(versionsAndSourcesById);\n    });\n\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      \"(\" + source + \")\\n//# sourceURL=\" + id\n    ).apply(this, arguments);\n  };\n}\n\nvar secretKey = null;\nexports.setSecretKey = function (key) {\n  secretKey = key;\n};\n\nvar fetchURL = require(\"./common.js\").fetchURL;\n\nfunction fetchMissing(missingTree) {\n  return new Promise(function (resolve, reject) {\n    // Always match the protocol (http or https) and the domain:port of\n    // the current page.\n    var url = \"//\" + location.host + fetchURL;\n\n    HTTP.call(\"POST\", url, {\n      query: secretKey ? \"key=\" + secretKey : void 0,\n      data: missingTree\n    }, function (error, result) {\n      error ? reject(error) : resolve(result.data);\n    });\n  });\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] ||\n        (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  });\n\n  // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n\n  return namespace;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\n},\"cache.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/cache.js                                            //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar dbPromise;\n\nvar canUseCache =\n  // The server doesn't benefit from dynamic module fetching, and almost\n  // certainly doesn't support IndexedDB.\n  Meteor.isClient &&\n  // Cordova bundles all modules into the monolithic initial bundle, so\n  // the dynamic module cache won't be necessary.\n  ! Meteor.isCordova &&\n  // Caching can be confusing in development, and is designed to be a\n  // transparent optimization for production performance.\n  Meteor.isProduction;\n\nfunction getIDB() {\n  if (typeof indexedDB !== \"undefined\") return indexedDB;\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n}\n\nfunction withDB(callback) {\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {\n    var idb = getIDB();\n    if (! idb) {\n      throw new Error(\"IndexedDB not available\");\n    }\n\n    // Incrementing the version number causes all existing object stores\n    // to be deleted and recreates those specified by objectStoreMap.\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);\n\n    request.onupgradeneeded = function (event) {\n      var db = event.target.result;\n\n      // It's fine to delete existing object stores since onupgradeneeded\n      // is only called when we change the DB version number, and the data\n      // we're storing is disposable/reconstructible.\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);\n\n      Object.keys(objectStoreMap).forEach(function (name) {\n        db.createObjectStore(name, objectStoreMap[name]);\n      });\n    };\n\n    request.onerror = makeOnError(reject, \"indexedDB.open\");\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n  });\n\n  return dbPromise.then(callback, function (error) {\n    return callback(null);\n  });\n}\n\nvar objectStoreMap = {\n  sourcesByVersion: { keyPath: \"version\" }\n};\n\nfunction makeOnError(reject, source) {\n  return function (event) {\n    reject(new Error(\n      \"IndexedDB failure in \" + source + \" \" +\n        JSON.stringify(event.target)\n    ));\n\n    // Returning true from an onerror callback function prevents an\n    // InvalidStateError in Firefox during Private Browsing. Silencing\n    // that error is safe because we handle the error more gracefully by\n    // passing it to the Promise reject function above.\n    // https://github.com/meteor/meteor/issues/8697\n    return true;\n  };\n}\n\nvar checkCount = 0;\n\nexports.checkMany = function (versions) {\n  var ids = Object.keys(versions);\n  var sourcesById = Object.create(null);\n\n  // Initialize sourcesById with null values to indicate all sources are\n  // missing (unless replaced with actual sources below).\n  ids.forEach(function (id) {\n    sourcesById[id] = null;\n  });\n\n  if (! canUseCache) {\n    return Promise.resolve(sourcesById);\n  }\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return sourcesById;\n    }\n\n    var txn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readonly\");\n\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");\n\n    ++checkCount;\n\n    function finish() {\n      --checkCount;\n      return sourcesById;\n    }\n\n    return Promise.all(ids.map(function (id) {\n      return new Promise(function (resolve, reject) {\n        var version = versions[id];\n        if (version) {\n          var sourceRequest = sourcesByVersion.get(version);\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n          sourceRequest.onsuccess = function (event) {\n            var result = event.target.result;\n            if (result) {\n              sourcesById[id] = result.source;\n            }\n            resolve();\n          };\n        } else resolve();\n      });\n    })).then(finish, finish);\n  });\n};\n\nvar pendingVersionsAndSourcesById = Object.create(null);\n\nexports.setMany = function (versionsAndSourcesById) {\n  if (canUseCache) {\n    Object.assign(\n      pendingVersionsAndSourcesById,\n      versionsAndSourcesById\n    );\n\n    // Delay the call to flushSetMany so that it doesn't contribute to the\n    // amount of time it takes to call module.dynamicImport.\n    if (! flushSetMany.timer) {\n      flushSetMany.timer = setTimeout(flushSetMany, 100);\n    }\n  }\n};\n\nfunction flushSetMany() {\n  if (checkCount > 0) {\n    // If checkMany is currently underway, postpone the flush until later,\n    // since updating the cache is less important than reading from it.\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);\n  }\n\n  flushSetMany.timer = null;\n\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;\n  pendingVersionsAndSourcesById = Object.create(null);\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return;\n    }\n\n    var setTxn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readwrite\");\n\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");\n\n    return Promise.all(\n      Object.keys(versionsAndSourcesById).map(function (id) {\n        var info = versionsAndSourcesById[id];\n        return new Promise(function (resolve, reject) {\n          var request = sourcesByVersion.put({\n            version: info.version,\n            source: info.source\n          });\n          request.onerror = makeOnError(reject, \"sourcesByVersion.put\");\n          request.onsuccess = resolve;\n        });\n      })\n    );\n  });\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\n},\"common.js\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/common.js                                           //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nexports.fetchURL = \"/__meteor__/dynamic-import/fetch\";\n\n/////////////////////////////////////////////////////////////////////////////////\n\n},\"dynamic-versions.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/dynamic-import/dynamic-versions.js                                 //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\n// This magic double-underscored identifier gets replaced in\n// tools/isobuild/bundler.js with a tree of hashes of all dynamic\n// modules, for use in client.js and cache.js.\nvar versions = __DYNAMIC_VERSIONS__;\n\nexports.get = function (id) {\n  var tree = versions;\n  var version = null;\n\n  id.split(\"/\").some(function (part) {\n    if (part) {\n      // If the tree contains identifiers for Meteor packages with colons\n      // in their names, the colons should not have been replaced by\n      // underscores, but there's a bug that results in that behavior, so\n      // for now it seems safest to be tolerant of underscores here.\n      // https://github.com/meteor/meteor/pull/9103\n      tree = tree[part] || tree[part.replace(\":\", \"_\")];\n    }\n\n    if (! tree) {\n      // Terminate the search without reassigning version.\n      return true;\n    }\n\n    if (typeof tree === \"string\") {\n      version = tree;\n      return true;\n    }\n  });\n\n  return version;\n};\n\nfunction getFlatModuleArray(tree) {\n  var parts = [\"\"];\n  var result = [];\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result.push(parts.join(\"/\"));\n    }\n  }\n\n  walk(tree);\n\n  return result;\n}\n\n// If Package.appcache is loaded, preload additional modules after the\n// core bundle has been loaded.\nfunction precacheOnLoad(event) {\n  // Check inside onload to make sure Package.appcache has had a chance to\n  // become available.\n  if (! Package.appcache) {\n    return;\n  }\n\n  // Prefetch in chunks to reduce overhead. If we call module.prefetch(id)\n  // multiple times in the same tick of the event loop, all those modules\n  // will be fetched in one HTTP POST request.\n  function prefetchInChunks(modules, amount) {\n    Promise.all(modules.splice(0, amount).map(function (id) {\n      return module.prefetch(id);\n    })).then(function () {\n      if (modules.length > 0) {\n        prefetchInChunks(modules, amount);\n      }\n    });\n  }\n\n  // Get a flat array of modules and start prefetching.\n  prefetchInChunks(getFlatModuleArray(versions), 50);\n}\n\n// Use window.onload to only prefetch after the main bundle has loaded.\nif (global.addEventListener) {\n  global.addEventListener('load', precacheOnLoad, false);\n} else if (global.attachEvent) {\n  global.attachEvent('onload', precacheOnLoad);\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/dynamic-import/client.js\");\n\n/* Exports */\nPackage._define(\"dynamic-import\", exports);\n\n})();\n","servePath":"/packages/dynamic-import.js"}]