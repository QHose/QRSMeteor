[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar humanize, MongoObject, Utility, SimpleSchema, doValidation1, doValidation2, SimpleSchemaValidationContext;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/string-polyfills.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/string-humanize.js                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/*\n  Code source:\n    https://github.com/jxson/string-humanize\n    https://github.com/jxson/string-capitalize\n */\n\nfunction capitalize(string){\n  string = string || '';\n  string = string.trim();\n\n  if (string[0]) {\n    string = string[0].toUpperCase() + string.substr(1).toLowerCase();\n  }\n\n  return string;\n}\n\nhumanize = function humanize(string){\n  string = string || '';\n  string = string.toString(); // might be a number\n  string = string.trim();\n  string = string.replace(extname(string), '');\n  string = underscore(string);\n  string = string.replace(/[\\W_]+/g, ' ');\n\n  return capitalize(string);\n}\n\n\nfunction underscore(string){\n  string = string || '';\n  string = string.toString(); // might be a number\n  string = string.trim();\n  string = string.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2');\n  string = string.replace(/[-\\s]+/g, '_').toLowerCase();\n\n  return string;\n}\n\nfunction extname(string){\n  var index = string.lastIndexOf('.');\n  var ext = string.substring(index, string.length);\n\n  return (index === -1) ? '' : ext;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/mongo-object.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global MongoObject:true */\n\n\nvar isObject = function(obj) {\n  return obj === Object(obj);\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n/* Takes a specific string that uses mongo-style dot notation\n * and returns a generic string equivalent. Replaces all numeric\n * \"pieces\" with a dollar sign ($).\n *\n * @param {type} name\n * @returns {unresolved}\n */\nvar makeGeneric = function makeGeneric(name) {\n  if (typeof name !== \"string\") {\n    return null;\n  }\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+$/g, '.$');\n};\n\nvar appendAffectedKey = function appendAffectedKey(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};\n\n// Extracts operator piece, if present, from position string\nvar extractOp = function extractOp(position) {\n  var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n  return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n};\n\n/*\n * @constructor\n * @param {Object} objOrModifier\n * @param {string[]} blackBoxKeys - A list of the names of keys that shouldn't be traversed\n * @returns {undefined}\n *\n * Creates a new MongoObject instance. The object passed as the first argument\n * will be modified in place by calls to instance methods. Also, immediately\n * upon creation of the instance, the object will have any `undefined` keys\n * removed recursively.\n */\nMongoObject = function(objOrModifier, blackBoxKeys) {\n  var self = this;\n  self._obj = objOrModifier;\n  self._affectedKeys = {};\n  self._genericAffectedKeys = {};\n  self._parentPositions = [];\n  self._positionsInsideArrays = [];\n  self._objectPositions = [];\n\n  function parseObj(val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\n\n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    var affectedKeyIsBlackBox = false;\n    var affectedKeyGeneric;\n    var stop = false;\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet and $pull and $pop\n      if (!adjusted) {\n        if (operator === \"$push\" || operator === \"$addToSet\" || operator === \"$pop\") {\n          // Adjust for $each\n          // We can simply jump forward and pretend like the $each array\n          // is the array for the field. This has the added benefit of\n          // skipping past any $slice, which we also don't care about.\n          if (isBasicObject(val) && \"$each\" in val) {\n            val = val.$each;\n            currentPosition = currentPosition + \"[$each]\";\n          } else {\n            affectedKey = affectedKey + \".0\";\n          }\n          adjusted = true;\n        } else if (operator === \"$pull\") {\n          affectedKey = affectedKey + \".0\";\n          if (isBasicObject(val)) {\n            stop = true;\n          }\n          adjusted = true;\n        }\n      }\n\n      // Make generic key\n      affectedKeyGeneric = makeGeneric(affectedKey);\n\n      // Determine whether affected key should be treated as a black box\n      affectedKeyIsBlackBox = _.contains(blackBoxKeys, affectedKeyGeneric);\n\n      // Mark that this position affects this generic and non-generic key\n      if (currentPosition) {\n        self._affectedKeys[currentPosition] = affectedKey;\n        self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\n\n        // If we're within an array, mark this position so we can omit it from flat docs\n        isWithinArray && self._positionsInsideArrays.push(currentPosition);\n      }\n    }\n\n    if (stop) {\n      return;\n    }\n\n    // Loop through arrays\n    if (_.isArray(val) && !_.isEmpty(val)) {\n      if (currentPosition) {\n        // Mark positions with arrays that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n      }\n\n      // Loop\n      _.each(val, function(v, i) {\n        parseObj(v, (currentPosition ? currentPosition + \"[\" + i + \"]\" : i), affectedKey + '.' + i, operator, adjusted, true);\n      });\n    }\n\n    // Loop through object keys, only for basic objects,\n    // but always for the passed-in object, even if it\n    // is a custom object.\n    else if ((isBasicObject(val) && !affectedKeyIsBlackBox) || !currentPosition) {\n      if (currentPosition && !_.isEmpty(val)) {\n        // Mark positions with objects that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n        // Mark positions with objects that should be left out of flat docs.\n        self._objectPositions.push(currentPosition);\n      }\n      // Loop\n      _.each(val, function(v, k) {\n        if (v === void 0) {\n          delete val[k];\n        } else if (k !== \"$slice\") {\n          parseObj(v, (currentPosition ? currentPosition + \"[\" + k + \"]\" : k), appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\n        }\n      });\n    }\n\n  }\n  parseObj(self._obj);\n\n  function reParseObj() {\n    self._affectedKeys = {};\n    self._genericAffectedKeys = {};\n    self._parentPositions = [];\n    self._positionsInsideArrays = [];\n    self._objectPositions = [];\n    parseObj(self._obj);\n  }\n\n  /**\n   * @method MongoObject.forEachNode\n   * @param {Function} func\n   * @param {Object} [options]\n   * @param {Boolean} [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n   * @returns {undefined}\n   *\n   * Runs a function for each endpoint node in the object tree, including all items in every array.\n   * The function arguments are\n   * (1) the value at this node\n   * (2) a string representing the node position\n   * (3) the representation of what would be changed in mongo, using mongo dot notation\n   * (4) the generic equivalent of argument 3, with \"$\" instead of numeric pieces\n   */\n  self.forEachNode = function(func, options) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"filter requires a loop function\");\n    }\n\n    options = _.extend({\n      endPointsOnly: true\n    }, options);\n\n    var updatedValues = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (options.endPointsOnly && _.contains(self._parentPositions, position)) {\n        return; //only endpoints\n      }\n      func.call({\n        value: self.getValueForPosition(position),\n        operator: extractOp(position),\n        position: position,\n        key: affectedKey,\n        genericKey: self._genericAffectedKeys[position],\n        updateValue: function(newVal) {\n          updatedValues[position] = newVal;\n        },\n        remove: function() {\n          updatedValues[position] = void 0;\n        }\n      });\n    });\n\n    // Actually update/remove values as instructed\n    _.each(updatedValues, function(newVal, position) {\n      self.setValueForPosition(position, newVal);\n    });\n\n  };\n\n  self.getValueForPosition = function(position) {\n    var subkey, subkeys = position.split(\"[\"), current = self._obj;\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      current = current[subkey];\n      if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n        return;\n      }\n    }\n    return current;\n  };\n\n  /**\n   * @method MongoObject.prototype.setValueForPosition\n   * @param {String} position\n   * @param {Any} value\n   * @returns {undefined}\n   */\n  self.setValueForPosition = function(position, value) {\n    var nextPiece, subkey, subkeys = position.split(\"[\"), current = self._obj;\n\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      // If we've reached the key in the object tree that needs setting or\n      // deleting, do it.\n      if (i === ln - 1) {\n        current[subkey] = value;\n        //if value is undefined, delete the property\n        if (value === void 0) {\n          delete current[subkey];\n        }\n      }\n      // Otherwise attempt to keep moving deeper into the object.\n      else {\n        // If we're setting (as opposed to deleting) a key and we hit a place\n        // in the ancestor chain where the keys are not yet created, create them.\n        if (current[subkey] === void 0 && value !== void 0) {\n          //see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          current[subkey] = isNaN(nextPiece) ? {} : [];\n        }\n\n        // Move deeper into the object\n        current = current[subkey];\n\n        // If we can go no further, then quit\n        if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n          return;\n        }\n      }\n    }\n\n    reParseObj();\n  };\n\n  /**\n   * @method MongoObject.prototype.removeValueForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.removeValueForPosition = function(position) {\n    self.setValueForPosition(position, void 0);\n  };\n\n  /**\n   * @method MongoObject.prototype.getKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getKeyForPosition = function(position) {\n    return self._affectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.prototype.getGenericKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getGenericKeyForPosition = function(position) {\n    return self._genericAffectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.getInfoForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Object}\n   *\n   * Returns the value and operator of the requested non-generic key.\n   * Example: {value: 1, operator: \"$pull\"}\n   */\n  self.getInfoForKey = function(key) {\n    // Get the info\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return {\n        value: self.getValueForPosition(position),\n        operator: extractOp(position)\n      };\n    }\n\n    // If we haven't returned yet, check to see if there is an array value\n    // corresponding to this key\n    // We find the first item within the array, strip the last piece off the\n    // position string, and then return whatever is at that new position in\n    // the original object.\n    var positions = self.getPositionsForGenericKey(key + \".$\"), p, v;\n    for (var i = 0, ln = positions.length; i < ln; i++) {\n      p = positions[i];\n      v = self.getValueForPosition(p) || self.getValueForPosition(p.slice(0, p.lastIndexOf(\"[\")));\n      if (v) {\n        return {\n          value: v,\n          operator: extractOp(p)\n        };\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getPositionForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|String} Position string\n   *\n   * Returns the position string for the place in the object that\n   * affects the requested non-generic key.\n   * Example: 'foo[bar][0]'\n   */\n  self.getPositionForKey = function(key) {\n    // Get the info\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same non-generic key, we'll assume that's not the case.\n          return position;\n        }\n      }\n    }\n\n    // If we haven't returned yet, we need to check for affected keys\n  };\n\n  /**\n   * @method MongoObject.getPositionsForGenericKey\n   * @param {String} key - Generic key\n   * @returns {String[]} Array of position strings\n   *\n   * Returns an array of position strings for the places in the object that\n   * affect the requested generic key.\n   * Example: ['foo[bar][0]']\n   */\n  self.getPositionsForGenericKey = function(key) {\n    // Get the info\n    var list = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          list.push(position);\n        }\n      }\n    }\n\n    return list;\n  };\n\n  /**\n   * @deprecated Use getInfoForKey\n   * @method MongoObject.getValueForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Any}\n   *\n   * Returns the value of the requested non-generic key\n   */\n  self.getValueForKey = function(key) {\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return self.getValueForPosition(position);\n    }\n  };\n\n  /**\n   * @method MongoObject.prototype.addKey\n   * @param {String} key - Key to set\n   * @param {Any} val - Value to give this key\n   * @param {String} op - Operator under which to set it, or `null` for a non-modifier object\n   * @returns {undefined}\n   *\n   * Adds `key` with value `val` under operator `op` to the source object.\n   */\n  self.addKey = function(key, val, op) {\n    var position = op ? op + \"[\" + key + \"]\" : MongoObject._keyToPosition(key);\n    self.setValueForPosition(position, val);\n  };\n\n  /**\n   * @method MongoObject.prototype.removeGenericKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the generic keys in the list\n   */\n  self.removeGenericKeys = function(keys) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (_.contains(keys, self._genericAffectedKeys[position])) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeGenericKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested generic key\n   */\n  self.removeGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested non-generic key\n   */\n  self.removeKey = function(key) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // remove for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the non-generic keys in the list\n   */\n  self.removeKeys = function(keys) {\n    for (var i = 0, ln = keys.length; i < ln; i++) {\n      self.removeKey(keys[i]);\n    }\n  };\n\n  /**\n   * @method MongoObject.filterGenericKeys\n   * @param {Function} test - Test function\n   * @returns {undefined}\n   *\n   * Passes all affected keys to a test function, which\n   * should return false to remove whatever is affecting that key\n   */\n  self.filterGenericKeys = function(test) {\n    var gk, checkedKeys = [], keysToRemove = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        gk = self._genericAffectedKeys[position];\n        if (!_.contains(checkedKeys, gk)) {\n          checkedKeys.push(gk);\n          if (gk && !test(gk)) {\n            keysToRemove.push(gk);\n          }\n        }\n      }\n    }\n\n    _.each(keysToRemove, function(key) {\n      self.removeGenericKey(key);\n    });\n  };\n\n  /**\n   * @method MongoObject.setValueForKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested non-generic key\n   */\n  self.setValueForKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.setValueForGenericKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested generic key\n   */\n  self.setValueForGenericKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getObject\n   * @returns {Object}\n   *\n   * Get the source object, potentially modified by other method calls on this\n   * MongoObject instance.\n   */\n  self.getObject = function() {\n    return self._obj;\n  };\n\n  /**\n   * @method MongoObject.getFlatObject\n   * @returns {Object}\n   *\n   * Gets a flat object based on the MongoObject instance.\n   * In a flat object, the key is the name of the non-generic affectedKey,\n   * with mongo dot notation if necessary, and the value is the value for\n   * that key.\n   *\n   * With `keepArrays: true`, we don't flatten within arrays. Currently\n   * MongoDB does not see a key such as `a.0.b` and automatically assume\n   * an array. Instead it would create an object with key \"0\" if there\n   * wasn't already an array saved as the value of `a`, which is rarely\n   * if ever what we actually want. To avoid this confusion, we\n   * set entire arrays.\n   */\n  self.getFlatObject = function(options) {\n    options = options || {};\n    var newObj = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (typeof affectedKey === \"string\" &&\n        (options.keepArrays === true && !_.contains(self._positionsInsideArrays, position) && !_.contains(self._objectPositions, position)) ||\n        (!options.keepArrays && !_.contains(self._parentPositions, position))\n        ) {\n        newObj[affectedKey] = self.getValueForPosition(position);\n      }\n    });\n    return newObj;\n  };\n\n  /**\n   * @method MongoObject.affectsKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the non-generic key is affected by this object\n   */\n  self.affectsKey = function(key) {\n    return !!self.getPositionForKey(key);\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the generic key is affected by this object\n   */\n  self.affectsGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKeyImplicit\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Like affectsGenericKey, but will return true if a child key is affected\n   */\n  self.affectsGenericKeyImplicit = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        var affectedKey = self._genericAffectedKeys[position];\n\n        // If the affected key is the test key\n        if (affectedKey === key) {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key followed by a period\n        if (affectedKey.substring(0, key.length + 1) === key + \".\") {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key and the test key ends with \".$\"\n        var lastTwo = key.slice(-2);\n        if (lastTwo === \".$\" && key.slice(0, -2) === affectedKey) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n */\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n *\n * @param {any} val\n * @param {String} key\n * @param {Object} obj\n * @returns {undefined}\n */\nMongoObject.expandKey = function(val, key, obj) {\n  var nextPiece, subkey, subkeys = key.split(\"[\"), current = obj;\n  for (var i = 0, ln = subkeys.length; i < ln; i++) {\n    subkey = subkeys[i];\n    if (subkey.slice(-1) === \"]\") {\n      subkey = subkey.slice(0, -1);\n    }\n    if (i === ln - 1) {\n      //last iteration; time to set the value; always overwrite\n      current[subkey] = val;\n      //if val is undefined, delete the property\n      if (val === void 0) {\n        delete current[subkey];\n      }\n    } else {\n      //see if the next piece is a number\n      nextPiece = subkeys[i + 1];\n      nextPiece = parseInt(nextPiece, 10);\n      if (!current[subkey]) {\n        current[subkey] = isNaN(nextPiece) ? {} : [];\n      }\n    }\n    current = current[subkey];\n  }\n};\n\nMongoObject._keyToPosition = function keyToPosition(key, wrapAll) {\n  var position = '';\n  _.each(key.split(\".\"), function (piece, i) {\n    if (i === 0 && !wrapAll) {\n      position += piece;\n    } else {\n      position += \"[\" + piece + \"]\";\n    }\n  });\n  return position;\n};\n\n/**\n * @method MongoObject._positionToKey\n * @param {String} position\n * @returns {String} The key that this position in an object would affect.\n *\n * This is different from MongoObject.prototype.getKeyForPosition in that\n * this method does not depend on the requested position actually being\n * present in any particular MongoObject.\n */\nMongoObject._positionToKey = function positionToKey(position) {\n  //XXX Probably a better way to do this, but this is\n  //foolproof for now.\n  var mDoc = new MongoObject({});\n  mDoc.setValueForPosition(position, 1); //value doesn't matter\n  var key = mDoc.getKeyForPosition(position);\n  mDoc = null;\n  return key;\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-utility.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility:true */\n\nUtility = {\n  appendAffectedKey: function appendAffectedKey(affectedKey, key) {\n    if (key === \"$each\") {\n      return affectedKey;\n    } else {\n      return (affectedKey ? affectedKey + \".\" + key : key);\n    }\n  },\n  shouldCheck: function shouldCheck(key) {\n    if (key === \"$pushAll\") {\n      throw new Error(\"$pushAll is not supported; use $push + $each\");\n    }\n    return !_.contains([\"$pull\", \"$pullAll\", \"$pop\", \"$slice\"], key);\n  },\n  errorObject: function errorObject(errorType, keyName, keyValue) {\n    return {name: keyName, type: errorType, value: keyValue};\n  },\n  // Tests whether it's an Object as opposed to something that inherits from Object\n  isBasicObject: function isBasicObject(obj) {\n    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n  },\n  // The latest Safari returns false for Uint8Array, etc. instanceof Function\n  // unlike other browsers.\n  safariBugFix: function safariBugFix(type) {\n    return (typeof Uint8Array !== \"undefined\" && type === Uint8Array) ||\n      (typeof Uint16Array !== \"undefined\" && type === Uint16Array) ||\n      (typeof Uint32Array !== \"undefined\" && type === Uint32Array) ||\n      (typeof Uint8ClampedArray !== \"undefined\" && type === Uint8ClampedArray);\n  },\n  isNotNullOrUndefined: function isNotNullOrUndefined(val) {\n    return val !== void 0 && val !== null;\n  },\n  // Extracts operator piece, if present, from position string\n  extractOp: function extractOp(position) {\n    var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n    return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n  },\n  deleteIfPresent: function deleteIfPresent(obj, key) {\n    if (key in obj) {\n      delete obj[key];\n    }\n  },\n  looksLikeModifier: function looksLikeModifier(obj) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n        return true;\n      }\n    }\n    return false;\n  },\n  dateToDateString: function dateToDateString(date) {\n    var m = (date.getUTCMonth() + 1);\n    if (m < 10) {\n      m = \"0\" + m;\n    }\n    var d = date.getUTCDate();\n    if (d < 10) {\n      d = \"0\" + d;\n    }\n    return date.getUTCFullYear() + '-' + m + '-' + d;\n  }\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema.js                                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global SimpleSchema:true */\n/* global SimpleSchemaValidationContext */\n/* global MongoObject */\n/* global Utility */\n\nvar schemaDefinition = {\n  type: Match.Any,\n  label: Match.Optional(Match.OneOf(String, Function)),\n  optional: Match.Optional(Match.OneOf(Boolean, Function)),\n  min: Match.Optional(Match.OneOf(Number, Date, Function)),\n  max: Match.Optional(Match.OneOf(Number, Date, Function)),\n  minCount: Match.Optional(Match.OneOf(Number, Function)),\n  maxCount: Match.Optional(Match.OneOf(Number, Function)),\n  allowedValues: Match.Optional(Match.OneOf([Match.Any], Function)),\n  decimal: Match.Optional(Boolean),\n  exclusiveMax: Match.Optional(Boolean),\n  exclusiveMin: Match.Optional(Boolean),\n  regEx: Match.Optional(Match.OneOf(RegExp, [RegExp])),\n  custom: Match.Optional(Function),\n  blackbox: Match.Optional(Boolean),\n  autoValue: Match.Optional(Function),\n  defaultValue: Match.Optional(Match.Any),\n  trim: Match.Optional(Boolean)\n};\n\n/*\n * PRIVATE FUNCTIONS\n */\n\n//called by clean()\nvar typeconvert = function(value, type) {\n  var parsedDate;\n\n  if (_.isArray(value) || (_.isObject(value) && !(value instanceof Date))) {\n    return value; //can't and shouldn't convert arrays or objects\n  }\n  if (type === String) {\n    if (typeof value !== \"undefined\" && value !== null && typeof value !== \"string\") {\n      return value.toString();\n    }\n    return value;\n  }\n  if (type === Number) {\n    if (typeof value === \"string\" && !_.isEmpty(value)) {\n      //try to convert numeric strings to numbers\n      var numberVal = Number(value);\n      if (!isNaN(numberVal)) {\n        return numberVal;\n      } else {\n        return value; //leave string; will fail validation\n      }\n    }\n    return value;\n  }\n  //\n  // If target type is a Date we can safely convert from either a\n  // number (Integer value representing the number of milliseconds\n  // since 1 January 1970 00:00:00 UTC) or a string that can be parsed\n  // by Date.\n  //\n  if (type === Date) {\n    if (typeof value === \"string\") {\n      parsedDate = Date.parse(value);\n      if (isNaN(parsedDate) === false) {\n        return new Date(parsedDate);\n      }\n    }\n    if (typeof value === \"number\") {\n      return new Date(value);\n    }\n  }\n  return value;\n};\n\nvar expandSchema = function(schema) {\n  // Flatten schema by inserting nested definitions\n  _.each(schema, function(val, key) {\n    var dot, type;\n    if (!val) {\n      return;\n    }\n    if (Match.test(val.type, SimpleSchema)) {\n      dot = '.';\n      type = val.type;\n      val.type = Object;\n    } else if (Match.test(val.type, [SimpleSchema])) {\n      dot = '.$.';\n      type = val.type[0];\n      val.type = [Object];\n    } else {\n      return;\n    }\n    //add child schema definitions to parent schema\n    _.each(type._schema, function(subVal, subKey) {\n      var newKey = key + dot + subKey;\n      if (!(newKey in schema)) {\n        schema[newKey] = subVal;\n      }\n    });\n  });\n  return schema;\n};\n\nvar adjustArrayFields = function(schema) {\n  _.each(schema, function(def, existingKey) {\n    if (_.isArray(def.type) || def.type === Array) {\n      // Copy some options to array-item definition\n      var itemKey = existingKey + \".$\";\n      if (!(itemKey in schema)) {\n        schema[itemKey] = {};\n      }\n      if (_.isArray(def.type)) {\n        schema[itemKey].type = def.type[0];\n      }\n      if (def.label) {\n        schema[itemKey].label = def.label;\n      }\n      schema[itemKey].optional = true;\n      if (typeof def.min !== \"undefined\") {\n        schema[itemKey].min = def.min;\n      }\n      if (typeof def.max !== \"undefined\") {\n        schema[itemKey].max = def.max;\n      }\n      if (typeof def.allowedValues !== \"undefined\") {\n        schema[itemKey].allowedValues = def.allowedValues;\n      }\n      if (typeof def.decimal !== \"undefined\") {\n        schema[itemKey].decimal = def.decimal;\n      }\n      if (typeof def.exclusiveMax !== \"undefined\") {\n        schema[itemKey].exclusiveMax = def.exclusiveMax;\n      }\n      if (typeof def.exclusiveMin !== \"undefined\") {\n        schema[itemKey].exclusiveMin = def.exclusiveMin;\n      }\n      if (typeof def.regEx !== \"undefined\") {\n        schema[itemKey].regEx = def.regEx;\n      }\n      if (typeof def.blackbox !== \"undefined\") {\n        schema[itemKey].blackbox = def.blackbox;\n      }\n      // Remove copied options and adjust type\n      def.type = Array;\n      _.each(['min', 'max', 'allowedValues', 'decimal', 'exclusiveMax', 'exclusiveMin', 'regEx', 'blackbox'], function(k) {\n        Utility.deleteIfPresent(def, k);\n      });\n    }\n  });\n};\n\n/**\n * Adds implied keys.\n * * If schema contains a key like \"foo.$.bar\" but not \"foo\", adds \"foo\".\n * * If schema contains a key like \"foo\" with an array type, adds \"foo.$\".\n * @param {Object} schema\n * @returns {Object} modified schema\n */\nvar addImplicitKeys = function(schema) {\n  var arrayKeysToAdd = [], objectKeysToAdd = [], newKey, key, i, ln;\n\n  // Pass 1 (objects)\n  _.each(schema, function(def, existingKey) {\n    var pos = existingKey.indexOf(\".\");\n    while (pos !== -1) {\n      newKey = existingKey.substring(0, pos);\n\n      // It's an array item; nothing to add\n      if (newKey.substring(newKey.length - 2) === \".$\") {\n        pos = -1;\n      }\n      // It's an array of objects; add it with type [Object] if not already in the schema\n      else if (existingKey.substring(pos, pos + 3) === \".$.\") {\n        arrayKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 3); // skip over next dot, find the one after\n      }\n      // It's an object; add it with type Object if not already in the schema\n      else {\n        objectKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 1); // find next dot\n      }\n    }\n  });\n\n  for (i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {\n    key = arrayKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: [Object], optional: true};\n    }\n  }\n\n  for (i = 0, ln = objectKeysToAdd.length; i < ln; i++) {\n    key = objectKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: Object, optional: true};\n    }\n  }\n\n  // Pass 2 (arrays)\n  adjustArrayFields(schema);\n\n  return schema;\n};\n\nvar mergeSchemas = function(schemas) {\n\n  // Merge all provided schema definitions.\n  // This is effectively a shallow clone of each object, too,\n  // which is what we want since we are going to manipulate it.\n  var mergedSchema = {};\n  _.each(schemas, function(schema) {\n\n    // Create a temporary SS instance so that the internal object\n    // we use for merging/extending will be fully expanded\n    if (Match.test(schema, SimpleSchema)) {\n      schema = schema._schema;\n    } else {\n      schema = addImplicitKeys(expandSchema(schema));\n    }\n\n    // Loop through and extend each individual field\n    // definition. That way you can extend and overwrite\n    // base field definitions.\n    _.each(schema, function(def, field) {\n      mergedSchema[field] = mergedSchema[field] || {};\n      _.extend(mergedSchema[field], def);\n    });\n\n  });\n\n  // If we merged some schemas, do this again to make sure\n  // extended definitions are pushed into array item field\n  // definitions properly.\n  schemas.length && adjustArrayFields(mergedSchema);\n\n  return mergedSchema;\n};\n\n// Returns an object relating the keys in the list\n// to their parent object.\nvar getObjectKeys = function(schema, schemaKeyList) {\n  var keyPrefix, remainingText, rKeys = {}, loopArray;\n  _.each(schema, function(definition, fieldName) {\n    if (definition.type === Object) {\n      //object\n      keyPrefix = fieldName + \".\";\n    } else {\n      return;\n    }\n\n    loopArray = [];\n    _.each(schemaKeyList, function(fieldName2) {\n      if (fieldName2.startsWith(keyPrefix)) {\n        remainingText = fieldName2.substring(keyPrefix.length);\n        if (remainingText.indexOf(\".\") === -1) {\n          loopArray.push(remainingText);\n        }\n      }\n    });\n    rKeys[keyPrefix] = loopArray;\n  });\n  return rKeys;\n};\n\n// returns an inflected version of fieldName to use as the label\nvar inflectedLabel = function(fieldName) {\n  var label = fieldName, lastPeriod = label.lastIndexOf(\".\");\n  if (lastPeriod !== -1) {\n    label = label.substring(lastPeriod + 1);\n    if (label === \"$\") {\n      var pcs = fieldName.split(\".\");\n      label = pcs[pcs.length - 2];\n    }\n  }\n  if (label === \"_id\") {\n    return \"ID\";\n  }\n  return humanize(label);\n};\n\n/**\n * @method getAutoValues\n * @private\n * @param {MongoObject} mDoc\n * @param {Boolean} [isModifier=false] - Is it a modifier doc?\n * @param {Object} [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\n * @returns {undefined}\n *\n * Updates doc with automatic values from autoValue functions or default\n * values from defaultValue. Modifies the referenced object in place.\n */\nfunction getAutoValues(mDoc, isModifier, extendedAutoValueContext) {\n  var self = this;\n  var doneKeys = [];\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && extendedAutoValueContext.userId === void 0) {\n    extendedAutoValueContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  function runAV(func) {\n    var affectedKey = this.key;\n    // If already called for this key, skip it\n    if (_.contains(doneKeys, affectedKey)) {\n      return;\n    }\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var doUnset = false;\n    var autoValue = func.call(_.extend({\n      isSet: (this.value !== void 0),\n      unset: function() {\n        doUnset = true;\n      },\n      value: this.value,\n      operator: this.operator,\n      field: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      },\n      siblingField: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      }\n    }, extendedAutoValueContext || {}), mDoc.getObject());\n\n    // Update tracking of which keys we've run autovalue for\n    doneKeys.push(affectedKey);\n\n    if (autoValue === void 0) {\n      if (doUnset) {\n        mDoc.removeValueForPosition(this.position);\n      }\n      return;\n    }\n\n    // If the user's auto value is of the pseudo-modifier format, parse it\n    // into operator and value.\n    var op, newValue;\n    if (_.isObject(autoValue)) {\n      for (var key in autoValue) {\n        if (autoValue.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n          op = key;\n          newValue = autoValue[key];\n          break;\n        }\n      }\n    }\n\n    // Add $set for updates and upserts if necessary\n    if (!op && isModifier && this.position.slice(0, 1) !== '$') {\n      op = \"$set\";\n      newValue = autoValue;\n    }\n\n    // Update/change value\n    if (op) {\n      mDoc.removeValueForPosition(this.position);\n      mDoc.setValueForPosition(op + '[' + affectedKey + ']', newValue);\n    } else {\n      mDoc.setValueForPosition(this.position, autoValue);\n    }\n  }\n\n  _.each(self._autoValues, function(func, fieldName) {\n    var positionSuffix, key, keySuffix, positions;\n\n    // If we're under an array, run autovalue for all the properties of\n    // any objects that are present in the nearest ancestor array.\n    if (fieldName.indexOf(\"$\") !== -1) {\n      var testField = fieldName.slice(0, fieldName.lastIndexOf(\"$\") + 1);\n      keySuffix = fieldName.slice(testField.length + 1);\n      positionSuffix = MongoObject._keyToPosition(keySuffix, true);\n      keySuffix = '.' + keySuffix;\n      positions = mDoc.getPositionsForGenericKey(testField);\n    } else {\n\n      // See if anything in the object affects this key\n      positions = mDoc.getPositionsForGenericKey(fieldName);\n\n      // Run autovalue for properties that are set in the object\n      if (positions.length) {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n      }\n\n      // Run autovalue for properties that are NOT set in the object\n      else {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n        if (isModifier) {\n          positions = [\"$set[\" + fieldName + \"]\"];\n        } else {\n          positions = [MongoObject._keyToPosition(fieldName)];\n        }\n      }\n\n    }\n\n    _.each(positions, function(position) {\n      runAV.call({\n        key: (key || MongoObject._positionToKey(position)) + keySuffix,\n        value: mDoc.getValueForPosition(position + positionSuffix),\n        operator: Utility.extractOp(position),\n        position: position + positionSuffix\n      }, func);\n    });\n  });\n}\n\n//exported\nSimpleSchema = function(schemas, options) {\n  var self = this;\n  var firstLevelSchemaKeys = [];\n  var fieldNameRoot;\n  options = options || {};\n  schemas = schemas || {};\n\n  if (!_.isArray(schemas)) {\n    schemas = [schemas];\n  }\n\n  // adjust and store a copy of the schema definitions\n  self._schema = mergeSchemas(schemas);\n\n  // store the list of defined keys for speedier checking\n  self._schemaKeys = [];\n\n  // store autoValue functions by key\n  self._autoValues = {};\n\n  // store the list of blackbox keys for passing to MongoObject constructor\n  self._blackboxKeys = [];\n\n  // a place to store custom validators for this instance\n  self._validators = [];\n\n  // a place to store custom error messages for this schema\n  self._messages = {};\n\n  self._depsMessages = new Tracker.Dependency();\n  self._depsLabels = {};\n\n  _.each(self._schema, function(definition, fieldName) {\n    // Validate the field definition\n    if (!Match.test(definition, schemaDefinition)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field.');\n    }\n\n    fieldNameRoot = fieldName.split(\".\")[0];\n\n    self._schemaKeys.push(fieldName);\n\n    // We support defaultValue shortcut by converting it immediately into an\n    // autoValue.\n    if ('defaultValue' in definition) {\n      if ('autoValue' in definition) {\n        console.warn('SimpleSchema: Found both autoValue and defaultValue options for \"' + fieldName + '\". Ignoring defaultValue.');\n      } else {\n        if (fieldName.slice(-2) === \".$\") {\n          throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n        }\n        self._autoValues[fieldName] = (function defineAutoValue(v) {\n          return function() {\n            if (this.operator === null && !this.isSet) {\n              return v;\n            }\n          };\n        })(definition.defaultValue);\n      }\n    }\n\n    if ('autoValue' in definition) {\n      if (fieldName.slice(-2) === \".$\") {\n        throw new Error('An array item field (one that ends with \".$\") cannot have autoValue.');\n      }\n      self._autoValues[fieldName] = definition.autoValue;\n    }\n\n    self._depsLabels[fieldName] = new Tracker.Dependency();\n\n    if (definition.blackbox === true) {\n      self._blackboxKeys.push(fieldName);\n    }\n\n    if (!_.contains(firstLevelSchemaKeys, fieldNameRoot)) {\n      firstLevelSchemaKeys.push(fieldNameRoot);\n    }\n  });\n\n\n  // Cache these lists\n  self._firstLevelSchemaKeys = firstLevelSchemaKeys;\n  self._objectKeys = getObjectKeys(self._schema, self._schemaKeys);\n\n  // We will store named validation contexts here\n  self._validationContexts = {};\n};\n\n// This allows other packages or users to extend the schema\n// definition options that are supported.\nSimpleSchema.extendOptions = function(options) {\n  _.extend(schemaDefinition, options);\n};\n\n// this domain regex matches all domains that have at least one .\n// sadly IPv4 Adresses will be caught too but technically those are valid domains\n// this expression is extracted from the original RFC 5322 mail expression\n// a modification enforces that the tld consists only of characters\nvar RX_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z](?:[a-z-]*[a-z])?';\n// this domain regex matches everythign that could be a domain in intranet\n// that means \"localhost\" is a valid domain\nvar RX_NAME_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\\\.|$))+';\n// strict IPv4 expression which allows 0-255 per oktett\nvar RX_IPv4 = '(?:(?:[0-1]?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])(?:\\\\.|$)){4}';\n// strict IPv6 expression which allows (and validates) all shortcuts\nvar RX_IPv6 = '(?:(?:[\\\\dA-Fa-f]{1,4}(?::|$)){8}' // full adress\n  + '|(?=(?:[^:\\\\s]|:[^:\\\\s])*::(?:[^:\\\\s]|:[^:\\\\s])*$)' // or min/max one '::'\n  + '[\\\\dA-Fa-f]{0,4}(?:::?(?:[\\\\dA-Fa-f]{1,4}|$)){1,6})'; // and short adress\n// this allows domains (also localhost etc) and ip adresses\nvar RX_WEAK_DOMAIN = '(?:' + [RX_NAME_DOMAIN,RX_IPv4,RX_IPv6].join('|') + ')';\n\nSimpleSchema.RegEx = {\n  // We use the RegExp suggested by W3C in http://www.w3.org/TR/html5/forms.html#valid-e-mail-address\n  // This is probably the same logic used by most browsers when type=email, which is our goal. It is\n  // a very permissive expression. Some apps may wish to be more strict and can write their own RegExp.\n  Email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n\n  Domain: new RegExp('^' + RX_DOMAIN + '$'),\n  WeakDomain: new RegExp('^' + RX_WEAK_DOMAIN + '$'),\n\n  IP: new RegExp('^(?:' + RX_IPv4 + '|' + RX_IPv6 + ')$'),\n  IPv4: new RegExp('^' + RX_IPv4 + '$'),\n  IPv6: new RegExp('^' + RX_IPv6 + '$'),\n  // URL RegEx from https://gist.github.com/dperini/729294\n  // http://mathiasbynens.be/demo/url-regex\n  Url: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i,\n  // unique id from the random package also used by minimongo\n  // character list: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L88\n  // string length: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L143\n  Id: /^[23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz]{17}$/,\n  // allows for a 5 digit zip code followed by a whitespace or dash and then 4 more digits\n  // matches 11111 and 11111-1111 and 11111 1111\n  ZipCode: /^\\d{5}(?:[-\\s]\\d{4})?$/,\n  // taken from google's libphonenumber library\n  // https://github.com/googlei18n/libphonenumber/blob/master/javascript/i18n/phonenumbers/phonenumberutil.js\n  // reference the VALID_PHONE_NUMBER_PATTERN key\n  // allows for common phone number symbols including + () and -\n  Phone: /^[0-9０-９٠-٩۰-۹]{2}$|^[+＋]*(?:[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～*]*[0-9０-９٠-٩۰-۹]){3,}[-x‐-―−ー－-／  ­​⁠　()（）［］.\\[\\]/~⁓∼～0-9０-９٠-٩۰-۹]*(?:;ext=([0-9０-９٠-٩۰-۹]{1,7})|[  \\t,]*(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|[,xｘ#＃~～]|int|anexo|ｉｎｔ)[:\\.．]?[  \\t,-]*([0-9０-９٠-٩۰-۹]{1,7})#?|[- ]+([0-9０-９٠-٩۰-۹]{1,5})#)?$/i\n};\n\nSimpleSchema._makeGeneric = function(name) {\n  if (typeof name !== \"string\") {\n    return null;\n  }\n\n  return name.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n};\n\nSimpleSchema._depsGlobalMessages = new Tracker.Dependency();\n\n// Inherit from Match.Where\n// This allow SimpleSchema instance to be recognized as a Match.Where instance as well\n// as a SimpleSchema instance\nSimpleSchema.prototype = new Match.Where();\n\n// If an object is an instance of Match.Where, Meteor built-in check API will look at\n// the function named `condition` and will pass it the document to validate\nSimpleSchema.prototype.condition = function(obj) {\n  var self = this;\n\n  //determine whether obj is a modifier\n  var isModifier, isNotModifier;\n  _.each(obj, function(val, key) {\n    if (key.substring(0, 1) === \"$\") {\n      isModifier = true;\n    } else {\n      isNotModifier = true;\n    }\n  });\n\n  if (isModifier && isNotModifier) {\n    throw new Match.Error(\"Object cannot contain modifier operators alongside other keys\");\n  }\n\n  var ctx = self.newContext();\n  if (!ctx.validate(obj, {modifier: isModifier, filter: false, autoConvert: false})) {\n    var error = ctx.getErrorObject();\n    var matchError = new Match.Error(error.message);\n    matchError.invalidKeys = error.invalidKeys;\n    if (Meteor.isServer) {\n      matchError.sanitizedError = error.sanitizedError;\n    }\n    throw matchError;\n  }\n\n  return true;\n};\n\nfunction logInvalidKeysForContext(context, name) {\n  Meteor.startup(function() {\n    Tracker.autorun(function() {\n      if (!context.isValid()) {\n        console.log('SimpleSchema invalid keys for \"' + name + '\" context:', context.invalidKeys());\n      }\n    });\n  });\n}\n\nSimpleSchema.prototype.namedContext = function(name) {\n  var self = this;\n  if (typeof name !== \"string\") {\n    name = \"default\";\n  }\n  if (!self._validationContexts[name]) {\n    self._validationContexts[name] = new SimpleSchemaValidationContext(self);\n\n    // In debug mode, log all invalid key errors to the browser console\n    if (SimpleSchema.debug && Meteor.isClient) {\n      Tracker.nonreactive(function() {\n        logInvalidKeysForContext(self._validationContexts[name], name);\n      });\n    }\n  }\n  return self._validationContexts[name];\n};\n\n// Global custom validators\nSimpleSchema._validators = [];\nSimpleSchema.addValidator = function(func) {\n  SimpleSchema._validators.push(func);\n};\n\n// Instance custom validators\nSimpleSchema.prototype.addValidator = function(func) {\n  this._validators.push(func);\n};\n\n/**\n * @method SimpleSchema.prototype.pick\n * @param {[fields]} The list of fields to pick to instantiate the subschema\n * @returns {SimpleSchema} The subschema\n */\nSimpleSchema.prototype.pick = function(/* arguments */) {\n  var self = this;\n  var args = _.toArray(arguments);\n  args.unshift(self._schema);\n\n  var newSchema = _.pick.apply(null, args);\n  return new SimpleSchema(newSchema);\n};\n\nSimpleSchema.prototype.omit = function() {\n  var self = this;\n  var args = _.toArray(arguments);\n  args.unshift(self._schema);\n\n  var newSchema = _.omit.apply(null, args);\n  return new SimpleSchema(newSchema);\n};\n\n\n/**\n * @method SimpleSchema.prototype.clean\n * @param {Object} doc - Document or modifier to clean. Referenced object will be modified in place.\n * @param {Object} [options]\n * @param {Boolean} [options.filter=true] - Do filtering?\n * @param {Boolean} [options.autoConvert=true] - Do automatic type converting?\n * @param {Boolean} [options.removeEmptyStrings=true] - Remove keys in normal object or $set where the value is an empty string?\n * @param {Boolean} [options.trimStrings=true] - Trim string values?\n * @param {Boolean} [options.getAutoValues=true] - Inject automatic and default values?\n * @param {Boolean} [options.isModifier=false] - Is doc a modifier object?\n * @param {Object} [options.extendAutoValueContext] - This object will be added to the `this` context of autoValue functions.\n * @returns {Object} The modified doc.\n *\n * Cleans a document or modifier object. By default, will filter, automatically\n * type convert where possible, and inject automatic/default values. Use the options\n * to skip one or more of these.\n */\nSimpleSchema.prototype.clean = function(doc, options) {\n  var self = this;\n\n  // By default, doc will be filtered and autoconverted\n  options = _.extend({\n    filter: true,\n    autoConvert: true,\n    removeEmptyStrings: true,\n    trimStrings: true,\n    getAutoValues: true,\n    isModifier: false,\n    extendAutoValueContext: {}\n  }, options || {});\n\n  // Convert $pushAll (deprecated) to $push with $each\n  if (\"$pushAll\" in doc) {\n    console.warn(\"SimpleSchema.clean: $pushAll is deprecated; converting to $push with $each\");\n    doc.$push = doc.$push || {};\n    for (var field in doc.$pushAll) {\n      doc.$push[field] = doc.$push[field] || {};\n      doc.$push[field].$each = doc.$push[field].$each || [];\n      for (var i = 0, ln = doc.$pushAll[field].length; i < ln; i++) {\n        doc.$push[field].$each.push(doc.$pushAll[field][i]);\n      }\n      delete doc.$pushAll;\n    }\n  }\n\n  var mDoc = new MongoObject(doc, self._blackboxKeys);\n\n  // Clean loop\n  if (options.filter || options.autoConvert || options.removeEmptyStrings || options.trimStrings) {\n    mDoc.forEachNode(function() {\n      var gKey = this.genericKey, p, def, val;\n      if (gKey) {\n        def = self._schema[gKey];\n        val = this.value;\n        // Filter out props if necessary; any property is OK for $unset because we want to\n        // allow conversions to remove props that have been removed from the schema.\n        if (options.filter && this.operator !== \"$unset\" && !self.allowsKey(gKey)) {\n          // XXX Special handling for $each; maybe this could be made nicer\n          if (this.position.slice(-7) === \"[$each]\") {\n            mDoc.removeValueForPosition(this.position.slice(0, -7));\n          } else {\n            this.remove();\n          }\n          if (SimpleSchema.debug) {\n            console.info('SimpleSchema.clean: filtered out value that would have affected key \"' + gKey + '\", which is not allowed by the schema');\n          }\n          return; // no reason to do more\n        }\n        if (val !== void 0) {\n          // Autoconvert values if requested and if possible\n          var wasAutoConverted = false;\n          if (options.autoConvert && this.operator !== \"$unset\" && def) {\n            var newVal = typeconvert(val, def.type);\n            // trim strings\n            if (options.trimStrings && typeof newVal === \"string\") {\n              newVal = newVal.trim();\n            }\n            if (newVal !== void 0 && newVal !== val) {\n              // remove empty strings\n              if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof newVal === \"string\" && !newVal.length) {\n                // For a document, we remove any fields that are being set to an empty string\n                newVal = void 0;\n                // For a modifier, we $unset any fields that are being set to an empty string\n                if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {\n\n                  p = this.position.replace(\"$set\", \"$unset\");\n                  mDoc.setValueForPosition(p, \"\");\n                }\n              }\n\n              // Change value; if undefined, will remove it\n              SimpleSchema.debug && console.info('SimpleSchema.clean: autoconverted value ' + val + ' from ' + typeof val + ' to ' + typeof newVal + ' for ' + gKey);\n              this.updateValue(newVal);\n              wasAutoConverted = true;\n            }\n          }\n          if (!wasAutoConverted) {\n            // trim strings\n            if (options.trimStrings && typeof val === \"string\" && (!def || (def && def.trim !== false))) {\n              this.updateValue(val.trim());\n            }\n            // remove empty strings\n            if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof val === \"string\" && !val.length) {\n              // For a document, we remove any fields that are being set to an empty string\n              this.remove();\n              // For a modifier, we $unset any fields that are being set to an empty string. But only if we're not already within an entire object that is being set.\n              if (this.operator === \"$set\" && this.position.match(/\\[.+?\\]/g).length < 2) {\n                p = this.position.replace(\"$set\", \"$unset\");\n                mDoc.setValueForPosition(p, \"\");\n              }\n            }\n          }\n        }\n      }\n    }, {endPointsOnly: false});\n  }\n\n  // Set automatic values\n  options.getAutoValues && getAutoValues.call(self, mDoc, options.isModifier, options.extendAutoValueContext);\n\n  // Ensure we don't have any operators set to an empty object\n  // since MongoDB 2.6+ will throw errors.\n  if (options.isModifier) {\n    for (var op in doc) {\n      if (doc.hasOwnProperty(op) && _.isEmpty(doc[op])) {\n        delete doc[op];\n      }\n    }\n  }\n\n  return doc;\n};\n\n// Returns the entire schema object or just the definition for one key\n// in the schema.\nSimpleSchema.prototype.schema = function(key) {\n  var self = this;\n  // if not null or undefined (more specific)\n  if (key !== null && key !== void 0) {\n    return self._schema[SimpleSchema._makeGeneric(key)];\n  } else {\n    return self._schema;\n  }\n};\n\n// Returns the evaluated definition for one key in the schema\n// key = non-generic key\n// [propList] = props to include in the result, for performance\n// [functionContext] = used for evaluating schema options that are functions\nSimpleSchema.prototype.getDefinition = function(key, propList, functionContext) {\n  var self = this;\n  var defs = self.schema(key);\n  if (!defs) {\n    return;\n  }\n\n  if (_.isArray(propList)) {\n    defs = _.pick(defs, propList);\n  } else {\n    defs = _.clone(defs);\n  }\n\n  // For any options that support specifying a function,\n  // evaluate the functions.\n  _.each(['min', 'max', 'minCount', 'maxCount', 'allowedValues', 'optional', 'label'], function (prop) {\n    if (_.isFunction(defs[prop])) {\n      defs[prop] = defs[prop].call(functionContext || {});\n    }\n  });\n\n  // Inflect label if not defined\n  defs.label = defs.label || inflectedLabel(key);\n\n  return defs;\n};\n\n// Check if the key is a nested dot-syntax key inside of a blackbox object\nSimpleSchema.prototype.keyIsInBlackBox = function(key) {\n  var self = this;\n  var parentPath = SimpleSchema._makeGeneric(key), lastDot, def;\n\n  // Iterate the dot-syntax hierarchy until we find a key in our schema\n  do {\n    lastDot = parentPath.lastIndexOf('.');\n    if (lastDot !== -1) {\n      parentPath = parentPath.slice(0, lastDot); // Remove last path component\n      def = self.getDefinition(parentPath);\n    }\n  } while (lastDot !== -1 && !def);\n\n  return !!(def && def.blackbox);\n};\n\n// Use to dynamically change the schema labels.\nSimpleSchema.prototype.labels = function(labels) {\n  var self = this;\n  _.each(labels, function(label, fieldName) {\n    if (!_.isString(label) && !_.isFunction(label)) {\n      return;\n    }\n\n    if (!(fieldName in self._schema)) {\n      return;\n    }\n\n    self._schema[fieldName].label = label;\n    self._depsLabels[fieldName] && self._depsLabels[fieldName].changed();\n  });\n};\n\n// should be used to safely get a label as string\nSimpleSchema.prototype.label = function(key) {\n  var self = this;\n\n  // Get all labels\n  if (key === null || key === void 0) {\n    var result = {};\n    _.each(self.schema(), function(def, fieldName) {\n      result[fieldName] = self.label(fieldName);\n    });\n    return result;\n  }\n\n  // Get label for one field\n  var def = self.getDefinition(key);\n  if (def) {\n    var genericKey = SimpleSchema._makeGeneric(key);\n    self._depsLabels[genericKey] && self._depsLabels[genericKey].depend();\n    return def.label;\n  }\n\n  return null;\n};\n\n// Global messages\n\nSimpleSchema._globalMessages = {\n  required: \"[label] is required\",\n  minString: \"[label] must be at least [min] characters\",\n  maxString: \"[label] cannot exceed [max] characters\",\n  minNumber: \"[label] must be at least [min]\",\n  maxNumber: \"[label] cannot exceed [max]\",\n  minNumberExclusive: \"[label] must be greater than [min]\",\n  maxNumberExclusive: \"[label] must be less than [max]\",\n  minDate: \"[label] must be on or after [min]\",\n  maxDate: \"[label] cannot be after [max]\",\n  badDate: \"[label] is not a valid date\",\n  minCount: \"You must specify at least [minCount] values\",\n  maxCount: \"You cannot specify more than [maxCount] values\",\n  noDecimal: \"[label] must be an integer\",\n  notAllowed: \"[value] is not an allowed value\",\n  expectedString: \"[label] must be a string\",\n  expectedNumber: \"[label] must be a number\",\n  expectedBoolean: \"[label] must be a boolean\",\n  expectedArray: \"[label] must be an array\",\n  expectedObject: \"[label] must be an object\",\n  expectedConstructor: \"[label] must be a [type]\",\n  regEx: [\n    {msg: \"[label] failed regular expression validation\"},\n    {exp: SimpleSchema.RegEx.Email, msg: \"[label] must be a valid e-mail address\"},\n    {exp: SimpleSchema.RegEx.WeakEmail, msg: \"[label] must be a valid e-mail address\"},\n    {exp: SimpleSchema.RegEx.Domain, msg: \"[label] must be a valid domain\"},\n    {exp: SimpleSchema.RegEx.WeakDomain, msg: \"[label] must be a valid domain\"},\n    {exp: SimpleSchema.RegEx.IP, msg: \"[label] must be a valid IPv4 or IPv6 address\"},\n    {exp: SimpleSchema.RegEx.IPv4, msg: \"[label] must be a valid IPv4 address\"},\n    {exp: SimpleSchema.RegEx.IPv6, msg: \"[label] must be a valid IPv6 address\"},\n    {exp: SimpleSchema.RegEx.Url, msg: \"[label] must be a valid URL\"},\n    {exp: SimpleSchema.RegEx.Id, msg: \"[label] must be a valid alphanumeric ID\"}\n  ],\n  keyNotInSchema: \"[key] is not allowed by the schema\"\n};\n\nSimpleSchema.messages = function(messages) {\n  _.extend(SimpleSchema._globalMessages, messages);\n  SimpleSchema._depsGlobalMessages.changed();\n};\n\n// Schema-specific messages\n\nSimpleSchema.prototype.messages = function(messages) {\n  var self = this;\n  _.extend(self._messages, messages);\n  self._depsMessages.changed();\n};\n\n// Returns a string message for the given error type and key. Uses the\n// def and value arguments to fill in placeholders in the error messages.\nSimpleSchema.prototype.messageForError = function(type, key, def, value) {\n  var self = this;\n\n  // We proceed even if we can't get a definition because it might be a keyNotInSchema error\n  def = def || self.getDefinition(key, ['regEx', 'label', 'minCount', 'maxCount', 'min', 'max', 'type']) || {};\n\n  // Adjust for complex types, currently only regEx,\n  // where we might have regEx.1 meaning the second\n  // expression in the array.\n  var firstTypePeriod = type.indexOf(\".\"), index = null;\n  if (firstTypePeriod !== -1) {\n    index = type.substring(firstTypePeriod + 1);\n    index = parseInt(index, 10);\n    type = type.substring(0, firstTypePeriod);\n  }\n\n  // Which regExp is it?\n  var regExpMatch;\n  if (type === \"regEx\") {\n    if (index !== null && index !== void 0 && !isNaN(index)) {\n      regExpMatch = def.regEx[index];\n    } else {\n      regExpMatch = def.regEx;\n    }\n    if (regExpMatch) {\n      regExpMatch = regExpMatch.toString();\n    }\n  }\n\n  // Prep some strings to be used when finding the correct message for this error\n  var typePlusKey = type + \" \" + key;\n  var genericKey = SimpleSchema._makeGeneric(key);\n  var typePlusGenKey = type + \" \" + genericKey;\n\n  // reactively update when message templates are changed\n  SimpleSchema._depsGlobalMessages.depend();\n  self._depsMessages.depend();\n\n  // Prep a function that finds the correct message for regEx errors\n  function findRegExError(message) {\n    if (type !== \"regEx\" || !_.isArray(message)) {\n      return message;\n    }\n    // Parse regEx messages, which are provided in a special object array format\n    // [{exp: RegExp, msg: \"Foo\"}]\n    // Where `exp` is optional\n\n    var msgObj;\n    // First see if there's one where exp matches this expression\n    if (regExpMatch) {\n      msgObj = _.find(message, function (o) {\n        return o.exp && o.exp.toString() === regExpMatch;\n      });\n    }\n\n    // If not, see if there's a default message defined\n    if (!msgObj) {\n      msgObj = _.findWhere(message, {exp: null});\n      if (!msgObj) {\n        msgObj = _.findWhere(message, {exp: void 0});\n      }\n    }\n\n    return msgObj ? msgObj.msg : null;\n  }\n\n  // Try finding the correct message to use at various levels, from most\n  // specific to least specific.\n  var message = self._messages[typePlusKey] ||                  // (1) Use schema-specific message for specific key\n                self._messages[typePlusGenKey] ||               // (2) Use schema-specific message for generic key\n                self._messages[type];                           // (3) Use schema-specific message for type\n  message = findRegExError(message);\n\n  if (!message) {\n    message = SimpleSchema._globalMessages[typePlusKey] ||      // (4) Use global message for specific key\n              SimpleSchema._globalMessages[typePlusGenKey] ||   // (5) Use global message for generic key\n              SimpleSchema._globalMessages[type];               // (6) Use global message for type\n    message = findRegExError(message);\n  }\n\n  if (!message) {\n    return \"Unknown validation error\";\n  }\n\n  // Now replace all placeholders in the message with the correct values\n\n  // [key]\n  message = message.replace(\"[key]\", key);\n\n  // [label]\n  // The call to self.label() establishes a reactive dependency, too\n  message = message.replace(\"[label]\", self.label(key));\n\n  // [minCount]\n  if (typeof def.minCount !== \"undefined\") {\n    message = message.replace(\"[minCount]\", def.minCount);\n  }\n\n  // [maxCount]\n  if (typeof def.maxCount !== \"undefined\") {\n    message = message.replace(\"[maxCount]\", def.maxCount);\n  }\n\n  // [value]\n  if (value !== void 0 && value !== null) {\n    message = message.replace(\"[value]\", value.toString());\n  } else {\n    message = message.replace(\"[value]\", 'null');\n  }\n\n  // [min] and [max]\n  var min = def.min;\n  var max = def.max;\n  if (def.type === Date || def.type === [Date]) {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", Utility.dateToDateString(min));\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", Utility.dateToDateString(max));\n    }\n  } else {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", min);\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", max);\n    }\n  }\n\n  // [type]\n  if (def.type instanceof Function) {\n    message = message.replace(\"[type]\", def.type.name);\n  }\n\n  // Now return the message\n  return message;\n};\n\n// Returns true if key is explicitly allowed by the schema or implied\n// by other explicitly allowed keys.\n// The key string should have $ in place of any numeric array positions.\nSimpleSchema.prototype.allowsKey = function(key) {\n  var self = this;\n\n  // Loop through all keys in the schema\n  return _.any(self._schemaKeys, function(schemaKey) {\n\n    // If the schema key is the test key, it's allowed.\n    if (schemaKey === key) {\n      return true;\n    }\n\n    // Black box handling\n    if (self.schema(schemaKey).blackbox === true) {\n      var kl = schemaKey.length;\n      var compare1 = key.slice(0, kl + 2);\n      var compare2 = compare1.slice(0, -1);\n\n      // If the test key is the black box key + \".$\", then the test\n      // key is NOT allowed because black box keys are by definition\n      // only for objects, and not for arrays.\n      if (compare1 === schemaKey + '.$') {\n        return false;\n      }\n\n      // Otherwise\n      if (compare2 === schemaKey + '.') {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\nSimpleSchema.prototype.newContext = function() {\n  return new SimpleSchemaValidationContext(this);\n};\n\n// Returns all the child keys for the object identified by the generic prefix,\n// or all the top level keys if no prefix is supplied.\nSimpleSchema.prototype.objectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelSchemaKeys;\n  }\n  return self._objectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.validate = function (obj, options) {\n  if (Package.check && Package['audit-argument-checks']) {\n    // Call check but ignore the error to silence audit-argument-checks\n    try { check(obj); } catch (e) { /* ignore error */ }\n  }\n\n  var validationContext = this.newContext();\n  var isValid = validationContext.validate(obj, options);\n\n  if (isValid) return;\n\n  var errors = validationContext.invalidKeys().map(function (error) {\n    return {\n      name: error.name,\n      type: error.type,\n      details: {\n        value: error.value\n      }\n    };\n  });\n\n  // In order for the message at the top of the stack trace to be useful,\n  // we set it to the first validation error message.\n  var message = validationContext.keyErrorMessage(errors[0].name);\n\n  throw new Package['mdg:validation-error'].ValidationError(errors, message);\n};\n\nSimpleSchema.prototype.validator = function (options) {\n  var self = this;\n  options = options || {};\n  return function (obj) {\n    if (options.clean === true) self.clean(obj, options);\n    self.validate(obj);\n  };\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-validation.js                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility */\n/* global _ */\n/* global SimpleSchema */\n/* global MongoObject */\n/* global doValidation1:true */\n\nfunction doTypeChecks(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (def.max !== null && def.max < keyValue.length) {\n      return \"maxString\";\n    } else if (def.min !== null && def.min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError) {\n        return regExError;\n      }\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!Utility.isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (isNaN(keyValue.getTime())) {\n        return \"badDate\";\n      }\n\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n}\n\ndoValidation1 = function doValidation1(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n\n  if (!isModifier && Utility.looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  var invalidKeys = [];\n  var mDoc; // for caching the MongoObject if necessary\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, isInArrayItemObject, isInSubObject) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If the operator is $unset or $rename, it's invalid.\n    // * If the value is null, it's invalid.\n    // * If the value is undefined and one of the following are true, it's invalid:\n    //     * We're validating a key of a sub-object.\n    //     * We're validating a key of an object that is an array item.\n    //     * We're validating a document (as opposed to a modifier).\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.\n    if (!skipRequiredCheck && !def.optional) {\n      if (\n        val === null ||\n        op === \"$unset\" ||\n        op === \"$rename\" ||\n        (val === void 0 && (isInArrayItemObject || isInSubObject || !op || op === \"$set\"))\n        ) {\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // For $rename, make sure that the new name is allowed by the schema\n    if (op === \"$rename\" && typeof val === \"string\" && !ss.allowsKey(val)) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", val, null, null, ss));\n      return;\n    }\n\n    // Value checks are not necessary for null or undefined values\n    // or for $unset or $rename values\n    if (op !== \"$unset\" && op !== \"$rename\" && Utility.isNotNullOrUndefined(val)) {\n\n      // Check that value is of the correct type\n      var typeError = doTypeChecks(def, val, op);\n      if (typeError) {\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));\n        return;\n      }\n\n      // Check value against allowedValues array\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // Perform custom validation\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var validators = def.custom ? [def.custom] : [];\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);\n    _.every(validators, function(validator) {\n      var errorType = validator.call(_.extend({\n        key: affectedKey,\n        genericKey: affectedKeyGeneric,\n        definition: def,\n        isSet: (val !== void 0),\n        value: val,\n        operator: op,\n        field: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        },\n        siblingField: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        }\n      }, extendedCustomContext || {}));\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, operator, setKeys, isInArrayItemObject, isInSubObject) {\n    var affectedKeyGeneric, def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (ss.keyIsInBlackBox(affectedKey)) {\n        return;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);\n      def = ss.getDefinition(affectedKey);\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        // We can skip the required check for keys that are ancestors\n        // of those in $set or $setOnInsert because they will be created\n        // by MongoDB while setting.\n        var skipRequiredCheck = _.some(setKeys, function(sk) {\n          return (sk.slice(0, affectedKey.length + 1) === affectedKey + \".\");\n        });\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, skipRequiredCheck, isInArrayItemObject, isInSubObject);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i, operator, setKeys);\n      });\n    }\n\n    // Loop through object keys\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {\n\n      // Get list of present keys\n      var presentKeys = _.keys(val);\n\n      // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n      var keysToCheck = _.union(presentKeys, ss.objectKeys(affectedKeyGeneric));\n\n      // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n      isInArrayItemObject = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");\n\n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), operator, setKeys, isInArrayItemObject, true);\n      });\n    }\n\n  }\n\n  function checkModifier(mod) {\n    // Check for empty modifier\n    if (_.isEmpty(mod)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    }\n\n    // Get a list of all keys in $set and $setOnInsert combined, for use later\n    var setKeys = _.keys(mod.$set || {}).concat(_.keys(mod.$setOnInsert || {}));\n\n    // If this is an upsert, add all the $setOnInsert keys to $set;\n    // since we don't know whether it will be an insert or update, we'll\n    // validate upserts as if they will be an insert.\n    if (\"$setOnInsert\" in mod) {\n      if (isUpsert) {\n        mod.$set = mod.$set || {};\n        mod.$set = _.extend(mod.$set, mod.$setOnInsert);\n      }\n      delete mod.$setOnInsert;\n    }\n\n    // Loop through operators\n    _.each(mod, function (opObj, op) {\n      // If non-operators are mixed in, throw error\n      if (op.slice(0, 1) !== \"$\") {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators. Did you forget `$set`?\");\n      }\n      if (Utility.shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we add null keys to the modifier to force any \"required\" checks to fail\n        if (isUpsert && op === \"$set\") {\n          var presentKeys = _.keys(opObj);\n          _.each(ss.objectKeys(), function (schemaKey) {\n            if (!_.contains(presentKeys, schemaKey)) {\n              checkObj(void 0, schemaKey, op, setKeys);\n            }\n          });\n        }\n        _.each(opObj, function (v, k) {\n          if (op === \"$push\" || op === \"$addToSet\") {\n            if (Utility.isBasicObject(v) && \"$each\" in v) {\n              v = v.$each;\n            } else {\n              k = k + \".0\";\n            }\n          }\n          checkObj(v, k, op, setKeys);\n        });\n      }\n    });\n  }\n\n  // Kick off the validation\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj(obj);\n  }\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-validation-new.js                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Utility */\n/* global _ */\n/* global SimpleSchema */\n/* global MongoObject */\n/* global Meteor */\n/* global Random */\n/* global doValidation2:true */\n\nfunction doTypeChecks(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (def.max !== null && def.max < keyValue.length) {\n      return \"maxString\";\n    } else if (def.min !== null && def.min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError) {\n        return regExError;\n      }\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && def.max !== null && (!!def.exclusiveMax ? def.max <= keyValue : def.max < keyValue)) {\n       return !!def.exclusiveMax ? \"maxNumberExclusive\" : \"maxNumber\";\n    } else if (op !== \"$inc\" && def.min !== null && (!!def.exclusiveMin ? def.min >= keyValue : def.min > keyValue)) {\n       return !!def.exclusiveMin ? \"minNumberExclusive\" : \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!Utility.isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || Utility.safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (isNaN(keyValue.getTime())) {\n        return \"badDate\";\n      }\n\n      if (_.isDate(def.min) && def.min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(def.max) && def.max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n}\n\ndoValidation2 = function doValidation2(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n\n  if (isModifier) {\n    if (_.isEmpty(obj)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    } else {\n      var allKeysAreOperators = _.every(obj, function(v, k) {\n        return (k.substring(0, 1) === \"$\");\n      });\n      if (!allKeysAreOperators) {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators\");\n      }\n\n      // We use a LocalCollection to figure out what the resulting doc\n      // would be in a worst case scenario. Then we validate that doc\n      // so that we don't have to validate the modifier object directly.\n      obj = convertModifierToDoc(obj, ss.schema(), isUpsert);\n    }\n  } else if (Utility.looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  var invalidKeys = [];\n  var mDoc; // for caching the MongoObject if necessary\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, strictRequiredCheck) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(Utility.errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If the operator is $unset or $rename, it's invalid.\n    // * If the value is null, it's invalid.\n    // * If the value is undefined and one of the following are true, it's invalid:\n    //     * We're validating a key of a sub-object.\n    //     * We're validating a key of an object that is an array item.\n    //     * We're validating a document (as opposed to a modifier).\n    //     * We're validating a key under the $set operator in a modifier, and it's an upsert.\n    if (!skipRequiredCheck && !def.optional) {\n      if (val === null || val === void 0) {\n        invalidKeys.push(Utility.errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // Value checks are not necessary for null or undefined values\n    if (Utility.isNotNullOrUndefined(val)) {\n\n      // Check that value is of the correct type\n      var typeError = doTypeChecks(def, val, op);\n      if (typeError) {\n        invalidKeys.push(Utility.errorObject(typeError, affectedKey, val, def, ss));\n        return;\n      }\n\n      // Check value against allowedValues array\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n        invalidKeys.push(Utility.errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // Perform custom validation\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var validators = def.custom ? [def.custom] : [];\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);\n    _.every(validators, function(validator) {\n      var errorType = validator.call(_.extend({\n        key: affectedKey,\n        genericKey: affectedKeyGeneric,\n        definition: def,\n        isSet: (val !== void 0),\n        value: val,\n        operator: op,\n        field: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        },\n        siblingField: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        }\n      }, extendedCustomContext || {}));\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(Utility.errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, skipRequiredCheck, strictRequiredCheck) {\n    var affectedKeyGeneric, def;\n\n    if (affectedKey) {\n\n      // When we hit a blackbox key, we don't progress any further\n      if (ss.keyIsInBlackBox(affectedKey)) {\n        return;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);\n      def = ss.getDefinition(affectedKey);\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        validate(val, affectedKey, affectedKeyGeneric, def, null, skipRequiredCheck, strictRequiredCheck);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i);\n      });\n    }\n\n    // Loop through object keys\n    else if (Utility.isBasicObject(val) && (!def || !def.blackbox)) {\n\n      // Get list of present keys\n      var presentKeys = _.keys(val);\n\n      // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n      var keysToCheck = _.union(presentKeys, ss._schemaKeys);\n\n      // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n      strictRequiredCheck = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");\n\n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        if (Utility.shouldCheck(key)) {\n          checkObj(val[key], Utility.appendAffectedKey(affectedKey, key), skipRequiredCheck, strictRequiredCheck);\n        }\n      });\n    }\n\n  }\n\n  // Kick off the validation\n  checkObj(obj);\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n\nfunction convertModifierToDoc(mod, schema, isUpsert) {\n  // Create unmanaged LocalCollection as scratchpad\n  var t = new Meteor.Collection(null);\n\n  // LocalCollections are in memory, and it seems\n  // that it's fine to use them synchronously on \n  // either client or server\n  var id;\n  if (isUpsert) {\n    // We assume upserts will be inserts (conservative\n    // validation of requiredness)\n    id = Random.id();\n    t.upsert({_id: id}, mod);\n  } else {\n    var mDoc = new MongoObject(mod);\n    // Create a ficticious existing document\n    var fakeDoc = new MongoObject({});\n    _.each(schema, function (def, fieldName) {\n      var setVal;\n      // Prefill doc with empty arrays to avoid the\n      // mongodb issue where it does not understand\n      // that numeric pieces should create arrays.\n      if (def.type === Array && mDoc.affectsGenericKey(fieldName)) {\n        setVal = [];\n      }\n      // Set dummy values for required fields because\n      // we assume any existing data would be valid.\n      else if (!def.optional) {\n        // TODO correct value type based on schema type\n        if (def.type === Boolean) {\n          setVal = true;\n        } else if (def.type === Number) {\n          setVal = def.min || 0;\n        } else if (def.type === Date) {\n          setVal = def.min || new Date();\n        } else if (def.type === Array) {\n          setVal = [];\n        } else if (def.type === Object) {\n          setVal = {};\n        } else {\n          setVal = \"0\";\n        }\n      }\n\n      if (setVal !== void 0) {\n        var key = fieldName.replace(/\\.\\$/g, \".0\");\n        var pos = MongoObject._keyToPosition(key, false);\n        fakeDoc.setValueForPosition(pos, setVal);\n      }\n    });\n    fakeDoc = fakeDoc.getObject();\n    // Insert fake doc into local scratch collection\n    id = t.insert(fakeDoc);\n    // Now update it with the modifier\n    t.update(id, mod);\n  }\n  \n  var doc = t.findOne(id);\n  // We're done with it\n  t.remove(id);\n  // Currently we don't validate _id unless it is\n  // explicitly added to the schema\n  if (!schema._id) {\n    delete doc._id;\n  }\n  return doc;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/aldeed_simple-schema/simple-schema-context.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global SimpleSchema */\n/* global SimpleSchemaValidationContext:true */\n/* global doValidation1 */\n/* global doValidation2 */\n\nfunction doValidation(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n  var useOld = true; //for now this can be manually changed to try the experimental method, which doesn't yet work properly\n  var func = useOld ? doValidation1 : doValidation2;\n  return func(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext);\n}\n\n/*\n * PUBLIC API\n */\n\nSimpleSchemaValidationContext = function SimpleSchemaValidationContext(ss) {\n  var self = this;\n  self._simpleSchema = ss;\n  self._schema = ss.schema();\n  self._schemaKeys = _.keys(self._schema);\n  self._invalidKeys = [];\n  //set up validation dependencies\n  self._deps = {};\n  self._depsAny = new Tracker.Dependency();\n  _.each(self._schemaKeys, function(name) {\n    self._deps[name] = new Tracker.Dependency();\n  });\n};\n\n//validates the object against the simple schema and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validate = function simpleSchemaValidationContextValidate(doc, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, null, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //note any currently invalid keys so that we can mark them as changed\n  //due to new validation (they may be valid now, or invalid in a different way)\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //update\n  self._invalidKeys = invalidKeys;\n\n  //add newly invalid keys to changedKeys\n  var addedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //mark all changed keys as changed\n  var changedKeys = _.union(addedKeys, removedKeys);\n  self._markKeysChanged(changedKeys);\n\n  // Return true if it was valid; otherwise, return false\n  return self._invalidKeys.length === 0;\n};\n\n//validates doc against self._schema for one key and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validateOne = function simpleSchemaValidationContextValidateOne(doc, keyName, options) {\n  var self = this, i, ln, k;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, keyName, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //remove objects from self._invalidKeys where name = keyName\n  var newInvalidKeys = [];\n  for (i = 0, ln = self._invalidKeys.length; i < ln; i++) {\n    k = self._invalidKeys[i];\n    if (k.name !== keyName) {\n      newInvalidKeys.push(k);\n    }\n  }\n  self._invalidKeys = newInvalidKeys;\n\n  //merge invalidKeys into self._invalidKeys\n  for (i = 0, ln = invalidKeys.length; i < ln; i++) {\n    k = invalidKeys[i];\n    self._invalidKeys.push(k);\n  }\n\n  //mark key as changed due to new validation (they may be valid now, or invalid in a different way)\n  self._markKeysChanged([keyName]);\n\n  // Return true if it was valid; otherwise, return false\n  return !self._keyIsInvalid(keyName);\n};\n\n//reset the invalidKeys array\nSimpleSchemaValidationContext.prototype.resetValidation = function simpleSchemaValidationContextResetValidation() {\n  var self = this;\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n  self._invalidKeys = [];\n  self._markKeysChanged(removedKeys);\n};\n\nSimpleSchemaValidationContext.prototype.isValid = function simpleSchemaValidationContextIsValid() {\n  var self = this;\n  self._depsAny.depend();\n  return !self._invalidKeys.length;\n};\n\nSimpleSchemaValidationContext.prototype.invalidKeys = function simpleSchemaValidationContextInvalidKeys() {\n  var self = this;\n  self._depsAny.depend();\n  return self._invalidKeys;\n};\n\nSimpleSchemaValidationContext.prototype.addInvalidKeys = function simpleSchemaValidationContextAddInvalidKeys(errors) {\n  var self = this;\n\n  if (!errors || !errors.length) {\n    return;\n  }\n\n  var changedKeys = [];\n  _.each(errors, function (errorObject) {\n    changedKeys.push(errorObject.name);\n    self._invalidKeys.push(errorObject);\n  });\n\n  self._markKeysChanged(changedKeys);\n};\n\nSimpleSchemaValidationContext.prototype._markKeysChanged = function simpleSchemaValidationContextMarkKeysChanged(keys) {\n  var self = this;\n\n  if (!keys || !keys.length) {\n    return;\n  }\n\n  _.each(keys, function(name) {\n    var genericName = SimpleSchema._makeGeneric(name);\n    if (genericName in self._deps) {\n      self._deps[genericName].changed();\n    }\n  });\n  self._depsAny.changed();\n};\n\nSimpleSchemaValidationContext.prototype._getInvalidKeyObject = function simpleSchemaValidationContextGetInvalidKeyObject(name, genericName) {\n  var self = this;\n  genericName = genericName || SimpleSchema._makeGeneric(name);\n\n  var errorObj = _.findWhere(self._invalidKeys, {name: name});\n  if (!errorObj) {\n    errorObj = _.findWhere(self._invalidKeys, {name: genericName});\n  }\n  return errorObj;\n};\n\nSimpleSchemaValidationContext.prototype._keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name, genericName) {\n  return !!this._getInvalidKeyObject(name, genericName);\n};\n\n// Like the internal one, but with deps\nSimpleSchemaValidationContext.prototype.keyIsInvalid = function simpleSchemaValidationContextKeyIsInvalid(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  self._deps[genericName] && self._deps[genericName].depend();\n\n  return self._keyIsInvalid(name, genericName);\n};\n\nSimpleSchemaValidationContext.prototype.keyErrorMessage = function simpleSchemaValidationContextKeyErrorMessage(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  self._deps[genericName] && self._deps[genericName].depend();\n\n  var errorObj = self._getInvalidKeyObject(name, genericName);\n  if (!errorObj) {\n    return \"\";\n  }\n\n  return self._simpleSchema.messageForError(errorObj.type, errorObj.name, null, errorObj.value);\n};\n\nSimpleSchemaValidationContext.prototype.getErrorObject = function simpleSchemaValidationContextGetErrorObject() {\n  var self = this, message, invalidKeys = this._invalidKeys;\n  if (invalidKeys.length) {\n    message = self.keyErrorMessage(invalidKeys[0].name);\n    // We add `message` prop to the invalidKeys.\n    invalidKeys = _.map(invalidKeys, function (o) {\n      return _.extend({message: self.keyErrorMessage(o.name)}, o);\n    });\n  } else {\n    message = \"Failed validation\";\n  }\n  var error = new Error(message);\n  error.invalidKeys = invalidKeys;\n  // If on the server, we add a sanitized error, too, in case we're\n  // called from a method.\n  if (Meteor.isServer) {\n    error.sanitizedError = new Meteor.Error(400, message);\n  }\n  return error;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"aldeed:simple-schema\", {\n  SimpleSchema: SimpleSchema,\n  MongoObject: MongoObject,\n  humanize: humanize\n});\n\n})();\n","servePath":"/packages/aldeed_simple-schema.js"}]