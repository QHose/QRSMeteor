[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar EJSON = Package.ejson.EJSON;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar DiffSequence;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"diff-sequence\":{\"diff.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                 //\n// packages/diff-sequence/diff.js                                                                  //\n//                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                   //\nmodule.export({\n  DiffSequence: () => DiffSequence\n});\nconst DiffSequence = {};\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isObjEmpty(obj) {\n  for (let key in Object(obj)) {\n    if (hasOwn.call(obj, key)) {\n      return false;\n    }\n  }\n\n  return true;\n} // ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\n\n\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n  if (ordered) DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);else DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n};\n\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  if (observer.movedBefore) {\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n  }\n\n  newResults.forEach(function (newDoc, id) {\n    var oldDoc = oldResults.get(id);\n\n    if (oldDoc) {\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n        var projectedNew = projectionFn(newDoc);\n        var projectedOld = projectionFn(oldDoc);\n        var changedFields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n        if (!isObjEmpty(changedFields)) {\n          observer.changed(id, changedFields);\n        }\n      }\n    } else if (observer.added) {\n      var fields = projectionFn(newDoc);\n      delete fields._id;\n      observer.added(newDoc._id, fields);\n    }\n  });\n\n  if (observer.removed) {\n    oldResults.forEach(function (oldDoc, id) {\n      if (!newResults.has(id)) observer.removed(id);\n    });\n  }\n};\n\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results, observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n  var new_presence_of_id = {};\n  new_results.forEach(function (doc) {\n    if (new_presence_of_id[doc._id]) Meteor._debug(\"Duplicate _id in new_results\");\n    new_presence_of_id[doc._id] = true;\n  });\n  var old_index_of_id = {};\n  old_results.forEach(function (doc, i) {\n    if (doc._id in old_index_of_id) Meteor._debug(\"Duplicate _id in old_results\");\n    old_index_of_id[doc._id] = i;\n  }); // ALGORITHM:\n  //\n  // To determine which docs should be considered \"moved\" (and which\n  // merely change position because of other docs moving) we run\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\n  // considered moved.\n  // To actually call the appropriate callbacks to get from the old state to the\n  // new state:\n  // First, we call removed() on all the items that only appear in the old\n  // state.\n  // Then, once we have the items that should not move, we walk through the new\n  // results array group-by-group, where a \"group\" is a set of items that have\n  // moved, anchored on the end by an item that should not move.  One by one, we\n  // move each of those elements into place \"before\" the anchoring end-of-group\n  // item, and fire changed events on them if necessary.  Then we fire a changed\n  // event on the anchor, and move on to the next group.  There is always at\n  // least one group; the last group is anchored by a virtual \"null\" id at the\n  // end.\n  // Asymptotically: O(N k) where k is number of ops, or potentially\n  // O(N log N) if inner loop of LCS were made to be binary search.\n  //////// LCS (longest common sequence, with respect to _id)\n  // (see Wikipedia article on Longest Increasing Subsequence,\n  // where the LIS is taken of the sequence of old indices of the\n  // docs in new_results)\n  //\n  // unmoved: the output of the algorithm; members of the LCS,\n  // in the form of indices into new_results\n\n  var unmoved = []; // max_seq_len: length of LCS found so far\n\n  var max_seq_len = 0; // seq_ends[i]: the index into new_results of the last doc in a\n  // common subsequence of length of i+1 <= max_seq_len\n\n  var N = new_results.length;\n  var seq_ends = new Array(N); // ptrs:  the common subsequence ending with new_results[n] extends\n  // a common subsequence ending with new_results[ptr[n]], unless\n  // ptr[n] is -1.\n\n  var ptrs = new Array(N); // virtual sequence of old indices of new results\n\n  var old_idx_seq = function (i_new) {\n    return old_index_of_id[new_results[i_new]._id];\n  }; // for each item in new_results, use it to extend a common subsequence\n  // of length j <= max_seq_len\n\n\n  for (var i = 0; i < N; i++) {\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\n      var j = max_seq_len; // this inner loop would traditionally be a binary search,\n      // but scanning backwards we will likely find a subseq to extend\n      // pretty soon, bounded for example by the total number of ops.\n      // If this were to be changed to a binary search, we'd still want\n      // to scan backwards a bit as an optimization.\n\n      while (j > 0) {\n        if (old_idx_seq(seq_ends[j - 1]) < old_idx_seq(i)) break;\n        j--;\n      }\n\n      ptrs[i] = j === 0 ? -1 : seq_ends[j - 1];\n      seq_ends[j] = i;\n      if (j + 1 > max_seq_len) max_seq_len = j + 1;\n    }\n  } // pull out the LCS/LIS into unmoved\n\n\n  var idx = max_seq_len === 0 ? -1 : seq_ends[max_seq_len - 1];\n\n  while (idx >= 0) {\n    unmoved.push(idx);\n    idx = ptrs[idx];\n  } // the unmoved item list is built backwards, so fix that\n\n\n  unmoved.reverse(); // the last group is always anchored by the end of the result list, which is\n  // an id of \"null\"\n\n  unmoved.push(new_results.length);\n  old_results.forEach(function (doc) {\n    if (!new_presence_of_id[doc._id]) observer.removed && observer.removed(doc._id);\n  }); // for each group of things in the new_results that is anchored by an unmoved\n  // element, iterate through the things before it.\n\n  var startOfGroup = 0;\n  unmoved.forEach(function (endOfGroup) {\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\n\n    for (var i = startOfGroup; i < endOfGroup; i++) {\n      newDoc = new_results[i];\n\n      if (!hasOwn.call(old_index_of_id, newDoc._id)) {\n        fields = projectionFn(newDoc);\n        delete fields._id;\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n        observer.added && observer.added(newDoc._id, fields);\n      } else {\n        // moved\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\n        projectedNew = projectionFn(newDoc);\n        projectedOld = projectionFn(oldDoc);\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n        if (!isObjEmpty(fields)) {\n          observer.changed && observer.changed(newDoc._id, fields);\n        }\n\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n      }\n    }\n\n    if (groupId) {\n      newDoc = new_results[endOfGroup];\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\n      projectedNew = projectionFn(newDoc);\n      projectedOld = projectionFn(oldDoc);\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n      if (!isObjEmpty(fields)) {\n        observer.changed && observer.changed(newDoc._id, fields);\n      }\n    }\n\n    startOfGroup = endOfGroup + 1;\n  });\n}; // General helper for diff-ing two objects.\n// callbacks is an object like so:\n// { leftOnly: function (key, leftValue) {...},\n//   rightOnly: function (key, rightValue) {...},\n//   both: function (key, leftValue, rightValue) {...},\n// }\n\n\nDiffSequence.diffObjects = function (left, right, callbacks) {\n  Object.keys(left).forEach(key => {\n    const leftValue = left[key];\n\n    if (hasOwn.call(right, key)) {\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\n    } else {\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n    }\n  });\n\n  if (callbacks.rightOnly) {\n    Object.keys(right).forEach(key => {\n      const rightValue = right[key];\n\n      if (!hasOwn.call(left, key)) {\n        callbacks.rightOnly(key, rightValue);\n      }\n    });\n  }\n};\n\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n  var fields = {};\n  DiffSequence.diffObjects(oldDoc, newDoc, {\n    leftOnly: function (key, value) {\n      fields[key] = undefined;\n    },\n    rightOnly: function (key, value) {\n      fields[key] = value;\n    },\n    both: function (key, leftValue, rightValue) {\n      if (!EJSON.equals(leftValue, rightValue)) fields[key] = rightValue;\n    }\n  });\n  return fields;\n};\n\nDiffSequence.applyChanges = function (doc, changeFields) {\n  Object.keys(changeFields).forEach(key => {\n    const value = changeFields[key];\n\n    if (typeof value === \"undefined\") {\n      delete doc[key];\n    } else {\n      doc[key] = value;\n    }\n  });\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/diff-sequence/diff.js\");\n\n/* Exports */\nPackage._define(\"diff-sequence\", exports, {\n  DiffSequence: DiffSequence\n});\n\n})();\n","servePath":"/packages/diff-sequence.js","sourceMap":{"version":3,"sources":["packages/diff-sequence/diff.js"],"names":["module","export","DiffSequence","hasOwn","Object","prototype","hasOwnProperty","isObjEmpty","obj","key","call","diffQueryChanges","ordered","oldResults","newResults","observer","options","diffQueryOrderedChanges","diffQueryUnorderedChanges","projectionFn","EJSON","clone","movedBefore","Error","forEach","newDoc","id","oldDoc","get","changed","equals","projectedNew","projectedOld","changedFields","makeChangedFields","added","fields","_id","removed","has","old_results","new_results","new_presence_of_id","doc","Meteor","_debug","old_index_of_id","i","unmoved","max_seq_len","N","length","seq_ends","Array","ptrs","old_idx_seq","i_new","undefined","j","idx","push","reverse","startOfGroup","endOfGroup","groupId","addedBefore","diffObjects","left","right","callbacks","keys","leftValue","both","leftOnly","rightOnly","rightValue","value","applyChanges","changeFields"],"mappings":"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","file":"/packages/diff-sequence.js","sourcesContent":["export const DiffSequence = {};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isObjEmpty(obj) {\n  for (let key in Object(obj)) {\n    if (hasOwn.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,\n                                              observer, options) {\n  if (ordered)\n    DiffSequence.diffQueryOrderedChanges(\n      oldResults, newResults, observer, options);\n  else\n    DiffSequence.diffQueryUnorderedChanges(\n      oldResults, newResults, observer, options);\n};\n\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,\n                                                       observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  if (observer.movedBefore) {\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n  }\n\n  newResults.forEach(function (newDoc, id) {\n    var oldDoc = oldResults.get(id);\n    if (oldDoc) {\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n        var projectedNew = projectionFn(newDoc);\n        var projectedOld = projectionFn(oldDoc);\n        var changedFields =\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (! isObjEmpty(changedFields)) {\n          observer.changed(id, changedFields);\n        }\n      }\n    } else if (observer.added) {\n      var fields = projectionFn(newDoc);\n      delete fields._id;\n      observer.added(newDoc._id, fields);\n    }\n  });\n\n  if (observer.removed) {\n    oldResults.forEach(function (oldDoc, id) {\n      if (!newResults.has(id))\n        observer.removed(id);\n    });\n  }\n};\n\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,\n                                                     observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  var new_presence_of_id = {};\n  new_results.forEach(function (doc) {\n    if (new_presence_of_id[doc._id])\n      Meteor._debug(\"Duplicate _id in new_results\");\n    new_presence_of_id[doc._id] = true;\n  });\n\n  var old_index_of_id = {};\n  old_results.forEach(function (doc, i) {\n    if (doc._id in old_index_of_id)\n      Meteor._debug(\"Duplicate _id in old_results\");\n    old_index_of_id[doc._id] = i;\n  });\n\n  // ALGORITHM:\n  //\n  // To determine which docs should be considered \"moved\" (and which\n  // merely change position because of other docs moving) we run\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\n  // considered moved.\n\n  // To actually call the appropriate callbacks to get from the old state to the\n  // new state:\n\n  // First, we call removed() on all the items that only appear in the old\n  // state.\n\n  // Then, once we have the items that should not move, we walk through the new\n  // results array group-by-group, where a \"group\" is a set of items that have\n  // moved, anchored on the end by an item that should not move.  One by one, we\n  // move each of those elements into place \"before\" the anchoring end-of-group\n  // item, and fire changed events on them if necessary.  Then we fire a changed\n  // event on the anchor, and move on to the next group.  There is always at\n  // least one group; the last group is anchored by a virtual \"null\" id at the\n  // end.\n\n  // Asymptotically: O(N k) where k is number of ops, or potentially\n  // O(N log N) if inner loop of LCS were made to be binary search.\n\n\n  //////// LCS (longest common sequence, with respect to _id)\n  // (see Wikipedia article on Longest Increasing Subsequence,\n  // where the LIS is taken of the sequence of old indices of the\n  // docs in new_results)\n  //\n  // unmoved: the output of the algorithm; members of the LCS,\n  // in the form of indices into new_results\n  var unmoved = [];\n  // max_seq_len: length of LCS found so far\n  var max_seq_len = 0;\n  // seq_ends[i]: the index into new_results of the last doc in a\n  // common subsequence of length of i+1 <= max_seq_len\n  var N = new_results.length;\n  var seq_ends = new Array(N);\n  // ptrs:  the common subsequence ending with new_results[n] extends\n  // a common subsequence ending with new_results[ptr[n]], unless\n  // ptr[n] is -1.\n  var ptrs = new Array(N);\n  // virtual sequence of old indices of new results\n  var old_idx_seq = function(i_new) {\n    return old_index_of_id[new_results[i_new]._id];\n  };\n  // for each item in new_results, use it to extend a common subsequence\n  // of length j <= max_seq_len\n  for(var i=0; i<N; i++) {\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\n      var j = max_seq_len;\n      // this inner loop would traditionally be a binary search,\n      // but scanning backwards we will likely find a subseq to extend\n      // pretty soon, bounded for example by the total number of ops.\n      // If this were to be changed to a binary search, we'd still want\n      // to scan backwards a bit as an optimization.\n      while (j > 0) {\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))\n          break;\n        j--;\n      }\n\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);\n      seq_ends[j] = i;\n      if (j+1 > max_seq_len)\n        max_seq_len = j+1;\n    }\n  }\n\n  // pull out the LCS/LIS into unmoved\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);\n  while (idx >= 0) {\n    unmoved.push(idx);\n    idx = ptrs[idx];\n  }\n  // the unmoved item list is built backwards, so fix that\n  unmoved.reverse();\n\n  // the last group is always anchored by the end of the result list, which is\n  // an id of \"null\"\n  unmoved.push(new_results.length);\n\n  old_results.forEach(function (doc) {\n    if (!new_presence_of_id[doc._id])\n      observer.removed && observer.removed(doc._id);\n  });\n\n  // for each group of things in the new_results that is anchored by an unmoved\n  // element, iterate through the things before it.\n  var startOfGroup = 0;\n  unmoved.forEach(function (endOfGroup) {\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\n    for (var i = startOfGroup; i < endOfGroup; i++) {\n      newDoc = new_results[i];\n      if (!hasOwn.call(old_index_of_id, newDoc._id)) {\n        fields = projectionFn(newDoc);\n        delete fields._id;\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n        observer.added && observer.added(newDoc._id, fields);\n      } else {\n        // moved\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\n        projectedNew = projectionFn(newDoc);\n        projectedOld = projectionFn(oldDoc);\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (!isObjEmpty(fields)) {\n          observer.changed && observer.changed(newDoc._id, fields);\n        }\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n      }\n    }\n    if (groupId) {\n      newDoc = new_results[endOfGroup];\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\n      projectedNew = projectionFn(newDoc);\n      projectedOld = projectionFn(oldDoc);\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n      if (!isObjEmpty(fields)) {\n        observer.changed && observer.changed(newDoc._id, fields);\n      }\n    }\n    startOfGroup = endOfGroup+1;\n  });\n\n\n};\n\n\n// General helper for diff-ing two objects.\n// callbacks is an object like so:\n// { leftOnly: function (key, leftValue) {...},\n//   rightOnly: function (key, rightValue) {...},\n//   both: function (key, leftValue, rightValue) {...},\n// }\nDiffSequence.diffObjects = function (left, right, callbacks) {\n  Object.keys(left).forEach(key => {\n    const leftValue = left[key];\n    if (hasOwn.call(right, key)) {\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\n    } else {\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n    }\n  });\n\n  if (callbacks.rightOnly) {\n    Object.keys(right).forEach(key => {\n      const rightValue = right[key];\n      if (! hasOwn.call(left, key)) {\n        callbacks.rightOnly(key, rightValue);\n      }\n    });\n  }\n};\n\n\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n  var fields = {};\n  DiffSequence.diffObjects(oldDoc, newDoc, {\n    leftOnly: function (key, value) {\n      fields[key] = undefined;\n    },\n    rightOnly: function (key, value) {\n      fields[key] = value;\n    },\n    both: function (key, leftValue, rightValue) {\n      if (!EJSON.equals(leftValue, rightValue))\n        fields[key] = rightValue;\n    }\n  });\n  return fields;\n};\n\nDiffSequence.applyChanges = function (doc, changeFields) {\n  Object.keys(changeFields).forEach(key => {\n    const value = changeFields[key];\n    if (typeof value === \"undefined\") {\n      delete doc[key];\n    } else {\n      doc[key] = value;\n    }\n  });\n};\n\n"]}}]