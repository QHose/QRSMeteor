[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\n\n/* Package-scope variables */\nvar getFilterQuery, ReactiveTable, dependOnFilters, getFilterStrings, getFilterFields;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/aslagle_reactive-table/lib/filter.js                                                               //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nvar parseFilterString = function (filterString) {\n  var startQuoteRegExp = /^[\\'\\\"]/;\n  var endQuoteRegExp = /[\\'\\\"]$/;\n  var filters = [];\n  var words = filterString.split(' ');\n\n  var inQuote = false;\n  var quotedWord = '';\n  _.each(words, function (word) {\n    if (inQuote) {\n      if (endQuoteRegExp.test(word)) {\n        filters.push(quotedWord + ' ' + word.slice(0, word.length - 1));\n        inQuote = false;\n        quotedWord = '';\n      } else {\n        quotedWord = quotedWord + ' ' + word;\n      }\n    } else if (startQuoteRegExp.test(word)) {\n      if (endQuoteRegExp.test(word)) {\n        filters.push(word.slice(1, word.length - 1));\n      } else {\n        inQuote = true;\n        quotedWord = word.slice(1, word.length);\n      }\n    } else {\n      filters.push(word);\n    }\n  });\n  return filters;\n};\n\nvar escapeRegex = function(text) {\n  return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n};\n\nvar getFieldMatches = function (field) {\n  var fieldMatches = [];\n  var keys = field.split('.');\n  var previousKeys = '';\n  _.each(keys, function (key) {\n    fieldMatches.push(previousKeys + key);\n    previousKeys += key + '.';\n  });\n  var extraMatch = field.replace(/\\.\\d+\\./g, \".\");\n  if (fieldMatches.indexOf(extraMatch) === -1) fieldMatches.push(extraMatch);\n  return fieldMatches;\n};\n\ngetFilterQuery = function (filterInputs, filterFields, settings) {\n  settings = settings || {};\n  if (settings.enableRegex === undefined) {\n    settings.enableRegex = false;\n  }\n  if (settings.filterOperator === undefined) {\n    settings.filterOperator = \"$and\";\n  }\n  if (settings.fields) {\n    _.each(filterInputs, function (filter, index) {\n      if (_.any(settings.fields, function (include) { return include; })) {\n        filterFields[index] = _.filter(filterFields[index], function (field) {\n          return _.any(getFieldMatches(field), function (fieldMatch) {\n            // ensure that the _id field is filtered on, even if it is not explicitly mentioned\n            if (fieldMatch === \"_id\") return true;\n            return settings.fields[fieldMatch];\n          });\n        });\n      } else {\n        filterFields[index] = _.filter(filterFields[index], function (field) {\n          return _.all(getFieldMatches(field), function (fieldMatch) {\n            return _.isUndefined(settings.fields[fieldMatch]) || settings.fields[fieldMatch];\n          });\n        });\n      }\n    });\n  }\n  var numberRegExp = /^\\d+$/;\n  var queryList = [];\n  _.each(filterInputs, function (filter, index) {\n    if (filter) {\n      if (_.isObject(filter)) {\n        var fieldQueries = _.map(filterFields[index], function (field) {\n          var query = {};\n          query[field] = filter;\n          return query;\n        });\n        if (fieldQueries.length) {\n            queryList.push({'$or': fieldQueries});\n          }\n      } else {\n        var filters = parseFilterString(filter);\n        _.each(filters, function (filterWord) {\n          if (settings.enableRegex === false) {\n            filterWord = escapeRegex(filterWord);\n          }\n          var filterQueryList = [];\n          _.each(filterFields[index], function (field) {\n            var filterRegExp = new RegExp(filterWord, 'i');\n            var query = {};\n            query[field] = filterRegExp;\n            filterQueryList.push(query);\n\n            if (numberRegExp.test(filterWord)) {\n              var numberQuery = {};\n              numberQuery[field] = parseInt(filterWord, 10);\n              filterQueryList.push(numberQuery);\n            }\n\n            if (filterWord === \"true\") {\n              var boolQuery = {};\n              boolQuery[field] = true;\n              filterQueryList.push(boolQuery);\n            } else if (filterWord === \"false\") {\n              var boolQuery = {};\n              boolQuery[field] = false;\n              filterQueryList.push(boolQuery);\n            }\n          });\n\n          if (filterQueryList.length) {\n            var filterQuery = {'$or': filterQueryList};\n            queryList.push(filterQuery);\n          }\n        });\n      }\n    }\n  });\n\n  var query = {};\n\n  if(queryList.length) {\n    query[settings.filterOperator] = queryList;\n  }\n\n  return query;\n};\n\nif (Meteor.isClient) {\n  ReactiveTable = ReactiveTable || {};\n\n  var reactiveTableFilters = {};\n  var callbacks = {};\n\n  ReactiveTable.Filter = function (id, fields) {\n    if (reactiveTableFilters[id]) {\n      reactiveTableFilters[id].fields = fields;\n      return reactiveTableFilters[id];\n    }\n\n    var filter = new ReactiveVar();\n\n    this.fields = fields;\n\n    this.get = function () {\n      return filter.get() || '';\n    };\n\n    this.set = function (filterString) {\n      filter.set(filterString);\n      _.each(callbacks[id], function (callback) {\n        callback();\n      });\n    };\n\n    reactiveTableFilters[id] = this;\n  };\n\n  ReactiveTable.clearFilters = function (filterIds) {\n    _.each(filterIds, function (filterId) {\n      if (reactiveTableFilters[filterId]) {\n        reactiveTableFilters[filterId].set('');\n      }\n    });\n  };\n\n  dependOnFilters = function (filterIds, callback) {\n    _.each(filterIds, function (filterId) {\n      if (_.isUndefined(callbacks[filterId])) {\n        callbacks[filterId] = [];\n      }\n      callbacks[filterId].push(callback);\n    });\n  };\n\n  getFilterStrings = function (filterIds) {\n    return _.map(filterIds, function (filterId) {\n      if (_.isUndefined(reactiveTableFilters[filterId])) {\n        reactiveTableFilters[filterId] = new ReactiveTable.Filter(filterId);\n      }\n      return reactiveTableFilters[filterId].get();\n    });\n  };\n\n  getFilterFields = function (filterIds, allFields) {\n    return _.map(filterIds, function (filterId) {\n      if (_.isUndefined(reactiveTableFilters[filterId])) {\n        return _.map(allFields, function (field) { return field.key; });\n      } else if (_.isEmpty(reactiveTableFilters[filterId].fields)) {\n        return _.map(allFields, function (field) { return field.key; });\n      } else {\n        return reactiveTableFilters[filterId].fields;\n      }\n    });\n  };\n\n  Template.reactiveTableFilter.helpers({\n    'class': function () {\n      return this.class || 'input-group';\n    },\n\n    'filter': function () {\n      if (_.isUndefined(reactiveTableFilters[this.id])) {\n        new ReactiveTable.Filter(this.id, this.fields);\n      } else if (_.isUndefined(reactiveTableFilters[this.id].fields)) {\n        reactiveTableFilters[this.id].fields = this.fields;\n      }\n      return reactiveTableFilters[this.id].get();\n    }\n  });\n\n  var updateFilter = _.debounce(function (template, filterText) {\n    reactiveTableFilters[template.data.id].set(filterText);\n  }, 200);\n\n  Template.reactiveTableFilter.events({\n    'keyup .reactive-table-input, input .reactive-table-input': function (event) {\n      var template = Template.instance();\n      var filterText = $(event.target).val();\n      updateFilter(template, filterText);\n    },\n  });\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/aslagle_reactive-table/lib/server.js                                                               //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nReactiveTable = {};\n\nReactiveTable.publish = function (name, collectionOrFunction, selectorOrFunction, settings) {\n    Meteor.publish(\"reactive-table-\" + name, function (publicationId, filters, fields, options, rowsPerPage) {\n      check(publicationId, String);\n      check(filters, [Match.OneOf(String, Object, Mongo.ObjectID)]);\n      check(fields, [[String]]);\n      check(options, {skip: Match.Integer, limit: Match.Integer, sort: Object});\n      check(rowsPerPage, Match.Integer);\n\n      var collection;\n      var selector;\n\n      if (_.isFunction(collectionOrFunction)) {\n        collection = collectionOrFunction.call(this);\n      } else {\n        collection = collectionOrFunction;\n      }\n\n      if (!(collection instanceof Mongo.Collection)) {\n        console.log(\"ReactiveTable.publish: no collection to publish\");\n        return [];\n      }\n\n      if (_.isFunction(selectorOrFunction)) {\n        selector = selectorOrFunction.call(this);\n      } else {\n        selector = selectorOrFunction;\n      }\n      var self = this;\n      var filterQuery = _.extend(getFilterQuery(filters, fields, settings), selector);\n      if (settings && settings.fields) {\n        options.fields = settings.fields;\n      }\n      var pageCursor = collection.find(filterQuery, options);\n      var fullCursor = collection.find(filterQuery);\n      var count = fullCursor.count();\n\n      var getRow = function (row, index) {\n        return _.extend({\n          \"reactive-table-id\": publicationId,\n          \"reactive-table-sort\": index\n        }, row);\n      };\n\n      var getRows = function () {\n        return _.map(pageCursor.fetch(), getRow);\n      };\n      var rows = {};\n      _.each(getRows(), function (row) {\n        rows[row._id] = row;\n      });\n\n      var updateRows = function () {\n        var newRows = getRows();\n        _.each(newRows, function (row, index) {\n          var oldRow = rows[row._id];\n          if (oldRow) {\n            if (!_.isEqual(oldRow, row)) {\n              self.changed(\"reactive-table-rows-\" + publicationId, row._id, row);\n              rows[row._id] = row;\n            }\n          } else {\n            self.added(\"reactive-table-rows-\" + publicationId, row._id, row);\n            rows[row._id] = row;\n          }\n        });\n      };\n\n      self.added(\"reactive-table-counts\", publicationId, {count: count});\n      _.each(rows, function (row) {\n        self.added(\"reactive-table-rows-\" + publicationId, row._id, row);\n      });\n\n      if (!(settings || {}).disableRowReactivity) {\n        var initializing = true;\n\n        var handle = pageCursor.observeChanges({\n          added: function (id, fields) {\n            if (!initializing) {\n              updateRows();\n            }\n          },\n\n          removed: function (id, fields) {\n            self.removed(\"reactive-table-rows-\" + publicationId, id);\n            delete rows[id];\n            updateRows();\n          },\n\n          changed: function (id, fields) {\n            updateRows();\n          }\n\n        });\n      }\n\n      if (!(settings || {}).disablePageCountReactivity) {\n        var countHandle = fullCursor.observeChanges({\n          added: function (id, fields) {\n            if (!initializing) {\n              self.changed(\"reactive-table-counts\", publicationId, {count: fullCursor.count()});\n            }\n          },\n\n          removed: function (id, fields) {\n            self.changed(\"reactive-table-counts\", publicationId, {count: fullCursor.count()});\n          }\n        });\n      }\n      initializing = false;\n\n      self.ready();\n\n      self.onStop(function () {\n        if (handle) handle.stop();\n        if (countHandle) countHandle.stop();\n      });\n    });\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"aslagle:reactive-table\", {\n  ReactiveTable: ReactiveTable\n});\n\n})();\n","servePath":"/packages/aslagle_reactive-table.js"}]