[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Accounts = Package['accounts-base'].Accounts;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\n\n/* Package-scope variables */\nvar Roles;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/alanning_roles/roles_common.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n;(function () {\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * @module Roles\n */\n\n/**\n * Roles collection documents consist only of an id and a role name.\n *   ex: { _id:<uuid>, name: \"admin\" }\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection(\"roles\")\n}\n\n/**\n * Authorization package compatible with built-in Meteor accounts system.\n *\n * Stores user's current roles in a 'roles' field on the user object.\n *\n * @class Roles\n * @constructor\n */\nif ('undefined' === typeof Roles) {\n  Roles = {}\n}\n\n\"use strict\";\n\nvar mixingGroupAndNonGroupErrorMsg = \"Roles error: Can't mix grouped and non-grouped roles for same user\";\n\n_.extend(Roles, {\n\n  /**\n   * Constant used to reference the special 'global' group that \n   * can be used to apply blanket permissions across all groups.\n   *\n   * @example\n   *     Roles.addUsersToRoles(user, 'admin', Roles.GLOBAL_GROUP)\n   *     Roles.userIsInRole(user, 'admin') // => true\n   *\n   *     Roles.setUserRoles(user, 'support-staff', Roles.GLOBAL_GROUP)\n   *     Roles.userIsInRole(user, 'support-staff') // => true\n   *     Roles.userIsInRole(user, 'admin') // => false\n   *\n   * @property GLOBAL_GROUP\n   * @type String\n   * @static\n   * @final\n   */\n  GLOBAL_GROUP: '__global_roles__',\n\n\n  /**\n   * Create a new role. Whitespace will be trimmed.\n   *\n   * @method createRole\n   * @param {String} role Name of role\n   * @return {String} id of new role\n   */\n  createRole: function (role) {\n    var id,\n        match\n\n    if (!role\n        || 'string' !== typeof role\n        || role.trim().length === 0) {\n      return\n    }\n\n    try {\n      id = Meteor.roles.insert({'name': role.trim()})\n      return id\n    } catch (e) {\n      // (from Meteor accounts-base package, insertUserDoc func)\n      // XXX string parsing sucks, maybe\n      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n      if (/E11000 duplicate key error.*(index.*roles|roles.*index).*name/.test(e.err || e.errmsg)) {\n        throw new Error(\"Role '\" + role.trim() + \"' already exists.\")\n      }\n      else {\n        throw e\n      }\n    }\n  },\n\n  /**\n   * Delete an existing role.  Will throw \"Role in use\" error if any users\n   * are currently assigned to the target role.\n   *\n   * @method deleteRole\n   * @param {String} role Name of role\n   */\n  deleteRole: function (role) {\n    if (!role) return\n\n    var foundExistingUser = Meteor.users.findOne(\n                              {roles: {$in: [role]}},\n                              {fields: {_id: 1}})\n\n    if (foundExistingUser) {\n      throw new Meteor.Error(403, 'Role in use')\n    }\n\n    var thisRole = Meteor.roles.findOne({name: role})\n    if (thisRole) {\n      Meteor.roles.remove({_id: thisRole._id})\n    }\n  },\n\n  /**\n   * Add users to roles. Will create roles as needed.\n   *\n   * NOTE: Mixing grouped and non-grouped roles for the same user\n   *       is not supported and will throw an error.\n   *\n   * Makes 2 calls to database:\n   *  1. retrieve list of all existing roles\n   *  2. update users' roles\n   *\n   * @example\n   *     Roles.addUsersToRoles(userId, 'admin')\n   *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *     Roles.addUsersToRoles(userId, 'admin', Roles.GLOBAL_GROUP)\n   *\n   * @method addUsersToRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles/permissions to add users to\n   * @param {String} [group] Optional group name. If supplied, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with a '$' or contain\n   *                         null characters.  Periods in names '.' are\n   *                         automatically converted to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   */\n  addUsersToRoles: function (users, roles, group) {\n    // use Template pattern to update user roles\n    Roles._updateUserRoles(users, roles, group, Roles._update_$addToSet_fn)\n  },\n\n  /**\n   * Set a users roles/permissions.\n   *\n   * @example\n   *     Roles.setUserRoles(userId, 'admin')\n   *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.setUserRoles([user1, user2], ['user','editor'])\n   *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *     Roles.setUserRoles(userId, 'admin', Roles.GLOBAL_GROUP)\n   *\n   * @method setUserRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles/permissions to add users to\n   * @param {String} [group] Optional group name. If supplied, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with '$'.\n   *                         Periods in names '.' are automatically converted\n   *                         to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   */\n  setUserRoles: function (users, roles, group) {\n    // use Template pattern to update user roles\n    Roles._updateUserRoles(users, roles, group, Roles._update_$set_fn)\n  },\n\n  /**\n   * Remove users from roles\n   *\n   * @example\n   *     Roles.removeUsersFromRoles(users.bob, 'admin')\n   *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor'])\n   *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor', 'user'])\n   *     Roles.removeUsersFromRoles(users.eve, ['user'], 'group1')\n   *\n   * @method removeUsersFromRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles to remove users from\n   * @param {String} [group] Optional. Group name. If supplied, only that\n   *                         group will have roles removed.\n   */\n  removeUsersFromRoles: function (users, roles, group) {\n    var update\n\n    if (!users) throw new Error (\"Missing 'users' param\")\n    if (!roles) throw new Error (\"Missing 'roles' param\")\n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    // ensure arrays\n    if (!_.isArray(users)) users = [users]\n    if (!_.isArray(roles)) roles = [roles]\n\n    // ensure users is an array of user ids\n    users = _.reduce(users, function (memo, user) {\n      var _id\n      if ('string' === typeof user) {\n        memo.push(user)\n      } else if ('object' === typeof user) {\n        _id = user._id\n        if ('string' === typeof _id) {\n          memo.push(_id)\n        }\n      }\n      return memo\n    }, [])\n\n    // update all users, remove from roles set\n    \n    if (group) {\n      update = {$pullAll: {}}\n      update.$pullAll['roles.'+group] = roles\n    } else {\n      update = {$pullAll: {roles: roles}}\n    }\n\n    try {\n      if (Meteor.isClient) {\n        // Iterate over each user to fulfill Meteor's 'one update per ID' policy\n        _.each(users, function (user) {\n          Meteor.users.update({_id:user}, update)\n        })\n      } else {\n        // On the server we can leverage MongoDB's $in operator for performance\n        Meteor.users.update({_id:{$in:users}}, update, {multi: true})\n      }\n    }\n    catch (ex) {\n      if (ex.name === 'MongoError' && isMongoMixError(ex.err || ex.errmsg)) {\n        throw new Error (mixingGroupAndNonGroupErrorMsg)\n      }\n\n      throw ex\n    }\n  },\n\n  /**\n   * Check if user has specified permissions/roles\n   *\n   * @example\n   *     // non-group usage\n   *     Roles.userIsInRole(user, 'admin')\n   *     Roles.userIsInRole(user, ['admin','editor'])\n   *     Roles.userIsInRole(userId, 'admin')\n   *     Roles.userIsInRole(userId, ['admin','editor'])\n   *\n   *     // per-group usage\n   *     Roles.userIsInRole(user,   ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], Roles.GLOBAL_GROUP)\n   *\n   *     // this format can also be used as short-hand for Roles.GLOBAL_GROUP\n   *     Roles.userIsInRole(user, 'admin')\n   *    \n   * @method userIsInRole\n   * @param {String|Object} user User Id or actual user object\n   * @param {String|Array} roles Name of role/permission or Array of \n   *                            roles/permissions to check against.  If array, \n   *                            will return true if user is in _any_ role.\n   * @param {String} [group] Optional. Name of group.  If supplied, limits check\n   *                         to just that group.\n   *                         The user's Roles.GLOBAL_GROUP will always be checked\n   *                         whether group is specified or not.  \n   * @return {Boolean} true if user is in _any_ of the target roles\n   */\n  userIsInRole: function (user, roles, group) {\n    var id,\n        userRoles,\n        query,\n        groupQuery,\n        found = false\n\n    // ensure array to simplify code\n    if (!_.isArray(roles)) {\n      roles = [roles]\n    }\n\n    if (!user) return false\n    if (group) {\n      if ('string' !== typeof group) return false\n      if ('$' === group[0]) return false\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n    \n    if ('object' === typeof user) {\n      userRoles = user.roles\n      if (_.isArray(userRoles)) {\n        return _.some(roles, function (role) {\n          return _.contains(userRoles, role)\n        })\n      } else if (userRoles && 'object' === typeof userRoles) {\n        // roles field is dictionary of groups\n        found = _.isArray(userRoles[group]) && _.some(roles, function (role) {\n          return _.contains(userRoles[group], role)\n        })\n        if (!found) {\n          // not found in regular group or group not specified.  \n          // check Roles.GLOBAL_GROUP, if it exists\n          found = _.isArray(userRoles[Roles.GLOBAL_GROUP]) && _.some(roles, function (role) {\n            return _.contains(userRoles[Roles.GLOBAL_GROUP], role)\n          })\n        }\n        return found\n      }\n\n      // missing roles field, try going direct via id\n      id = user._id\n    } else if ('string' === typeof user) {\n      id = user\n    }\n\n    if (!id) return false\n\n\n    query = {_id: id, $or: []}\n\n    // always check Roles.GLOBAL_GROUP\n    groupQuery = {}\n    groupQuery['roles.'+Roles.GLOBAL_GROUP] = {$in: roles}\n    query.$or.push(groupQuery)\n\n    if (group) {\n      // structure of query, when group specified including Roles.GLOBAL_GROUP \n      //   {_id: id, \n      //    $or: [\n      //      {'roles.group1':{$in: ['admin']}},\n      //      {'roles.__global_roles__':{$in: ['admin']}}\n      //    ]}\n      groupQuery = {}\n      groupQuery['roles.'+group] = {$in: roles}\n      query.$or.push(groupQuery)\n    } else {\n      // structure of query, where group not specified. includes \n      // Roles.GLOBAL_GROUP \n      //   {_id: id, \n      //    $or: [\n      //      {roles: {$in: ['admin']}},\n      //      {'roles.__global_roles__': {$in: ['admin']}}\n      //    ]}\n      query.$or.push({roles: {$in: roles}})\n    }\n\n    found = Meteor.users.findOne(query, {fields: {_id: 1}})\n    return found ? true : false\n  },\n\n  /**\n   * Retrieve users roles\n   *\n   * @method getRolesForUser\n   * @param {String|Object} user User Id or actual user object\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User's Roles.GLOBAL_GROUP will also be included.\n   * @return {Array} Array of user's roles, unsorted.\n   */\n  getRolesForUser: function (user, group) {\n    if (!user) return []\n    if (group) {\n      if ('string' !== typeof group) return []\n      if ('$' === group[0]) return []\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    if ('string' === typeof user) {\n      user = Meteor.users.findOne(\n               {_id: user},\n               {fields: {roles: 1}})\n\n    } else if ('object' !== typeof user) {\n      // invalid user object\n      return []\n    }\n\n    if (!user || !user.roles) return []\n\n    if (group) {\n      return _.union(user.roles[group] || [], user.roles[Roles.GLOBAL_GROUP] || [])\n    }\n\n    if (_.isArray(user.roles))\n      return user.roles\n\n    // using groups but group not specified. return global group, if exists\n    return user.roles[Roles.GLOBAL_GROUP] || []\n  },\n\n  /**\n   * Retrieve set of all existing roles\n   *\n   * @method getAllRoles\n   * @return {Cursor} cursor of existing roles\n   */\n  getAllRoles: function () {\n    return Meteor.roles.find({}, {sort: {name: 1}})\n  },\n\n  /**\n   * Retrieve all users who are in target role.  \n   *\n   * NOTE: This is an expensive query; it performs a full collection scan\n   * on the users collection since there is no index set on the 'roles' field.  \n   * This is by design as most queries will specify an _id so the _id index is \n   * used automatically.\n   *\n   * @method getUsersInRole\n   * @param {Array|String} role Name of role/permission.  If array, users \n   *                            returned will have at least one of the roles\n   *                            specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User's Roles.GLOBAL_GROUP will also be checked.\n   * @param {Object} [options] Optional options which are passed directly\n   *                           through to `Meteor.users.find(query, options)`\n   * @return {Cursor} cursor of users in role\n   */\n  getUsersInRole: function (role, group, options) {\n    var query,\n        roles = role,\n        groupQuery\n\n    // ensure array to simplify query logic\n    if (!_.isArray(roles)) roles = [roles]\n    \n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    query = {$or: []}\n\n    // always check Roles.GLOBAL_GROUP\n    groupQuery = {}\n    groupQuery['roles.'+Roles.GLOBAL_GROUP] = {$in: roles}\n    query.$or.push(groupQuery)\n\n    if (group) {\n      // structure of query, when group specified including Roles.GLOBAL_GROUP \n      //   {\n      //    $or: [\n      //      {'roles.group1':{$in: ['admin']}},\n      //      {'roles.__global_roles__':{$in: ['admin']}}\n      //    ]}\n      groupQuery = {}\n      groupQuery['roles.'+group] = {$in: roles}\n      query.$or.push(groupQuery)\n    } else {\n      // structure of query, where group not specified. includes \n      // Roles.GLOBAL_GROUP \n      //   {\n      //    $or: [\n      //      {roles: {$in: ['admin']}},\n      //      {'roles.__global_roles__': {$in: ['admin']}}\n      //    ]}\n      query.$or.push({roles: {$in: roles}})\n    }\n\n    return Meteor.users.find(query, options);\n  },  // end getUsersInRole \n  \n  /**\n   * Retrieve users groups, if any\n   *\n   * @method getGroupsForUser\n   * @param {String|Object} user User Id or actual user object\n   * @param {String} [role] Optional name of roles to restrict groups to.\n   *\n   * @return {Array} Array of user's groups, unsorted. Roles.GLOBAL_GROUP will be omitted\n   */\n  getGroupsForUser: function (user, role) {\n    var userGroups = [];\n    \n    if (!user) return []\n    if (role) {\n      if ('string' !== typeof role) return []\n      if ('$' === role[0]) return []\n\n      // convert any periods to underscores\n      role = role.replace('.', '_')\n    }\n\n    if ('string' === typeof user) {\n      user = Meteor.users.findOne(\n               {_id: user},\n               {fields: {roles: 1}})\n    \n    }else if ('object' !== typeof user) {\n      // invalid user object\n      return []\n    }\n\n    //User has no roles or is not using groups\n    if (!user || !user.roles || _.isArray(user.roles)) return []\n\n    if (role) {\n      _.each(user.roles, function(groupRoles, groupName) {\n        if (_.contains(groupRoles, role) && groupName !== Roles.GLOBAL_GROUP) {\n          userGroups.push(groupName);\n        }\n      });\n      return userGroups;\n    }else {\n      return _.without(_.keys(user.roles), Roles.GLOBAL_GROUP);\n    }\n\n  }, //End getGroupsForUser\n\n\n  /**\n   * Private function 'template' that uses $set to construct an update object\n   * for MongoDB.  Passed to _updateUserRoles\n   *\n   * @method _update_$set_fn \n   * @protected\n   * @param {Array} roles\n   * @param {String} [group]\n   * @return {Object} update object for use in MongoDB update command\n   */\n  _update_$set_fn: function  (roles, group) {\n    var update = {}\n\n    if (group) {\n      // roles is a key/value dict object\n      update.$set = {}\n      update.$set['roles.' + group] = roles\n    } else {\n      // roles is an array of strings\n      update.$set = {roles: roles}\n    }\n\n    return update\n  },  // end _update_$set_fn \n\n  /**\n   * Private function 'template' that uses $addToSet to construct an update \n   * object for MongoDB.  Passed to _updateUserRoles\n   *\n   * @method _update_$addToSet_fn  \n   * @protected\n   * @param {Array} roles\n   * @param {String} [group]\n   * @return {Object} update object for use in MongoDB update command\n   */\n  _update_$addToSet_fn: function (roles, group) {\n    var update = {}\n\n    if (group) {\n      // roles is a key/value dict object\n      update.$addToSet = {}\n      update.$addToSet['roles.' + group] = {$each: roles}\n    } else {\n      // roles is an array of strings\n      update.$addToSet = {roles: {$each: roles}}\n    }\n\n    return update\n  },  // end _update_$addToSet_fn \n\n\n  /**\n   * Internal function that uses the Template pattern to adds or sets roles \n   * for users.\n   *\n   * @method _updateUserRoles\n   * @protected\n   * @param {Array|String} users user id(s) or object(s) with an _id field\n   * @param {Array|String} roles name(s) of roles/permissions to add users to\n   * @param {String} group Group name. If not null or undefined, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with '$'.\n   *                         Periods in names '.' are automatically converted\n   *                         to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   * @param {Function} updateFactory Func which returns an update object that\n   *                         will be passed to Mongo.\n   *   @param {Array} roles\n   *   @param {String} [group]\n   */\n  _updateUserRoles: function (users, roles, group, updateFactory) {\n    if (!users) throw new Error (\"Missing 'users' param\")\n    if (!roles) throw new Error (\"Missing 'roles' param\")\n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    var existingRoles,\n        query,\n        update\n\n    // ensure arrays to simplify code\n    if (!_.isArray(users)) users = [users]\n    if (!_.isArray(roles)) roles = [roles]\n\n    // remove invalid roles\n    roles = _.reduce(roles, function (memo, role) {\n      if (role\n          && 'string' === typeof role\n          && role.trim().length > 0) {\n        memo.push(role.trim())\n      }\n      return memo\n    }, [])\n\n    // empty roles array is ok, since it might be a $set operation to clear roles\n    //if (roles.length === 0) return\n\n    // ensure all roles exist in 'roles' collection\n    existingRoles = _.reduce(Meteor.roles.find({}).fetch(), function (memo, role) {\n      memo[role.name] = true\n      return memo\n    }, {})\n    _.each(roles, function (role) {\n      if (!existingRoles[role]) {\n        Roles.createRole(role)\n      }\n    })\n\n    // ensure users is an array of user ids\n    users = _.reduce(users, function (memo, user) {\n      var _id\n      if ('string' === typeof user) {\n        memo.push(user)\n      } else if ('object' === typeof user) {\n        _id = user._id\n        if ('string' === typeof _id) {\n          memo.push(_id)\n        }\n      }\n      return memo\n    }, [])\n    \n    // update all users\n    update = updateFactory(roles, group)\n    \n    try {\n      if (Meteor.isClient) {\n        // On client, iterate over each user to fulfill Meteor's \n        // 'one update per ID' policy\n        _.each(users, function (user) {\n          Meteor.users.update({_id: user}, update)\n        })\n      } else {\n        // On the server we can use MongoDB's $in operator for \n        // better performance\n        Meteor.users.update(\n          {_id: {$in: users}},\n          update,\n          {multi: true})\n      }\n    }\n    catch (ex) {\n      if (ex.name === 'MongoError' && isMongoMixError(ex.err || ex.errmsg)) {\n        throw new Error (mixingGroupAndNonGroupErrorMsg)\n      }\n\n      throw ex\n    }\n  }  // end _updateUserRoles\n\n})  // end _.extend(Roles ...)\n\n\nfunction isMongoMixError (errorMsg) {\n  var expectedMessages = [\n      'Cannot apply $addToSet modifier to non-array',\n      'Cannot apply $addToSet to a non-array field',\n      'Can only apply $pullAll to an array',\n      'Cannot apply $pull/$pullAll modifier to non-array',\n      \"can't append to array using string field name\",\n      'to traverse the element'\n      ]\n\n  return _.some(expectedMessages, function (snippet) {\n    return strContains(errorMsg, snippet)\n  })\n}\n\nfunction strContains (haystack, needle) {\n  return -1 !== haystack.indexOf(needle)\n}\n\n}());\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/alanning_roles/client/debug.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n\"use strict\"\n\n\n////////////////////////////////////////////////////////////\n// Debugging helpers\n//\n// Run this in your browser console to turn on debugging\n// for this package:\n//\n//   localstorage.setItem('Roles.debug', true)\n//\n\nRoles.debug = false\n\ntry {\n  if (localStorage) {\n    var temp = localStorage.getItem(\"Roles.debug\")\n\n    if ('undefined' !== typeof temp) {\n      Roles.debug = !!temp\n    }\n  }\n} catch (ex) {\n  // ignore: accessing localStorage when its disabled throws\n  // https://github.com/meteor/meteor/issues/5759\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/alanning_roles/client/uiHelpers.js                                                             //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n\"use strict\"\n\n/**\n * Convenience functions for use on client.\n *\n * NOTE: You must restrict user actions on the server-side; any\n * client-side checks are strictly for convenience and must not be\n * trusted.\n *\n * @module UIHelpers\n */\n\n\n////////////////////////////////////////////////////////////\n// UI helpers\n//\n// Use a semi-private variable rather than declaring UI\n// helpers directly so that we can unit test the helpers.\n// XXX For some reason, the UI helpers are not registered \n// before the tests run.\n//\nRoles._uiHelpers = {\n\n  /**\n   * UI helper to check if current user is in at least one\n   * of the target roles.  For use in client-side templates.\n   *\n   * @example\n   *     {{#if isInRole 'admin'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user' 'group1'}}\n   *     {{/if}}\n   *\n   * @method isInRole\n   * @param {String} role Name of role or comma-seperated list of roles\n   * @param {String} [group] Optional, name of group to check\n   * @return {Boolean} true if current user is in at least one of the target roles\n   * @static\n   * @for UIHelpers \n   */\n  isInRole: function (role, group) {\n    var user = Meteor.user(),\n        comma = (role || '').indexOf(','),\n        roles\n\n    if (!user) return false\n    if (!Match.test(role, String)) return false\n\n    if (comma !== -1) {\n      roles = _.reduce(role.split(','), function (memo, r) {\n        if (!r || !r.trim()) {\n          return memo\n        }\n        memo.push(r.trim())\n        return memo\n      }, [])\n    } else {\n      roles = [role]\n    }\n\n    if (Match.test(group, String)) {\n      return Roles.userIsInRole(user, roles, group)\n    }\n\n    return Roles.userIsInRole(user, roles)\n  }\n}\n\n\n\n////////////////////////////////////////////////////////////\n// Register UI helpers\n//\n\nif (Roles.debug && console.log) {\n  console.log(\"[roles] Roles.debug =\", Roles.debug)\n}\n\nif ('undefined' !== typeof Package.blaze &&\n    'undefined' !== typeof Package.blaze.Blaze &&\n    'function'  === typeof Package.blaze.Blaze.registerHelper) {\n  _.each(Roles._uiHelpers, function (func, name) {\n    if (Roles.debug && console.log) {\n      console.log(\"[roles] registering Blaze helper '\" + name + \"'\")\n    }\n    Package.blaze.Blaze.registerHelper(name, func) \n  })\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/alanning_roles/client/subscriptions.js                                                         //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n\"use strict\"\n\n\n/**\n * Subscription handle for the currently logged in user's permissions.\n *\n * NOTE: The corresponding publish function, `_roles`, depends on\n * `this.userId` so it will automatically re-run when the currently\n * logged-in user changes.\n *\n * @example\n *\n *     `Roles.subscription.ready()` // => `true` if user roles have been loaded\n *\n * @property subscription\n * @type Object\n * @for Roles\n */\n\nTracker.autorun(function () {\n  Roles.subscription = Meteor.subscribe(\"_roles\")\n})\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"alanning:roles\", {\n  Roles: Roles\n});\n\n})();\n","servePath":"/packages/alanning_roles.js"}]