[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Accounts = Package['accounts-base'].Accounts;\nvar Template = Package['templating-runtime'].Template;\nvar LoginState = Package['brettle:accounts-login-state'].LoginState;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar HTML = Package.htmljs.HTML;\nvar Spacebars = Package.spacebars.Spacebars;\n\n/* Package-scope variables */\nvar AccountsPatchUi;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/brettle_accounts-patch-ui/accounts-patch-ui.js                         //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n\"use strict\";\n/* globals AccountsPatchUi: true, LoginState */\n\n// Remember the official Meteor versions of the functions we will be\n// monkey patching.\nvar meteorUserIdFunc = Meteor.userId;\nvar meteorUserFunc = Meteor.user;\n\n// A version of Meteor.userId() that returns null for users who have not signed\n// up\nvar signedUpUserIdFunc = function() {\n  var meteorUserId = meteorUserIdFunc.call(Meteor);\n  if (!meteorUserId) {\n    return null;\n  }\n  var user = Meteor.users.findOne(meteorUserId);\n  if (!user) {\n    // Meteor.userId() was not null, but the userId wasn't found locally. That\n    // only happens before startup has finished and the Meteor.users\n    // subscription is not yet ready. So, just act like regular Meteor.userId()\n    // in this case (i.e. assume the user is signed up).\n    return meteorUserId;\n  }\n  if (LoginState.signedUp()) {\n    return meteorUserId;\n  }\n  return null;\n};\n\n// A version of Meteor.user() that returns null for user who have not signed up\nvar signedUpUserFunc = function() {\n  if (LoginState.signedUp()) {\n    return meteorUserFunc.call(Meteor);\n  }\n  return null;\n};\n\nfunction AccountsPatchUiConstructor() {\n}\n\n_.extend(AccountsPatchUiConstructor.prototype, {\n  /** Returns a function that will execute the passed function with a version\n   * `Meteor.userId()` and `Meteor.user()` that return null for users who have not\n   * signed up.\n   * @param {Function} func - the function to wrap.\n   * @returns {Function} - the wrapped function\n   */\n  wrapWithSignedUp: function(func) {\n    return function( /*arguments*/ ) {\n      var savedUserIdFunc = Meteor.userId;\n      var savedUserFunc = Meteor.user;\n      Meteor.userId = signedUpUserIdFunc;\n      Meteor.user = signedUpUserFunc;\n      try {\n        return func.apply(this, arguments);\n      } finally {\n        Meteor.userId = savedUserIdFunc;\n        Meteor.user = savedUserFunc;\n      }\n    };\n  },\n\n  _signedUpUser: signedUpUserFunc,\n\n  _wrapTemplateWithSignedUp: function(template) {\n    var self = this;\n    if (! template) {\n      return;\n    }\n    self._wrapMethodsWithSignedUp(template.__helpers);\n    if (! _.isArray(template.__eventMaps)) {\n      throw new TypeError('__eventMaps not an Array');\n    }\n    _.each(template.__eventMaps, function(value, index, eventMaps) {\n      self._wrapMethodsWithSignedUp(eventMaps[index]);\n    });\n  },\n\n  _wrapMethodsWithSignedUp: function(obj) {\n    if (obj === undefined) {\n      return;\n    }\n    if (! _.isObject(obj)) {\n      throw new TypeError('Not an object');\n    }\n    _.each(obj, function(value, key) {\n      if (_.isFunction(value)) {\n        obj[key] = AccountsPatchUi.wrapWithSignedUp(value);\n      }\n    });\n  }\n});\n\nAccountsPatchUi = new AccountsPatchUiConstructor();\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/brettle_accounts-patch-ui/patch-accounts-ui-unstyled.js                //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n\"use strict\";\n/* globals AccountsPatchUi */\n\nif (Package['accounts-ui-unstyled'] && Template.loginButtons) {\n  // Override global currentUser to hide users who are logged in but not\n  // signed up, just for this template.\n  Template.loginButtons.helpers({\n    currentUser: AccountsPatchUi.wrapWithSignedUp(function () {\n      return Meteor.user();\n    })\n  });\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/brettle_accounts-patch-ui/patch-ian_accounts-ui-bootstrap-3.js         //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n\"use strict\";\n/* globals AccountsPatchUi */\n\nif (Package['ian:accounts-ui-bootstrap-3'] && Template._loginButtons) {\n  // Override global currentUser to hide users who are logged in but not\n  // signed up, just for this template.\n  Template._loginButtons.helpers({\n    currentUser: AccountsPatchUi.wrapWithSignedUp(function () {\n      return Meteor.user();\n    })\n  });\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/brettle_accounts-patch-ui/patch-useraccounts.js                        //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n\"use strict\";\n/* globals AccountsPatchUi, Iron */\n\nfunction wrapRouteHooksWithSignedUp(route) {\n  _.each(Iron.Router.HOOK_TYPES, function(hookType) {\n    if (_.isFunction(route.options[hookType])) {\n      route.options[hookType] =\n        AccountsPatchUi.wrapWithSignedUp(route.options[hookType]);\n    }\n  });\n}\n\nfunction wrapFlowRouteHooksWithSignedUp(route) {\n  if (_.isFunction(route._action)) {\n    route._action = AccountsPatchUi.wrapWithSignedUp(route._action);\n  }\n  _.each(['triggersEnter', 'triggersExit'], function(hookType) {\n    if (_.isArray(route.options[hookType])) {\n      _.each(route.options[hookType], function(cb, i, arr) {\n        if (_.isFunction(cb)) {\n          arr[i] = AccountsPatchUi.wrapWithSignedUp(cb);\n        }\n      });\n    }\n  });\n}\n\nAccountsPatchUi._wrapTemplateWithSignedUp(Template.atNavButton);\nAccountsPatchUi._wrapTemplateWithSignedUp(Template.atForm);\n\nvar AccountsTemplates =\n  Package['useraccounts:core'] &&\n  Package['useraccounts:core'].AccountsTemplates;\nif (Package['useraccounts:iron-routing']) {\n  var IronRouter = Package['iron:router'] && Package['iron:router'].Router;\n  if (AccountsTemplates && AccountsTemplates.routes && IronRouter) {\n    _.each(AccountsTemplates.routes, function(r) {\n      var route = IronRouter.routes[r.name];\n      wrapRouteHooksWithSignedUp(route);\n    });\n  }\n\n  if (AccountsTemplates && AccountsTemplates.configureRoute && IronRouter) {\n    var origConfigureRoute = AccountsTemplates.configureRoute;\n    AccountsTemplates.configureRoute = function(routeCode, options) {\n      var ret = origConfigureRoute.call(this, routeCode, options);\n      var route = IronRouter.routes[AccountsTemplates.routes[routeCode].name];\n      wrapRouteHooksWithSignedUp(route);\n      return ret;\n    };\n\n    var origEnsureSignedIn = AccountsTemplates.ensureSignedIn;\n    AccountsTemplates.ensureSignedIn =\n      AccountsPatchUi.wrapWithSignedUp(origEnsureSignedIn);\n\n    var origEnsureSignedInPlugin = Iron.Router.plugins.ensureSignedIn;\n    Iron.Router.plugins.ensureSignedIn = function(router, options) {\n      var origMethods = {};\n      _.each(['onBeforeAction', 'onAfterAction', 'onRerun', 'onRun', 'onStop'],\n        function(methodName) {\n          if (_.isFunction(router[methodName])) {\n            origMethods[methodName] = router[methodName];\n            router[methodName] = function(hook, options) {\n              return origMethods[methodName].\n                call(router, AccountsPatchUi.wrapWithSignedUp(hook), options);\n            };\n          }\n        }\n      );\n      var ret;\n      try {\n        ret = origEnsureSignedInPlugin(router, options);\n      } finally {\n        _.each(_.keys(origMethods), function(methodName) {\n          router[methodName] = origMethods[methodName];\n        });\n      }\n      return ret;\n    };\n  }\n} else if (Package['useraccounts:flow-routing']) {\n  var FlowRouter =\n    Package['kadira:flow-router'] && Package['kadira:flow-router'].FlowRouter;\n  if (AccountsTemplates && AccountsTemplates.routes && FlowRouter) {\n    _.each(AccountsTemplates.routes, function(r, key) {\n      var route = lookupFlowRoute(r.name, key);\n      wrapFlowRouteHooksWithSignedUp(route);\n    });\n  }\n\n  if (AccountsTemplates && AccountsTemplates.configureRoute && FlowRouter) {\n    var origConfigureRoute = AccountsTemplates.configureRoute;\n    AccountsTemplates.configureRoute = function(routeCode, options) {\n      var ret = origConfigureRoute.call(this, routeCode, options);\n      var route =\n        lookupFlowRoute(AccountsTemplates.routes[routeCode].name, routeCode);\n      wrapFlowRouteHooksWithSignedUp(route);\n      return ret;\n    };\n\n    var origEnsureSignedIn = AccountsTemplates.ensureSignedIn;\n    AccountsTemplates.ensureSignedIn =\n      AccountsPatchUi.wrapWithSignedUp(origEnsureSignedIn);\n  }\n}\n\nfunction lookupFlowRoute(name, code) {\n  var route = FlowRouter._routesMap[name];\n  // Looks like configureRoute sometimes uses the route code instead of the\n  // route name. Probably a bug.\n  if (!route) {\n    route = FlowRouter._routesMap[code];\n  }\n  return route;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"brettle:accounts-patch-ui\", {\n  AccountsPatchUi: AccountsPatchUi\n});\n\n})();\n","servePath":"/packages/brettle_accounts-patch-ui.js"}]