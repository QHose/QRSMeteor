[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\n\n/* Package-scope variables */\nvar Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"promise\":{\"server.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/promise/server.js                                                //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nrequire(\"meteor-promise\").makeCompatible(\n  exports.Promise = require(\"./common.js\").Promise,\n  // Allow every Promise callback to run in a Fiber drawn from a pool of\n  // reusable Fibers.\n  require(\"fibers\")\n);\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"common.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/promise/common.js                                                //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nvar global = this;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nif (typeof global.Promise === \"function\") {\n  exports.Promise = global.Promise;\n} else {\n  exports.Promise = global.Promise =\n    require(\"promise/lib/es6-extensions\");\n}\n\nvar proto = exports.Promise.prototype;\n\nproto.done = function (onFulfilled, onRejected) {\n  var self = this;\n\n  if (arguments.length > 0) {\n    self = this.then.apply(this, arguments);\n  }\n\n  self.then(null, function (err) {\n    Meteor._setImmediate(function () {\n      throw err;\n    });\n  });\n};\n\nif (! hasOwn.call(proto, \"finally\")) {\n  proto[\"finally\"] = function (onFinally) {\n    var threw = false, result;\n    return this.then(function (value) {\n      result = value;\n      // Most implementations of Promise.prototype.finally call\n      // Promise.resolve(onFinally()) (or this.constructor.resolve or even\n      // this.constructor[Symbol.species].resolve, depending on how spec\n      // compliant they're trying to be), but this implementation simply\n      // relies on the standard Promise behavior of resolving any value\n      // returned from a .then callback function.\n      return onFinally();\n    }, function (error) {\n      // Make the final .then callback (below) re-throw the error instead\n      // of returning it.\n      threw = true;\n      result = error;\n      return onFinally();\n    }).then(function () {\n      if (threw) throw result;\n      return result;\n    });\n  };\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"meteor-promise\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/promise/node_modules/meteor-promise/package.json      //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nexports.name = \"meteor-promise\";\nexports.version = \"0.8.6\";\nexports.main = \"promise_server.js\";\n\n///////////////////////////////////////////////////////////////////////////////\n\n},\"promise_server.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nvar assert = require(\"assert\");\nvar fiberPool = require(\"./fiber_pool.js\").makePool();\n\nexports.makeCompatible = function (Promise, Fiber) {\n  var es6PromiseThen = Promise.prototype.then;\n\n  if (typeof Fiber === \"function\") {\n    Promise.Fiber = Fiber;\n  }\n\n  if (es6PromiseThen.name === \"meteorPromiseThen\") {\n    return; // Already compatible.\n  }\n\n  function meteorPromiseThen(onResolved, onRejected) {\n    var Promise = this.constructor;\n    var Fiber = Promise.Fiber;\n\n    if (typeof Fiber === \"function\" &&\n        ! this._meteorPromiseAlreadyWrapped) {\n      onResolved = wrapCallback(onResolved, Promise);\n      onRejected = wrapCallback(onRejected, Promise);\n\n      // Just in case we're wrapping a .then method defined by an older\n      // version of this library, make absolutely sure it doesn't attempt\n      // to rewrap the callbacks, and instead calls its own original\n      // es6PromiseThen function.\n      Promise.Fiber = null;\n      try {\n        return es6PromiseThen.call(this, onResolved, onRejected);\n      } finally {\n        Promise.Fiber = Fiber;\n      }\n    }\n\n    return es6PromiseThen.call(this, onResolved, onRejected);\n  }\n\n  // Replace Promise.prototype.then with a wrapper that ensures the\n  // onResolved and onRejected callbacks always run in a Fiber.\n  Object.defineProperty(Promise.prototype, \"then\", {\n    value: meteorPromiseThen,\n    enumerable: true,\n    // Don't let older versions of the meteor-promise library overwrite\n    // this version of Promise.prototype.then...\n    writable: false,\n    // ... unless they also call Object.defineProperty.\n    configurable: true\n  });\n\n  Promise.awaitAll = function (args) {\n    return awaitPromise(this.all(args));\n  };\n\n  Promise.await = function (arg) {\n    return awaitPromise(this.resolve(arg));\n  };\n\n  Promise.prototype.await = function () {\n    return awaitPromise(this);\n  };\n\n  // Yield the current Fiber until the given Promise has been fulfilled.\n  function awaitPromise(promise) {\n    var Promise = promise.constructor;\n    var Fiber = Promise.Fiber;\n\n    assert.strictEqual(\n      typeof Fiber, \"function\",\n      \"Cannot await unless Promise.Fiber is defined\"\n    );\n\n    var fiber = Fiber.current;\n\n    assert.ok(\n      fiber instanceof Fiber,\n      \"Cannot await without a Fiber\"\n    );\n\n    var run = fiber.run;\n    var throwInto = fiber.throwInto;\n\n    if (process.domain) {\n      run = process.domain.bind(run);\n      throwInto = process.domain.bind(throwInto);\n    }\n\n    // The overridden es6PromiseThen function is adequate here because these\n    // two callbacks do not need to run in a Fiber.\n    es6PromiseThen.call(promise, function (result) {\n      tryCatchNextTick(fiber, run, [result]);\n    }, function (error) {\n      tryCatchNextTick(fiber, throwInto, [error]);\n    });\n\n    return stackSafeYield(Fiber, awaitPromise);\n  }\n\n  function stackSafeYield(Fiber, caller) {\n    try {\n      return Fiber.yield();\n    } catch (thrown) {\n      if (thrown) {\n        var e = new Error;\n        Error.captureStackTrace(e, caller);\n        thrown.stack += e.stack.replace(/^.*?\\n/, \"\\n => awaited here:\\n\");\n      }\n      throw thrown;\n    }\n  }\n\n  // Return a wrapper function that returns a Promise for the eventual\n  // result of the original function.\n  Promise.async = function (fn, allowReuseOfCurrentFiber) {\n    var Promise = this;\n    return function () {\n      return Promise.asyncApply(\n        fn, this, arguments,\n        allowReuseOfCurrentFiber\n      );\n    };\n  };\n\n  Promise.asyncApply = function (\n    fn, context, args, allowReuseOfCurrentFiber\n  ) {\n    var Promise = this;\n    var Fiber = Promise.Fiber;\n    var fiber = Fiber && Fiber.current;\n\n    if (fiber && allowReuseOfCurrentFiber) {\n      return this.resolve(fn.apply(context, args));\n    }\n\n    return fiberPool.run({\n      callback: fn,\n      context: context,\n      args: args,\n      dynamics: cloneFiberOwnProperties(fiber)\n    }, Promise);\n  };\n};\n\nfunction wrapCallback(callback, Promise) {\n  if (! callback) {\n    return callback;\n  }\n\n  // Don't wrap callbacks that are flagged as not wanting to be called in a\n  // fiber.\n  if (callback._meteorPromiseAlreadyWrapped) {\n    return callback;\n  }\n\n  var dynamics = cloneFiberOwnProperties(Promise.Fiber.current);\n  var result = function (arg) {\n    var promise = fiberPool.run({\n      callback: callback,\n      args: [arg], // Avoid dealing with arguments objects.\n      dynamics: dynamics\n    }, Promise);\n\n    // Avoid wrapping the native resolver functions that will be attached\n    // to this promise per https://github.com/meteor/promise/issues/18.\n    promise._meteorPromiseAlreadyWrapped = true;\n\n    return promise;\n  };\n\n  // Flag this callback as not wanting to be called in a fiber because it is\n  // already creating a fiber.\n  result._meteorPromiseAlreadyWrapped = true;\n\n  return result;\n}\n\nfunction cloneFiberOwnProperties(fiber) {\n  if (fiber) {\n    var dynamics = {};\n\n    Object.keys(fiber).forEach(function (key) {\n      dynamics[key] = shallowClone(fiber[key]);\n    });\n\n    return dynamics;\n  }\n}\n\nfunction shallowClone(value) {\n  if (Array.isArray(value)) {\n    return value.slice(0);\n  }\n\n  if (value && typeof value === \"object\") {\n    var copy = Object.create(Object.getPrototypeOf(value));\n    var keys = Object.keys(value);\n    var keyCount = keys.length;\n\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      copy[key] = value[key];\n    }\n\n    return copy;\n  }\n\n  return value;\n}\n\n// Invoke method with args against object in a try-catch block,\n// re-throwing any exceptions in the next tick of the event loop, so that\n// they won't get captured/swallowed by the caller.\nfunction tryCatchNextTick(object, method, args) {\n  try {\n    return method.apply(object, args);\n  } catch (error) {\n    process.nextTick(function () {\n      throw error;\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n}},\"promise\":{\"lib\":{\"es6-extensions.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// node_modules/meteor/promise/node_modules/promise/lib/es6-extensions.js    //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._44);\n  p._83 = 1;\n  p._18 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._83 === 3) {\n            val = val._18;\n          }\n          if (val._83 === 1) return res(i, val._18);\n          if (val._83 === 2) reject(val._18);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n///////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/promise/server.js\");\n\n/* Exports */\nPackage._define(\"promise\", exports, {\n  Promise: Promise\n});\n\n})();\n","servePath":"/packages/promise.js"}]