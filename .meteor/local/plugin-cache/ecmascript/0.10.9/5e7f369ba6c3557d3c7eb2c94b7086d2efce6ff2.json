{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/autoupdate/autoupdate_client.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/autoupdate/autoupdate_client.js","filename":"packages/autoupdate/autoupdate_client.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/autoupdate/autoupdate_client.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/autoupdate/autoupdate_client.js"}},"code":"// Subscribe to the `meteor_autoupdate_clientVersions` collection,\n// which contains the set of acceptable client versions.\n//\n// A \"hard code push\" occurs when the running client version is not in\n// the set of acceptable client versions (or the server updates the\n// collection, there is a published client version marked `current` and\n// the running client version is no longer in the set).\n//\n// When the `reload` package is loaded, a hard code push causes\n// the browser to reload, so that it will load the latest client\n// version from the server.\n//\n// A \"soft code push\" represents the situation when the running client\n// version is in the set of acceptable versions, but there is a newer\n// version available on the server.\n//\n// `Autoupdate.newClientAvailable` is a reactive data source which\n// becomes `true` if there is a new version of the client is available on\n// the server.\n//\n// This package doesn't implement a soft code reload process itself,\n// but `newClientAvailable` could be used for example to display a\n// \"click to reload\" link to the user.\n// The client version of the client code currently running in the\n// browser.\nvar autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\nvar autoupdateVersionRefreshable = __meteor_runtime_config__.autoupdateVersionRefreshable || \"unknown\"; // The collection of acceptable client versions.\n\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !!ClientVersions.findOne({\n    _id: \"version\",\n    version: {\n      $ne: autoupdateVersion\n    }\n  }) || !!ClientVersions.findOne({\n    _id: \"version-refreshable\",\n    version: {\n      $ne: autoupdateVersionRefreshable\n    }\n  });\n};\n\nAutoupdate._ClientVersions = ClientVersions; // Used by a self-test\n\nvar knownToSupportCssOnLoad = false;\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0,\n  // don't do any immediate retries\n  baseTimeout: 30 * 1000 // start with 30s\n\n});\nvar failures = 0;\n\nfunction after(times, func) {\n  return function () {\n    if (--times < 1) {\n      return func.apply(this, arguments);\n    }\n  };\n}\n\n;\n\nAutoupdate._retrySubscription = function () {\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n    onError: function (error) {\n      Meteor._debug(\"autoupdate subscription failed:\", error);\n\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function () {\n      if (Package.reload) {\n        var checkNewVersionDocument = function (doc) {\n          var self = this;\n\n          if (doc._id === 'version-refreshable' && doc.version !== autoupdateVersionRefreshable) {\n            autoupdateVersionRefreshable = doc.version; // Switch out old css links for the new css links. Inspired by:\n            // https://github.com/guard/guard-livereload/blob/master/js/livereload.js#L710\n\n            var newCss = doc.assets && doc.assets.allCss || [];\n            var oldLinks = [];\n            Array.prototype.forEach.call(document.getElementsByTagName('link'), function (link) {\n              if (link.className === '__meteor-css__') {\n                oldLinks.push(link);\n              }\n            });\n\n            function waitUntilCssLoads(link, callback) {\n              var called;\n\n              function executeCallback(...args) {\n                if (!called) {\n                  called = true;\n                  return callback(...args);\n                }\n              }\n\n              link.onload = function () {\n                knownToSupportCssOnLoad = true;\n                executeCallback();\n              };\n\n              if (!knownToSupportCssOnLoad) {\n                var id = Meteor.setInterval(function () {\n                  if (link.sheet) {\n                    executeCallback();\n                    Meteor.clearInterval(id);\n                  }\n                }, 50);\n              }\n            }\n\n            var removeOldLinks = after(newCss.length, function () {\n              oldLinks.forEach(function (link) {\n                link.parentNode.removeChild(link);\n              });\n            });\n\n            var attachStylesheetLink = function (newLink) {\n              document.getElementsByTagName(\"head\").item(0).appendChild(newLink);\n              waitUntilCssLoads(newLink, function () {\n                Meteor.setTimeout(removeOldLinks, 200);\n              });\n            };\n\n            if (newCss.length !== 0) {\n              newCss.forEach(function (css) {\n                var newLink = document.createElement(\"link\");\n                newLink.setAttribute(\"rel\", \"stylesheet\");\n                newLink.setAttribute(\"type\", \"text/css\");\n                newLink.setAttribute(\"class\", \"__meteor-css__\");\n                newLink.setAttribute(\"href\", css.url);\n                attachStylesheetLink(newLink);\n              });\n            } else {\n              removeOldLinks();\n            }\n          } else if (doc._id === 'version' && doc.version !== autoupdateVersion) {\n            handle && handle.stop();\n\n            if (Package.reload) {\n              Package.reload.Reload._reload();\n            }\n          }\n        };\n\n        var handle = ClientVersions.find().observe({\n          added: checkNewVersionDocument,\n          changed: checkNewVersionDocument\n        });\n      }\n    }\n  });\n};\n\nAutoupdate._retrySubscription();","map":{"version":3,"sources":["packages/autoupdate/autoupdate_client.js"],"names":["autoupdateVersion","__meteor_runtime_config__","autoupdateVersionRefreshable","ClientVersions","Mongo","Collection","Autoupdate","newClientAvailable","findOne","_id","version","$ne","_ClientVersions","knownToSupportCssOnLoad","retry","Retry","minCount","baseTimeout","failures","after","times","func","apply","arguments","_retrySubscription","Meteor","subscribe","onError","error","_debug","retryLater","onReady","Package","reload","checkNewVersionDocument","doc","self","newCss","assets","allCss","oldLinks","Array","prototype","forEach","call","document","getElementsByTagName","link","className","push","waitUntilCssLoads","callback","called","executeCallback","args","onload","id","setInterval","sheet","clearInterval","removeOldLinks","length","parentNode","removeChild","attachStylesheetLink","newLink","item","appendChild","setTimeout","css","createElement","setAttribute","url","handle","stop","Reload","_reload","find","observe","added","changed"],"mappings":"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","sourcesContent":["// Subscribe to the `meteor_autoupdate_clientVersions` collection,\n// which contains the set of acceptable client versions.\n//\n// A \"hard code push\" occurs when the running client version is not in\n// the set of acceptable client versions (or the server updates the\n// collection, there is a published client version marked `current` and\n// the running client version is no longer in the set).\n//\n// When the `reload` package is loaded, a hard code push causes\n// the browser to reload, so that it will load the latest client\n// version from the server.\n//\n// A \"soft code push\" represents the situation when the running client\n// version is in the set of acceptable versions, but there is a newer\n// version available on the server.\n//\n// `Autoupdate.newClientAvailable` is a reactive data source which\n// becomes `true` if there is a new version of the client is available on\n// the server.\n//\n// This package doesn't implement a soft code reload process itself,\n// but `newClientAvailable` could be used for example to display a\n// \"click to reload\" link to the user.\n\n// The client version of the client code currently running in the\n// browser.\nvar autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\nvar autoupdateVersionRefreshable =\n  __meteor_runtime_config__.autoupdateVersionRefreshable || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne({\n               _id: \"version\",\n               version: {$ne: autoupdateVersion} }) ||\n         !! ClientVersions.findOne({\n               _id: \"version-refreshable\",\n               version: {$ne: autoupdateVersionRefreshable} });\n};\nAutoupdate._ClientVersions = ClientVersions;  // Used by a self-test\n\nvar knownToSupportCssOnLoad = false;\n\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nfunction after(times, func) {\n  return function() {\n    if (--times < 1) {\n      return func.apply(this, arguments);\n    }\n  };\n};\n\nAutoupdate._retrySubscription = function () {\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n    onError: function (error) {\n      Meteor._debug(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function () {\n      if (Package.reload) {\n        var checkNewVersionDocument = function (doc) {\n          var self = this;\n          if (doc._id === 'version-refreshable' &&\n              doc.version !== autoupdateVersionRefreshable) {\n            autoupdateVersionRefreshable = doc.version;\n            // Switch out old css links for the new css links. Inspired by:\n            // https://github.com/guard/guard-livereload/blob/master/js/livereload.js#L710\n            var newCss = (doc.assets && doc.assets.allCss) || [];\n            var oldLinks = [];\n\n            Array.prototype.forEach.call(\n              document.getElementsByTagName('link'),\n              function (link) {\n                if (link.className === '__meteor-css__') {\n                  oldLinks.push(link);\n                }\n              }\n            );\n\n            function waitUntilCssLoads(link, callback) {\n              var called;\n              function executeCallback(...args) {\n                if (! called) {\n                  called = true;\n                  return callback(...args);\n                }\n              }\n\n              link.onload = function () {\n                knownToSupportCssOnLoad = true;\n                executeCallback();\n              };\n\n              if (! knownToSupportCssOnLoad) {\n                var id = Meteor.setInterval(function () {\n                  if (link.sheet) {\n                    executeCallback();\n                    Meteor.clearInterval(id);\n                  }\n                }, 50);\n              }\n            }\n\n            var removeOldLinks = after(newCss.length, function () {\n              oldLinks.forEach(function (link) {\n                link.parentNode.removeChild(link);\n              });\n            });\n\n            var attachStylesheetLink = function (newLink) {\n              document.getElementsByTagName(\"head\").item(0).appendChild(newLink);\n\n              waitUntilCssLoads(newLink, function () {\n                Meteor.setTimeout(removeOldLinks, 200);\n              });\n            };\n\n            if (newCss.length !== 0) {\n              newCss.forEach(function (css) {\n                var newLink = document.createElement(\"link\");\n                newLink.setAttribute(\"rel\", \"stylesheet\");\n                newLink.setAttribute(\"type\", \"text/css\");\n                newLink.setAttribute(\"class\", \"__meteor-css__\");\n                newLink.setAttribute(\"href\", css.url);\n                attachStylesheetLink(newLink);\n              });\n            } else {\n              removeOldLinks();\n            }\n\n          }\n          else if (doc._id === 'version' && doc.version !== autoupdateVersion) {\n            handle && handle.stop();\n\n            if (Package.reload) {\n              Package.reload.Reload._reload();\n            }\n          }\n        };\n\n        var handle = ClientVersions.find().observe({\n          added: checkNewVersionDocument,\n          changed: checkNewVersionDocument\n        });\n      }\n    }\n  });\n};\nAutoupdate._retrySubscription();\n"]},"sourceType":"script","hash":"5e7f369ba6c3557d3c7eb2c94b7086d2efce6ff2"}
