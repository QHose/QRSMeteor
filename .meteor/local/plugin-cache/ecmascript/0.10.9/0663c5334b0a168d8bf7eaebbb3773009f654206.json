{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/shell-server/shell-server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/shell-server/shell-server.js","filename":"packages/shell-server/shell-server.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/shell-server/shell-server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/shell-server/shell-server.js"}},"code":"const module1 = module;\nmodule1.export({\n  listen: () => listen,\n  disable: () => disable\n});\nlet assert;\nmodule1.watch(require(\"assert\"), {\n  default(v) {\n    assert = v;\n  }\n\n}, 0);\nlet pathJoin;\nmodule1.watch(require(\"path\"), {\n  join(v) {\n    pathJoin = v;\n  }\n\n}, 1);\nlet PassThrough;\nmodule1.watch(require(\"stream\"), {\n  PassThrough(v) {\n    PassThrough = v;\n  }\n\n}, 2);\nlet closeSync, openSync, readFileSync, unlink, writeFileSync, writeSync;\nmodule1.watch(require(\"fs\"), {\n  closeSync(v) {\n    closeSync = v;\n  },\n\n  openSync(v) {\n    openSync = v;\n  },\n\n  readFileSync(v) {\n    readFileSync = v;\n  },\n\n  unlink(v) {\n    unlink = v;\n  },\n\n  writeFileSync(v) {\n    writeFileSync = v;\n  },\n\n  writeSync(v) {\n    writeSync = v;\n  }\n\n}, 3);\nlet createServer;\nmodule1.watch(require(\"net\"), {\n  createServer(v) {\n    createServer = v;\n  }\n\n}, 4);\nlet replStart;\nmodule1.watch(require(\"repl\"), {\n  start(v) {\n    replStart = v;\n  }\n\n}, 5);\nconst INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\n\nconst EXITING_MESSAGE = \"Shell exiting...\"; // Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\n\nfunction listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  } // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n\n\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    const hooks = __meteor_bootstrap__.startupHooks;\n\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\nfunction disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    writeFileSync(getInfoFile(shellDir), JSON.stringify({\n      status: \"disabled\",\n      reason: \"Shell server has shut down.\"\n    }) + \"\\n\", {\n      mode: INFO_FILE_MODE\n    });\n  } catch (ignored) {}\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nconst evalCommandPromise = Promise.resolve();\n\nclass Server {\n  constructor(shellDir) {\n    assert.ok(this instanceof Server);\n    this.shellDir = shellDir;\n    this.key = Math.random().toString(36).slice(2);\n    this.server = createServer(socket => {\n      this.onConnection(socket);\n    }).on(\"error\", err => {\n      console.error(err.stack);\n    });\n  }\n\n  listen() {\n    const infoFile = getInfoFile(this.shellDir);\n    unlink(infoFile, () => {\n      this.server.listen(0, \"127.0.0.1\", () => {\n        writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: this.server.address().port,\n          key: this.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function () {\n      socket = null;\n    }); // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n\n    const timeout = setTimeout(function () {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000); // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n\n    readJSONFromStream(socket, (error, options, replInputSocket) => {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== this.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n\n        return;\n      }\n\n      delete options.key; // Set the columns to what is being requested by the client.\n\n      if (options.columns && socket) {\n        socket.columns = options.columns;\n      }\n\n      delete options.columns;\n      options = Object.assign(Object.create(null), // Defaults for configurable options.\n      {\n        prompt: \"> \",\n        terminal: true,\n        useColors: true,\n        ignoreUndefined: true\n      }, // Configurable options\n      options, // Immutable options.\n      {\n        input: replInputSocket,\n        useGlobal: false,\n        output: socket\n      }); // The prompt during an evaluateAndExit must be blank to ensure\n      // that the prompt doesn't inadvertently get parsed as part of\n      // the JSON communication channel.\n\n      if (options.evaluateAndExit) {\n        options.prompt = \"\";\n      } // Start the REPL.\n\n\n      this.startREPL(options);\n\n      if (options.evaluateAndExit) {\n        this._wrappedDefaultEval.call(Object.create(null), options.evaluateAndExit.command, global, options.evaluateAndExit.filename || \"<meteor shell>\", function (error, result) {\n          if (socket) {\n            function sendResultToSocket(message) {\n              // Sending back a JSON payload allows the client to\n              // distinguish between errors and successful results.\n              socket.end(JSON.stringify(message) + \"\\n\");\n            }\n\n            if (error) {\n              sendResultToSocket({\n                error: error.toString(),\n                code: 1\n              });\n            } else {\n              sendResultToSocket({\n                result\n              });\n            }\n          }\n        });\n\n        return;\n      }\n\n      delete options.evaluateAndExit;\n      this.enableInteractiveMode(options);\n    });\n  }\n\n  startREPL(options) {\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function () {\n      options.output = null;\n    });\n    const repl = this.repl = replStart(options); // This is technique of setting `repl.context` is similar to how the\n    // `useGlobal` option would work during a normal `repl.start()` and\n    // allows shell access (and tab completion!) to Meteor globals (i.e.\n    // Underscore _, Meteor, etc.). By using this technique, which changes\n    // the context after startup, we avoid stomping on the special `_`\n    // variable (in `repl` this equals the value of the last command) from\n    // being overridden in the client/server socket-handshaking.  Furthermore,\n    // by setting `useGlobal` back to true, we allow the default eval function\n    // to use the desired `runInThisContext` method (https://git.io/vbvAB).\n\n    repl.context = global;\n    repl.useGlobal = true;\n    setRequireAndModule(repl.context); // In order to avoid duplicating code here, specifically the complexities\n    // of catching so-called \"Recoverable Errors\" (https://git.io/vbvbl),\n    // we will wrap the default eval, run it in a Fiber (via a Promise), and\n    // give it the opportunity to decide if the user is mid-code-block.\n\n    const defaultEval = repl.eval;\n\n    function wrappedDefaultEval(code, context, file, callback) {\n      if (Package.ecmascript) {\n        try {\n          code = Package.ecmascript.ECMAScript.compileForShell(code);\n        } catch (err) {// Any Babel error here might be just fine since it's\n          // possible the code was incomplete (multi-line code on the REPL).\n          // The defaultEval below will use its own functionality to determine\n          // if this error is \"recoverable\".\n        }\n      }\n\n      evalCommandPromise.then(() => defaultEval(code, context, file, callback)).catch(callback);\n    } // Have the REPL use the newly wrapped function instead and store the\n    // _wrappedDefaultEval so that evalulateAndExit calls can use it directly.\n\n\n    repl.eval = this._wrappedDefaultEval = wrappedDefaultEval;\n  }\n\n  enableInteractiveMode(options) {\n    // History persists across shell sessions!\n    this.initializeHistory();\n    const repl = this.repl; // Implement an alternate means of fetching the return value,\n    // via `__` (double underscore) as originally implemented in:\n    // https://github.com/meteor/meteor/commit/2443d832265c7d1c\n\n    Object.defineProperty(repl.context, \"__\", {\n      get: () => repl.last,\n      set: val => {\n        repl.last = val;\n      },\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    }); // Some improvements to the existing help messages.\n\n    function addHelp(cmd, helpText) {\n      const info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n\n      if (info) {\n        info.help = helpText;\n      }\n    }\n\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\"); // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n\n    repl.on(\"exit\", function () {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    }); // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n\n    process.on(\"exit\", function () {\n      if (options.output) {\n        options.output.end();\n      }\n    }); // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function () {\n        process.exit(0);\n      }\n    });\n  } // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell-history.\n\n\n  initializeHistory() {\n    const rli = this.repl.rli;\n    const historyFile = getHistoryFile(this.shellDir);\n    let historyFd = openSync(historyFile, \"a+\");\n    const historyLines = readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    const seenLines = Object.create(null);\n\n    if (!rli.history) {\n      rli.history = [];\n      rli.historyIndex = -1;\n    }\n\n    while (rli.history && historyLines.length > 0) {\n      const line = historyLines.pop();\n\n      if (line && /\\S/.test(line) && !seenLines[line]) {\n        rli.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    rli.addListener(\"line\", function (line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        writeSync(historyFd, line + \"\\n\");\n      }\n    });\n    this.repl.on(\"exit\", function () {\n      closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  const outputStream = new PassThrough();\n  let dataSoFar = \"\";\n\n  function onData(buffer) {\n    const lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n      let json;\n\n      try {\n        json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  let finished = false;\n\n  function finish(error, json) {\n    if (!finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return pathJoin(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return pathJoin(shellDir, \"history\");\n}\n\nfunction setRequireAndModule(context) {\n  if (Package.modules) {\n    // Use the same `require` function and `module` object visible to the\n    // application.\n    const toBeInstalled = {};\n    const shellModuleName = \"meteor-shell-\" + Math.random().toString(36).slice(2) + \".js\";\n\n    toBeInstalled[shellModuleName] = function (require, exports, module) {\n      context.module = module;\n      context.require = require; // Tab completion sometimes uses require.extensions, but only for\n      // the keys.\n\n      require.extensions = {\n        \".js\": true,\n        \".json\": true,\n        \".node\": true\n      };\n    }; // This populates repl.context.{module,require} by evaluating the\n    // module defined above.\n\n\n    Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n  }\n}","map":{"version":3,"sources":["packages/shell-server/shell-server.js"],"names":["module1","module","export","listen","disable","assert","watch","require","default","v","pathJoin","join","PassThrough","closeSync","openSync","readFileSync","unlink","writeFileSync","writeSync","createServer","replStart","start","INFO_FILE_MODE","parseInt","EXITING_MESSAGE","shellDir","callback","Server","Meteor","startup","__meteor_bootstrap__","hooks","startupHooks","push","setImmediate","getInfoFile","JSON","stringify","status","reason","mode","ignored","evalCommandPromise","Promise","resolve","constructor","ok","key","Math","random","toString","slice","server","socket","onConnection","on","err","console","error","stack","infoFile","port","address","timeout","setTimeout","removeAllListeners","end","readJSONFromStream","options","replInputSocket","clearTimeout","columns","Object","assign","create","prompt","terminal","useColors","ignoreUndefined","input","useGlobal","output","evaluateAndExit","startREPL","_wrappedDefaultEval","call","command","global","filename","result","sendResultToSocket","message","code","enableInteractiveMode","repl","context","setRequireAndModule","defaultEval","eval","wrappedDefaultEval","file","Package","ecmascript","ECMAScript","compileForShell","then","catch","initializeHistory","defineProperty","get","last","set","val","configurable","addHelp","cmd","helpText","info","commands","help","write","process","defineCommand","action","exit","rli","historyFile","getHistoryFile","historyFd","historyLines","split","seenLines","history","historyIndex","length","line","pop","test","addListener","inputStream","outputStream","dataSoFar","onData","buffer","lines","shift","json","parse","SyntaxError","finish","pipe","onClose","Error","finished","removeListener","modules","toBeInstalled","shellModuleName","exports","extensions","meteorInstall"],"mappings":"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","sourcesContent":["import assert from \"assert\";\nimport { join as pathJoin } from \"path\";\nimport { PassThrough } from \"stream\";\nimport {\n  closeSync,\n  openSync,\n  readFileSync,\n  unlink,\n  writeFileSync,\n  writeSync,\n} from \"fs\";\nimport { createServer } from \"net\";\nimport { start as replStart } from \"repl\";\n\nconst INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nconst EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nexport function listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    const hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nexport function disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    writeFileSync(\n      getInfoFile(shellDir),\n      JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\",\n      { mode: INFO_FILE_MODE }\n    );\n  } catch (ignored) {}\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nconst evalCommandPromise = Promise.resolve();\n\nclass Server {\n  constructor(shellDir) {\n    assert.ok(this instanceof Server);\n\n    this.shellDir = shellDir;\n    this.key = Math.random().toString(36).slice(2);\n\n    this.server =\n      createServer((socket) => {\n        this.onConnection(socket);\n      })\n      .on(\"error\", (err) => {\n        console.error(err.stack);\n      });\n  }\n\n  listen() {\n    const infoFile = getInfoFile(this.shellDir);\n\n    unlink(infoFile, () => {\n      this.server.listen(0, \"127.0.0.1\", () => {\n        writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: this.server.address().port,\n          key: this.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function() {\n      socket = null;\n    });\n\n    // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n    const timeout = setTimeout(function() {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000);\n\n    // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n    readJSONFromStream(socket, (error, options, replInputSocket) => {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== this.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n        return;\n      }\n      delete options.key;\n\n      // Set the columns to what is being requested by the client.\n      if (options.columns && socket) {\n        socket.columns = options.columns;\n      }\n      delete options.columns;\n\n      options = Object.assign(\n        Object.create(null),\n\n        // Defaults for configurable options.\n        {\n          prompt: \"> \",\n          terminal: true,\n          useColors: true,\n          ignoreUndefined: true,\n        },\n\n        // Configurable options\n        options,\n\n        // Immutable options.\n        {\n          input: replInputSocket,\n          useGlobal: false,\n          output: socket\n        }\n      );\n\n      // The prompt during an evaluateAndExit must be blank to ensure\n      // that the prompt doesn't inadvertently get parsed as part of\n      // the JSON communication channel.\n      if (options.evaluateAndExit) {\n        options.prompt = \"\";\n      }\n\n      // Start the REPL.\n      this.startREPL(options);\n\n      if (options.evaluateAndExit) {\n        this._wrappedDefaultEval.call(\n          Object.create(null),\n          options.evaluateAndExit.command,\n          global,\n          options.evaluateAndExit.filename || \"<meteor shell>\",\n          function (error, result) {\n            if (socket) {\n              function sendResultToSocket(message) {\n                // Sending back a JSON payload allows the client to\n                // distinguish between errors and successful results.\n                socket.end(JSON.stringify(message) + \"\\n\");\n              }\n\n              if (error) {\n                sendResultToSocket({\n                  error: error.toString(),\n                  code: 1\n                });\n              } else {\n                sendResultToSocket({\n                  result,\n                });\n              }\n            }\n          }\n        );\n        return;\n      }\n      delete options.evaluateAndExit;\n\n      this.enableInteractiveMode(options);\n    });\n  }\n\n  startREPL(options) {\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function() {\n      options.output = null;\n    });\n\n    const repl = this.repl = replStart(options);\n\n    // This is technique of setting `repl.context` is similar to how the\n    // `useGlobal` option would work during a normal `repl.start()` and\n    // allows shell access (and tab completion!) to Meteor globals (i.e.\n    // Underscore _, Meteor, etc.). By using this technique, which changes\n    // the context after startup, we avoid stomping on the special `_`\n    // variable (in `repl` this equals the value of the last command) from\n    // being overridden in the client/server socket-handshaking.  Furthermore,\n    // by setting `useGlobal` back to true, we allow the default eval function\n    // to use the desired `runInThisContext` method (https://git.io/vbvAB).\n    repl.context = global;\n    repl.useGlobal = true;\n\n    setRequireAndModule(repl.context);\n\n    // In order to avoid duplicating code here, specifically the complexities\n    // of catching so-called \"Recoverable Errors\" (https://git.io/vbvbl),\n    // we will wrap the default eval, run it in a Fiber (via a Promise), and\n    // give it the opportunity to decide if the user is mid-code-block.\n    const defaultEval = repl.eval;\n\n    function wrappedDefaultEval(code, context, file, callback) {\n      if (Package.ecmascript) {\n        try {\n          code = Package.ecmascript.ECMAScript.compileForShell(code);\n        } catch (err) {\n          // Any Babel error here might be just fine since it's\n          // possible the code was incomplete (multi-line code on the REPL).\n          // The defaultEval below will use its own functionality to determine\n          // if this error is \"recoverable\".\n        }\n      }\n\n      evalCommandPromise\n        .then(() => defaultEval(code, context, file, callback))\n        .catch(callback);\n    }\n\n    // Have the REPL use the newly wrapped function instead and store the\n    // _wrappedDefaultEval so that evalulateAndExit calls can use it directly.\n    repl.eval = this._wrappedDefaultEval = wrappedDefaultEval;\n  }\n\n  enableInteractiveMode(options) {\n    // History persists across shell sessions!\n    this.initializeHistory();\n\n    const repl = this.repl;\n\n    // Implement an alternate means of fetching the return value,\n    // via `__` (double underscore) as originally implemented in:\n    // https://github.com/meteor/meteor/commit/2443d832265c7d1c\n    Object.defineProperty(repl.context, \"__\", {\n      get: () => repl.last,\n      set: (val) => {\n        repl.last = val;\n      },\n\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    });\n\n    // Some improvements to the existing help messages.\n    function addHelp(cmd, helpText) {\n      const info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n      if (info) {\n        info.help = helpText;\n      }\n    }\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\");\n\n    // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n    repl.on(\"exit\", function() {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    });\n\n    // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n    process.on(\"exit\", function() {\n      if (options.output) {\n        options.output.end();\n      }\n    });\n\n    // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function() {\n        process.exit(0);\n      }\n    });\n  }\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell-history.\n  initializeHistory() {\n    const rli = this.repl.rli;\n    const historyFile = getHistoryFile(this.shellDir);\n    let historyFd = openSync(historyFile, \"a+\");\n    const historyLines = readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    const seenLines = Object.create(null);\n\n    if (! rli.history) {\n      rli.history = [];\n      rli.historyIndex = -1;\n    }\n\n    while (rli.history && historyLines.length > 0) {\n      const line = historyLines.pop();\n      if (line && /\\S/.test(line) && ! seenLines[line]) {\n        rli.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    rli.addListener(\"line\", function(line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        writeSync(historyFd, line + \"\\n\");\n      }\n    });\n\n    this.repl.on(\"exit\", function() {\n      closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  const outputStream = new PassThrough();\n  let dataSoFar = \"\";\n\n  function onData(buffer) {\n    const lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      let json;\n      try {\n        json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  let finished = false;\n  function finish(error, json) {\n    if (! finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return pathJoin(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return pathJoin(shellDir, \"history\");\n}\n\n\nfunction setRequireAndModule(context) {\n  if (Package.modules) {\n    // Use the same `require` function and `module` object visible to the\n    // application.\n    const toBeInstalled = {};\n    const shellModuleName = \"meteor-shell-\" +\n      Math.random().toString(36).slice(2) + \".js\";\n\n    toBeInstalled[shellModuleName] = function (require, exports, module) {\n      context.module = module;\n      context.require = require;\n\n      // Tab completion sometimes uses require.extensions, but only for\n      // the keys.\n      require.extensions = {\n        \".js\": true,\n        \".json\": true,\n        \".node\": true,\n      };\n    };\n\n    // This populates repl.context.{module,require} by evaluating the\n    // module defined above.\n    Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n  }\n}\n"]},"sourceType":"script","hash":"0663c5334b0a168d8bf7eaebbb3773009f654206"}
