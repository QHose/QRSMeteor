{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/rate-limit/rate-limit-tests.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/rate-limit/rate-limit-tests.js","filename":"packages/rate-limit/rate-limit-tests.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/rate-limit/rate-limit-tests.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/rate-limit/rate-limit-tests.js"}},"code":"let Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet RateLimiter;\nmodule.watch(require(\"meteor/rate-limit\"), {\n  RateLimiter(v) {\n    RateLimiter = v;\n  }\n\n}, 1);\nlet DDPCommon;\nmodule.watch(require(\"meteor/ddp-common\"), {\n  DDPCommon(v) {\n    DDPCommon = v;\n  }\n\n}, 2);\nTinytest.add('rate limit tests - Check empty constructor creation', function (test) {\n  const r = new RateLimiter();\n  test.equal(r.rules, {});\n});\nTinytest.add('rate limit tests - Check single rule with multiple ' + 'invocations, only 1 that matches', function (test) {\n  const r = new RateLimiter();\n  const userIdOne = 1;\n  const restrictJustUserIdOneRule = {\n    userId: userIdOne,\n    IPAddr: null,\n    method: null\n  };\n  r.addRule(restrictJustUserIdOneRule, 1, 1000);\n  const connectionHandle = createTempConnectionHandle(123, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(userIdOne, connectionHandle, 'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle, 'login');\n\n  for (let i = 0; i < 2; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n  }\n\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, true);\n});\ntestAsyncMulti('rate limit tests - Run multiple invocations and wait for one' + ' to reset', [function (test, expect) {\n  this.r = new RateLimiter();\n  this.userIdOne = 1;\n  this.userIdTwo = 2;\n  this.restrictJustUserIdOneRule = {\n    userId: this.userIdOne,\n    IPAddr: null,\n    method: null\n  };\n  this.r.addRule(this.restrictJustUserIdOneRule, 1, 500);\n  this.connectionHandle = createTempConnectionHandle(123, '127.0.0.1');\n  this.methodInvc1 = createTempMethodInvocation(this.userIdOne, this.connectionHandle, 'login');\n  this.methodInvc2 = createTempMethodInvocation(this.userIdTwo, this.connectionHandle, 'login');\n\n  for (let i = 0; i < 2; i++) {\n    this.r.increment(this.methodInvc1);\n    this.r.increment(this.methodInvc2);\n  }\n\n  test.equal(this.r.check(this.methodInvc1).allowed, false);\n  test.equal(this.r.check(this.methodInvc2).allowed, true);\n  Meteor.setTimeout(expect(function () {}), 1000);\n}, function (test) {\n  for (let i = 0; i < 100; i++) {\n    this.r.increment(this.methodInvc2);\n  }\n\n  test.equal(this.r.check(this.methodInvc1).allowed, true);\n  test.equal(this.r.check(this.methodInvc2).allowed, true);\n}]);\nTinytest.add('rate limit tests - Check two rules that affect same methodInvc' + ' still throw', function (test) {\n  const r = new RateLimiter();\n  const loginMethodRule = {\n    userId: null,\n    IPAddr: null,\n    method: 'login'\n  };\n  const onlyLimitEvenUserIdRule = {\n    userId: userId => userId % 2 === 0,\n    IPAddr: null,\n    method: null\n  };\n  r.addRule(loginMethodRule, 10, 100);\n  r.addRule(onlyLimitEvenUserIdRule, 4, 100);\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle, 'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle, 'login');\n  const methodInvc3 = createTempMethodInvocation(3, connectionHandle, 'test');\n\n  for (let i = 0; i < 5; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n    r.increment(methodInvc3);\n  } // After for loop runs, we only have 10 runs, so that's under the limit\n\n\n  test.equal(r.check(methodInvc1).allowed, true); // However, this triggers userId rule since this userId is even\n\n  test.equal(r.check(methodInvc2).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false); // Running one more test causes it to be false, since we're at 11 now.\n\n  r.increment(methodInvc1);\n  test.equal(r.check(methodInvc1).allowed, false); // 3rd Method Invocation isn't affected by either rules.\n\n  test.equal(r.check(methodInvc3).allowed, true);\n});\nTinytest.add('rate limit tests - Check one rule affected by two different ' + 'invocations', function (test) {\n  const r = new RateLimiter();\n  const loginMethodRule = {\n    userId: null,\n    IPAddr: null,\n    method: 'login'\n  };\n  r.addRule(loginMethodRule, 10, 10000);\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle, 'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle, 'login');\n\n  for (let i = 0; i < 5; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n  } // This throws us over the limit since both increment the login rule\n  // counter\n\n\n  r.increment(methodInvc1);\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false);\n});\nTinytest.add('rate limit tests - add global rule', function (test) {\n  const r = new RateLimiter();\n  const globalRule = {\n    userId: null,\n    IPAddr: null,\n    method: null\n  };\n  r.addRule(globalRule, 1, 10000);\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const connectionHandle2 = createTempConnectionHandle(1234, '127.0.0.2');\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle, 'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle2, 'test');\n  const methodInvc3 = createTempMethodInvocation(3, connectionHandle, 'user-accounts'); // First invocation, all methods would still be allowed.\n\n  r.increment(methodInvc2);\n  test.equal(r.check(methodInvc1).allowed, true);\n  test.equal(r.check(methodInvc2).allowed, true);\n  test.equal(r.check(methodInvc3).allowed, true); // Second invocation, everything has reached common rate limit\n\n  r.increment(methodInvc3);\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false);\n  test.equal(r.check(methodInvc3).allowed, false);\n});\nTinytest.add('rate limit tests - Fuzzy rule match does not trigger rate limit', function (test) {\n  const r = new RateLimiter();\n  const rule = {\n    a: inp => inp % 3 === 0,\n    b: 5,\n    c: 'hi'\n  };\n  r.addRule(rule, 1, 10000);\n  const input = {\n    a: 3,\n    b: 5\n  };\n\n  for (let i = 0; i < 5; i++) {\n    r.increment(input);\n  }\n\n  test.equal(r.check(input).allowed, true);\n  const matchingInput = {\n    a: 3,\n    b: 5,\n    c: 'hi',\n    d: 1\n  };\n  r.increment(matchingInput);\n  r.increment(matchingInput); // Past limit so should be false\n\n  test.equal(r.check(matchingInput).allowed, false); // Add secondary rule and check that longer time is returned when multiple\n  // rules limits are hit\n\n  const newRule = {\n    a: inp => inp % 3 === 0,\n    b: 5,\n    c: 'hi',\n    d: 1\n  };\n  r.addRule(newRule, 1, 10); // First rule should still throw while second rule will trigger as well,\n  // causing us to return longer time to reset to user\n\n  r.increment(matchingInput);\n  r.increment(matchingInput);\n  test.equal(r.check(matchingInput).timeToReset > 50, true);\n});\n/****** Test Our Helper Methods *****/\n\nTinytest.add('rate limit tests - test matchRule method', function (test) {\n  const r = new RateLimiter();\n  const globalRule = {\n    userId: null,\n    IPAddr: null,\n    type: null,\n    name: null\n  };\n  const globalRuleId = r.addRule(globalRule);\n  const rateLimiterInput = {\n    userId: 1023,\n    IPAddr: '127.0.0.1',\n    type: 'sub',\n    name: 'getSubLists'\n  };\n  test.equal(r.rules[globalRuleId].match(rateLimiterInput), true);\n  const oneNotNullRule = {\n    userId: 102,\n    IPAddr: null,\n    type: null,\n    name: null\n  };\n  const oneNotNullId = r.addRule(oneNotNullRule);\n  test.equal(r.rules[oneNotNullId].match(rateLimiterInput), false);\n  oneNotNullRule.userId = 1023;\n  test.equal(r.rules[oneNotNullId].match(rateLimiterInput), true);\n  const notCompleteInput = {\n    userId: 102,\n    IPAddr: '127.0.0.1'\n  };\n  test.equal(r.rules[globalRuleId].match(notCompleteInput), true);\n  test.equal(r.rules[oneNotNullId].match(notCompleteInput), false);\n});\nTinytest.add('rate limit tests - test generateMethodKey string', function (test) {\n  const r = new RateLimiter();\n  const globalRule = {\n    userId: null,\n    IPAddr: null,\n    type: null,\n    name: null\n  };\n  const globalRuleId = r.addRule(globalRule);\n  const rateLimiterInput = {\n    userId: 1023,\n    IPAddr: '127.0.0.1',\n    type: 'sub',\n    name: 'getSubLists'\n  };\n  test.equal(r.rules[globalRuleId]._generateKeyString(rateLimiterInput), '');\n  globalRule.userId = 1023;\n  test.equal(r.rules[globalRuleId]._generateKeyString(rateLimiterInput), 'userId1023');\n  const ruleWithFuncs = {\n    userId: input => input % 2 === 0,\n    IPAddr: null,\n    type: null\n  };\n  const funcRuleId = r.addRule(ruleWithFuncs);\n  test.equal(r.rules[funcRuleId]._generateKeyString(rateLimiterInput), '');\n  rateLimiterInput.userId = 1024;\n  test.equal(r.rules[funcRuleId]._generateKeyString(rateLimiterInput), 'userId1024');\n  const multipleRules = ruleWithFuncs;\n  multipleRules.IPAddr = '127.0.0.1';\n  const multipleRuleId = r.addRule(multipleRules);\n  test.equal(r.rules[multipleRuleId]._generateKeyString(rateLimiterInput), 'userId1024IPAddr127.0.0.1');\n});\n\nfunction createTempConnectionHandle(id, clientIP) {\n  return {\n    id,\n\n    close() {\n      this.close();\n    },\n\n    onClose(fn) {\n      const cb = Meteor.bindEnvironment(fn, 'connection onClose callback');\n\n      if (this.inQueue) {\n        this._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n\n    clientAddress: clientIP,\n    httpHeaders: null\n  };\n}\n\nfunction createTempMethodInvocation(userId, connectionHandle, methodName) {\n  const methodInv = new DDPCommon.MethodInvocation({\n    isSimulation: false,\n    userId,\n    setUserId: null,\n    unblock: false,\n    connection: connectionHandle,\n    randomSeed: 1234\n  });\n  methodInv.method = methodName;\n  return methodInv;\n}","map":{"version":3,"sources":["packages/rate-limit/rate-limit-tests.js"],"names":["Meteor","module","watch","require","v","RateLimiter","DDPCommon","Tinytest","add","test","r","equal","rules","userIdOne","restrictJustUserIdOneRule","userId","IPAddr","method","addRule","connectionHandle","createTempConnectionHandle","methodInvc1","createTempMethodInvocation","methodInvc2","i","increment","check","allowed","testAsyncMulti","expect","userIdTwo","setTimeout","loginMethodRule","onlyLimitEvenUserIdRule","methodInvc3","globalRule","connectionHandle2","rule","a","inp","b","c","input","matchingInput","d","newRule","timeToReset","type","name","globalRuleId","rateLimiterInput","match","oneNotNullRule","oneNotNullId","notCompleteInput","_generateKeyString","ruleWithFuncs","funcRuleId","multipleRules","multipleRuleId","id","clientIP","close","onClose","fn","cb","bindEnvironment","inQueue","_closeCallbacks","push","defer","clientAddress","httpHeaders","methodName","methodInv","MethodInvocation","isSimulation","setUserId","unblock","connection","randomSeed"],"mappings":"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","sourcesContent":["// These tests were written before rate-limit was factored outside of DDP Rate\n// Limiter and thus are structured with DDP method invocations in mind. These\n// rules still test abstract rate limit package behavior. The tests currently\n// implemented are:\n// * Empty rule set on RateLimiter construction\n// * Multiple inputs, only 1 that matches rule and reaches rate limit\n// * Multiple inputs, 1 hits rate limit, wait for reset, after which inputs\n//   allowed\n// * 2 rules, 3 inputs where 2/3 match 1 rule and thus hit rate limit. Second\n//   input matches another rule and hits rate limit while 3rd rule not rate\n//   limited\n// * One rule affected by two inputs still throws\n// * Global rule triggers on any invocation after reaching limit\n// * Fuzzy rule matching triggers rate limit only when input has more keys than\n//   rule\n// * matchRule tests that have various levels of similarity in input and rule\n// * generateKeyString tests for various matches creating appropriate string\n//\n// XXX These tests should be refactored to use Tinytest.add instead of\n// testAsyncMulti as they're all on the server. Any future tests should be\n// written that way.\nimport { Meteor } from 'meteor/meteor';\nimport { RateLimiter } from 'meteor/rate-limit';\nimport { DDPCommon } from 'meteor/ddp-common';\n\nTinytest.add('rate limit tests - Check empty constructor creation',\n  function (test) {\n    const r = new RateLimiter();\n    test.equal(r.rules, {});\n  },\n);\n\nTinytest.add('rate limit tests - Check single rule with multiple ' +\n  'invocations, only 1 that matches',\nfunction (test) {\n  const r = new RateLimiter();\n  const userIdOne = 1;\n  const restrictJustUserIdOneRule = {\n    userId: userIdOne,\n    IPAddr: null,\n    method: null,\n  };\n  r.addRule(restrictJustUserIdOneRule, 1, 1000);\n  const connectionHandle = createTempConnectionHandle(123, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(userIdOne, connectionHandle,\n    'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle,\n    'login');\n  for (let i = 0; i < 2; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n  }\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, true);\n},\n);\n\ntestAsyncMulti('rate limit tests - Run multiple invocations and wait for one' +\n  ' to reset', [\n  function (test, expect) {\n    this.r = new RateLimiter();\n    this.userIdOne = 1;\n    this.userIdTwo = 2;\n    this.restrictJustUserIdOneRule = {\n      userId: this.userIdOne,\n      IPAddr: null,\n      method: null,\n    };\n    this.r.addRule(this.restrictJustUserIdOneRule, 1, 500);\n    this.connectionHandle = createTempConnectionHandle(123, '127.0.0.1')\n    this.methodInvc1 = createTempMethodInvocation(this.userIdOne,\n      this.connectionHandle, 'login');\n    this.methodInvc2 = createTempMethodInvocation(this.userIdTwo,\n      this.connectionHandle, 'login');\n    for (let i = 0; i < 2; i++) {\n      this.r.increment(this.methodInvc1);\n      this.r.increment(this.methodInvc2);\n    }\n    test.equal(this.r.check(this.methodInvc1).allowed, false);\n    test.equal(this.r.check(this.methodInvc2).allowed, true);\n    Meteor.setTimeout(expect(function () { }), 1000);\n  },\n  function (test) {\n    for (let i = 0; i < 100; i++) {\n      this.r.increment(this.methodInvc2);\n    }\n    test.equal(this.r.check(this.methodInvc1).allowed, true);\n    test.equal(this.r.check(this.methodInvc2).allowed, true);\n  },\n]);\n\nTinytest.add('rate limit tests - Check two rules that affect same methodInvc' +\n  ' still throw', function (test) {\n  const r = new RateLimiter();\n  const loginMethodRule = {\n    userId: null,\n    IPAddr: null,\n    method: 'login',\n  };\n  const onlyLimitEvenUserIdRule = {\n    userId: userId => userId % 2 === 0,\n    IPAddr: null,\n    method: null,\n  };\n  r.addRule(loginMethodRule, 10, 100);\n  r.addRule(onlyLimitEvenUserIdRule, 4, 100);\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle,\n    'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle,\n    'login');\n  const methodInvc3 = createTempMethodInvocation(3, connectionHandle,\n    'test');\n  for (let i = 0; i < 5; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n    r.increment(methodInvc3);\n  }\n  // After for loop runs, we only have 10 runs, so that's under the limit\n  test.equal(r.check(methodInvc1).allowed, true);\n  // However, this triggers userId rule since this userId is even\n  test.equal(r.check(methodInvc2).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false);\n  // Running one more test causes it to be false, since we're at 11 now.\n  r.increment(methodInvc1);\n  test.equal(r.check(methodInvc1).allowed, false);\n  // 3rd Method Invocation isn't affected by either rules.\n  test.equal(r.check(methodInvc3).allowed, true);\n});\n\nTinytest.add('rate limit tests - Check one rule affected by two different ' +\n  'invocations', function (test) {\n  const r = new RateLimiter();\n  const loginMethodRule = {\n    userId: null,\n    IPAddr: null,\n    method: 'login',\n  };\n  r.addRule(loginMethodRule, 10, 10000);\n\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle,\n    'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle,\n    'login');\n\n  for (let i = 0; i < 5; i++) {\n    r.increment(methodInvc1);\n    r.increment(methodInvc2);\n  }\n  // This throws us over the limit since both increment the login rule\n  // counter\n  r.increment(methodInvc1);\n\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false);\n});\n\nTinytest.add('rate limit tests - add global rule', function (test) {\n  const r = new RateLimiter();\n  const globalRule = {\n    userId: null,\n    IPAddr: null,\n    method: null,\n  };\n  r.addRule(globalRule, 1, 10000);\n\n  const connectionHandle = createTempConnectionHandle(1234, '127.0.0.1');\n  const connectionHandle2 = createTempConnectionHandle(1234, '127.0.0.2');\n\n  const methodInvc1 = createTempMethodInvocation(1, connectionHandle,\n    'login');\n  const methodInvc2 = createTempMethodInvocation(2, connectionHandle2,\n    'test');\n  const methodInvc3 = createTempMethodInvocation(3, connectionHandle,\n    'user-accounts');\n\n  // First invocation, all methods would still be allowed.\n  r.increment(methodInvc2);\n  test.equal(r.check(methodInvc1).allowed, true);\n  test.equal(r.check(methodInvc2).allowed, true);\n  test.equal(r.check(methodInvc3).allowed, true);\n  // Second invocation, everything has reached common rate limit\n  r.increment(methodInvc3);\n  test.equal(r.check(methodInvc1).allowed, false);\n  test.equal(r.check(methodInvc2).allowed, false);\n  test.equal(r.check(methodInvc3).allowed, false);\n});\n\nTinytest.add('rate limit tests - Fuzzy rule match does not trigger rate limit',\n  function (test) {\n    const r = new RateLimiter();\n    const rule = {\n      a: inp => inp % 3 === 0,\n      b: 5,\n      c: 'hi',\n    };\n    r.addRule(rule, 1, 10000);\n    const input = {\n      a: 3,\n      b: 5,\n    };\n    for (let i = 0; i < 5; i++) {\n      r.increment(input);\n    }\n    test.equal(r.check(input).allowed, true);\n    const matchingInput = {\n      a: 3,\n      b: 5,\n      c: 'hi',\n      d: 1,\n    };\n    r.increment(matchingInput);\n    r.increment(matchingInput);\n    // Past limit so should be false\n    test.equal(r.check(matchingInput).allowed, false);\n\n    // Add secondary rule and check that longer time is returned when multiple\n    // rules limits are hit\n    const newRule = {\n      a: inp => inp % 3 === 0,\n      b: 5,\n      c: 'hi',\n      d: 1,\n    };\n    r.addRule(newRule, 1, 10);\n    // First rule should still throw while second rule will trigger as well,\n    // causing us to return longer time to reset to user\n    r.increment(matchingInput);\n    r.increment(matchingInput);\n    test.equal(r.check(matchingInput).timeToReset > 50, true);\n  },\n);\n\n\n/****** Test Our Helper Methods *****/\n\nTinytest.add('rate limit tests - test matchRule method', function (test) {\n  const r = new RateLimiter();\n  const globalRule = {\n    userId: null,\n    IPAddr: null,\n    type: null,\n    name: null,\n  };\n  const globalRuleId = r.addRule(globalRule);\n\n  const rateLimiterInput = {\n    userId: 1023,\n    IPAddr: '127.0.0.1',\n    type: 'sub',\n    name: 'getSubLists',\n  };\n\n  test.equal(r.rules[globalRuleId].match(rateLimiterInput), true);\n\n  const oneNotNullRule = {\n    userId: 102,\n    IPAddr: null,\n    type: null,\n    name: null,\n  };\n\n  const oneNotNullId = r.addRule(oneNotNullRule);\n  test.equal(r.rules[oneNotNullId].match(rateLimiterInput), false);\n\n  oneNotNullRule.userId = 1023;\n  test.equal(r.rules[oneNotNullId].match(rateLimiterInput), true);\n\n  const notCompleteInput = {\n    userId: 102,\n    IPAddr: '127.0.0.1',\n  };\n  test.equal(r.rules[globalRuleId].match(notCompleteInput), true);\n  test.equal(r.rules[oneNotNullId].match(notCompleteInput), false);\n});\n\nTinytest.add('rate limit tests - test generateMethodKey string',\n  function (test) {\n    const r = new RateLimiter();\n    const globalRule = {\n      userId: null,\n      IPAddr: null,\n      type: null,\n      name: null,\n    };\n    const globalRuleId = r.addRule(globalRule);\n\n    const rateLimiterInput = {\n      userId: 1023,\n      IPAddr: '127.0.0.1',\n      type: 'sub',\n      name: 'getSubLists',\n    };\n\n    test.equal(r.rules[globalRuleId]._generateKeyString(rateLimiterInput), '');\n    globalRule.userId = 1023;\n\n    test.equal(r.rules[globalRuleId]._generateKeyString(rateLimiterInput),\n      'userId1023');\n\n    const ruleWithFuncs = {\n      userId: input => input % 2 === 0,\n      IPAddr: null,\n      type: null,\n    };\n    const funcRuleId = r.addRule(ruleWithFuncs);\n    test.equal(r.rules[funcRuleId]._generateKeyString(rateLimiterInput), '');\n    rateLimiterInput.userId = 1024;\n    test.equal(r.rules[funcRuleId]._generateKeyString(rateLimiterInput),\n      'userId1024');\n\n    const multipleRules = ruleWithFuncs;\n    multipleRules.IPAddr = '127.0.0.1';\n    const multipleRuleId = r.addRule(multipleRules);\n    test.equal(r.rules[multipleRuleId]._generateKeyString(rateLimiterInput),\n      'userId1024IPAddr127.0.0.1');\n  },\n);\n\nfunction createTempConnectionHandle(id, clientIP) {\n  return {\n    id,\n    close() {\n      this.close();\n    },\n    onClose(fn) {\n      const cb = Meteor.bindEnvironment(fn, 'connection onClose callback');\n      if (this.inQueue) {\n        this._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: clientIP,\n    httpHeaders: null,\n  };\n}\n\nfunction createTempMethodInvocation(userId, connectionHandle, methodName) {\n  const methodInv = new DDPCommon.MethodInvocation({\n    isSimulation: false,\n    userId,\n    setUserId: null,\n    unblock: false,\n    connection: connectionHandle,\n    randomSeed: 1234,\n  });\n  methodInv.method = methodName;\n  return methodInv;\n}\n"]},"sourceType":"script","hash":"3e7832bd438ea5488f4ec7ddffc5a0a478f0df7a"}
