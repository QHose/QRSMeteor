{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/autoupdate/autoupdate_cordova.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/autoupdate/autoupdate_cordova.js","filename":"packages/autoupdate/autoupdate_cordova.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/autoupdate/autoupdate_cordova.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/autoupdate/autoupdate_cordova.js"}},"code":"var autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova || \"unknown\"; // The collection of acceptable client versions.\n\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !!ClientVersions.findOne({\n    _id: 'version-cordova',\n    version: {\n      $ne: autoupdateVersionCordova\n    }\n  });\n};\n\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0,\n  // don't do any immediate retries\n  baseTimeout: 30 * 1000 // start with 30s\n\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n  var appId = __meteor_runtime_config__.appId;\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", appId, {\n    onError: function (error) {\n      console.log(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function () {\n      if (Package.reload) {\n        var checkNewVersionDocument = function (doc) {\n          var self = this;\n\n          if (doc.version !== autoupdateVersionCordova) {\n            newVersionAvailable();\n          }\n        };\n\n        var handle = ClientVersions.find({\n          _id: 'version-cordova'\n        }).observe({\n          added: checkNewVersionDocument,\n          changed: checkNewVersionDocument\n        });\n      }\n    }\n  });\n};\n\nMeteor.startup(function () {\n  WebAppLocalServer.onNewVersionReady(function () {\n    if (Package.reload) {\n      Package.reload.Reload._reload();\n    }\n  });\n\n  Autoupdate._retrySubscription();\n});\n\nvar newVersionAvailable = function () {\n  WebAppLocalServer.checkForUpdates();\n};","map":{"version":3,"sources":["packages/autoupdate/autoupdate_cordova.js"],"names":["autoupdateVersionCordova","__meteor_runtime_config__","ClientVersions","Mongo","Collection","Autoupdate","newClientAvailable","findOne","_id","version","$ne","retry","Retry","minCount","baseTimeout","failures","_retrySubscription","appId","Meteor","subscribe","onError","error","console","log","retryLater","onReady","Package","reload","checkNewVersionDocument","doc","self","newVersionAvailable","handle","find","observe","added","changed","startup","WebAppLocalServer","onNewVersionReady","Reload","_reload","checkForUpdates"],"mappings":"AAAA,IAAIA,2BAA2BC,0BAA0BD,wBAA1B,IAAsD,SAArF,C,CAEA;;AACAE,iBAAiB,IAAIC,MAAMC,UAAV,CAAqB,kCAArB,CAAjB;AAEAC,aAAa,EAAb;;AAEAA,WAAWC,kBAAX,GAAgC,YAAW;AACzC,SAAO,CAAC,CAAEJ,eAAeK,OAAf,CAAuB;AAC/BC,SAAK,iBAD0B;AAE/BC,aAAS;AAACC,WAAKV;AAAN;AAFsB,GAAvB,CAAV;AAID,CALD;;AAOA,IAAIW,QAAQ,IAAIC,KAAJ,CAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,YAAU,CATU;AASP;AACbC,eAAa,KAAG,IAVI,CAUC;;AAVD,CAAV,CAAZ;AAYA,IAAIC,WAAW,CAAf;;AAEAV,WAAWW,kBAAX,GAAgC,YAAW;AACzC,MAAIC,QAAQhB,0BAA0BgB,KAAtC;AACAC,SAAOC,SAAP,CAAiB,kCAAjB,EAAqDF,KAArD,EAA4D;AAC1DG,aAAS,UAASC,KAAT,EAAgB;AACvBC,cAAQC,GAAR,CAAY,iCAAZ,EAA+CF,KAA/C;AACAN;AACAJ,YAAMa,UAAN,CAAiBT,QAAjB,EAA2B,YAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,mBAAWW,kBAAX;AACD,OATD;AAUD,KAdyD;AAe1DS,aAAS,YAAW;AAClB,UAAIC,QAAQC,MAAZ,EAAoB;AAClB,YAAIC,0BAA0B,UAASC,GAAT,EAAc;AAC1C,cAAIC,OAAO,IAAX;;AACA,cAAID,IAAIpB,OAAJ,KAAgBT,wBAApB,EAA8C;AAC5C+B;AACD;AACF,SALD;;AAOA,YAAIC,SAAS9B,eAAe+B,IAAf,CAAoB;AAACzB,eAAK;AAAN,SAApB,EAA8C0B,OAA9C,CAAsD;AACjEC,iBAAOP,uBAD0D;AAEjEQ,mBAASR;AAFwD,SAAtD,CAAb;AAID;AACF;AA7ByD,GAA5D;AA+BD,CAjCD;;AAmCAV,OAAOmB,OAAP,CAAe,YAAW;AACxBC,oBAAkBC,iBAAlB,CAAoC,YAAW;AAC7C,QAAIb,QAAQC,MAAZ,EAAoB;AAClBD,cAAQC,MAAR,CAAea,MAAf,CAAsBC,OAAtB;AACD;AACF,GAJD;;AAMApC,aAAWW,kBAAX;AACD,CARD;;AAUA,IAAIe,sBAAsB,YAAW;AACnCO,oBAAkBI,eAAlB;AACD,CAFD","sourcesContent":["var autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function() {\n  return !! ClientVersions.findOne({\n    _id: 'version-cordova',\n    version: {$ne: autoupdateVersionCordova}\n  });\n};\n\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function() {\n  var appId = __meteor_runtime_config__.appId;\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", appId, {\n    onError: function(error) {\n      console.log(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function() {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function() {\n      if (Package.reload) {\n        var checkNewVersionDocument = function(doc) {\n          var self = this;\n          if (doc.version !== autoupdateVersionCordova) {\n            newVersionAvailable();\n          }\n        };\n\n        var handle = ClientVersions.find({_id: 'version-cordova'}).observe({\n          added: checkNewVersionDocument,\n          changed: checkNewVersionDocument\n        });\n      }\n    }\n  });\n};\n\nMeteor.startup(function() {\n  WebAppLocalServer.onNewVersionReady(function() {\n    if (Package.reload) {\n      Package.reload.Reload._reload();\n    }\n  });\n\n  Autoupdate._retrySubscription();\n});\n\nvar newVersionAvailable = function() {\n  WebAppLocalServer.checkForUpdates();\n}\n"]},"sourceType":"script","hash":"1d83bb8b05233733e4e187f4a695cc372be43cb2"}
