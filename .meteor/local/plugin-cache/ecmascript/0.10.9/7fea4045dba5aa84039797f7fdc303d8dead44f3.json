{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/mongo/oplog_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/mongo/oplog_observe_driver.js","filename":"packages/mongo/oplog_observe_driver.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/mongo/oplog_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/oplog_observe_driver.js"}},"code":"var Future = Npm.require('fibers/future');\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n}; // Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\n\nvar SwitchedToQuery = function () {};\n\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery)) throw e;\n    }\n  };\n};\n\nvar currentId = 0; // OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\n\nOplogObserveDriver = function (options) {\n  var self = this;\n  self._usesOplog = true; // tests look at this\n\n  self._id = currentId;\n  currentId++;\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  var sorter = options.sorter; // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n\n  var comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Min Heap (also implements IdMap methods)\n    var heapOptions = {\n      IdMap: LocalCollection._IdMap\n    };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions); // We need something that can find Max value in addition to IdMap interface\n\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap();\n  } // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n\n\n  self._safeAppendToBuffer = false;\n  self._stopped = false;\n  self._stopHandles = [];\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  self._matcher = options.matcher;\n  var projection = self._cursorDescription.options.fields || {};\n  self._projectionFn = LocalCollection._compileProjection(projection); // Projection function, result of combining important fields for selector and\n  // existing fields projection\n\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection);\n  self._needToFetch = new LocalCollection._IdMap();\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = []; // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  })));\n\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {\n      Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n        var op = notification.op;\n\n        if (notification.dropCollection || notification.dropDatabase) {\n          // Note: this call is not allowed to block on anything (especially\n          // on waiting for oplog entries to catch up) because that will block\n          // onOplogEntry!\n          self._needToPollQuery();\n        } else {\n          // All other operators should be handled depending on phase\n          if (self._phase === PHASE.QUERYING) {\n            self._handleOplogEntryQuerying(op);\n          } else {\n            self._handleOplogEntrySteadyOrFetching(op);\n          }\n        }\n      }));\n    }));\n  }); // XXX ordering w.r.t. everything else?\n\n  self._stopHandles.push(listenAll(self._cursorDescription, function (notification) {\n    // If we're not in a pre-fire write fence, we don't have to do anything.\n    var fence = DDPServer._CurrentWriteFence.get();\n\n    if (!fence || fence.fired) return;\n\n    if (fence._oplogObserveDrivers) {\n      fence._oplogObserveDrivers[self._id] = self;\n      return;\n    }\n\n    fence._oplogObserveDrivers = {};\n    fence._oplogObserveDrivers[self._id] = self;\n    fence.onBeforeFire(function () {\n      var drivers = fence._oplogObserveDrivers;\n      delete fence._oplogObserveDrivers; // This fence cannot fire until we've caught up to \"this point\" in the\n      // oplog, and all observers made it back to the steady state.\n\n      self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n      _.each(drivers, function (driver) {\n        if (driver._stopped) return;\n        var write = fence.beginWrite();\n\n        if (driver._phase === PHASE.STEADY) {\n          // Make sure that all of the callbacks have made it through the\n          // multiplexer and been delivered to ObserveHandles before committing\n          // writes.\n          driver._multiplexer.onFlush(function () {\n            write.committed();\n          });\n        } else {\n          driver._writesToCommitWhenWeReachSteady.push(write);\n        }\n      });\n    });\n  })); // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n\n\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {\n    self._needToPollQuery();\n  }))); // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n\n\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function (id, doc) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      var fields = _.clone(doc);\n\n      delete fields._id;\n\n      self._published.set(id, self._sharedProjectionFn(doc));\n\n      self._multiplexer.added(id, self._projectionFn(fields)); // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n\n\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n\n        self._multiplexer.removed(overflowingDocId);\n\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n\n      self._multiplexer.removed(id);\n\n      if (!self._limit || self._published.size() === self._limit) return;\n      if (self._published.size() > self._limit) throw Error(\"self._published got too big\"); // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n\n        self._removeBuffered(newDocId);\n\n        self._addPublished(newDocId, newDoc);\n\n        return;\n      } // There's nothing in the buffer.  This could mean one of a few things.\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n\n\n      if (self._phase === PHASE.QUERYING) return; // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n\n      if (self._safeAppendToBuffer) return; // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n\n      var projectedNew = self._projectionFn(newDoc);\n\n      var projectedOld = self._projectionFn(oldDoc);\n\n      var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n      if (!_.isEmpty(changed)) self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc)); // If something is overflowing the buffer, we just remove it from cache\n\n\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId); // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n\n\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id); // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n\n\n      if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id)) throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null; // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n\n      var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0; // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit; // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n\n      var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0;\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n\n        var comparator = self._comparator;\n\n        var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n\n        var maxBuffered;\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id); // but it can move into buffered now, check it\n\n\n            maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n            var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id); // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(self._published.maxElementId());\n\n          maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()); // the buffered doc was updated, it could move to published\n\n          var toPublish = comparator(newDoc, maxPublished) < 0; // or stays in buffer even after the change\n\n          var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false; // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n\n            if (!self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.FETCHING); // Defer, because nothing called from the oplog entry handler may yield,\n      // but fetch() yields.\n\n\n      Meteor.defer(finishIfNeedToPollQuery(function () {\n        while (!self._stopped && !self._needToFetch.empty()) {\n          if (self._phase === PHASE.QUERYING) {\n            // While fetching, we decided to go into QUERYING mode, and then we\n            // saw another oplog entry, so _needToFetch is not empty. But we\n            // shouldn't fetch these documents until AFTER the query is done.\n            break;\n          } // Being in steady phase here would be surprising.\n\n\n          if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n          self._currentlyFetching = self._needToFetch;\n          var thisGeneration = ++self._fetchGeneration;\n          self._needToFetch = new LocalCollection._IdMap();\n          var waiting = 0;\n          var fut = new Future(); // This loop is safe, because _currentlyFetching will not be updated\n          // during this loop (in fact, it is never mutated).\n\n          self._currentlyFetching.forEach(function (cacheKey, id) {\n            waiting++;\n\n            self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, cacheKey, finishIfNeedToPollQuery(function (err, doc) {\n              try {\n                if (err) {\n                  Meteor._debug(\"Got exception while fetching documents\", err); // If we get an error from the fetcher (eg, trouble\n                  // connecting to Mongo), let's just abandon the fetch phase\n                  // altogether and fall back to polling. It's not like we're\n                  // getting live updates anyway.\n\n\n                  if (self._phase !== PHASE.QUERYING) {\n                    self._needToPollQuery();\n                  }\n                } else if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                  // We re-check the generation in case we've had an explicit\n                  // _pollQuery call (eg, in another fiber) which should\n                  // effectively cancel this round of fetches.  (_pollQuery\n                  // increments the generation.)\n                  self._handleDoc(id, doc);\n                }\n              } finally {\n                waiting--; // Because fetch() never calls its callback synchronously,\n                // this is safe (ie, we won't call fut.return() before the\n                // forEach is done).\n\n                if (waiting === 0) fut.return();\n              }\n            }));\n          });\n\n          fut.wait(); // Exit now if we've had a _pollQuery call (here or in another fiber).\n\n          if (self._phase === PHASE.QUERYING) return;\n          self._currentlyFetching = null;\n        } // We're done fetching, so we can be steady, unless we've had a\n        // _pollQuery call (here or in another fiber).\n\n\n        if (self._phase !== PHASE.QUERYING) self._beSteady();\n      }));\n    });\n  },\n  _beSteady: function () {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.STEADY);\n\n      var writes = self._writesToCommitWhenWeReachSteady;\n      self._writesToCommitWhenWeReachSteady = [];\n\n      self._multiplexer.onFlush(function () {\n        _.each(writes, function (w) {\n          w.committed();\n        });\n      });\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op.ts.toString());\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op); // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n\n      if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op.ts.toString());\n\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\"); // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n\n        if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset'); // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n\n        var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, _.extend({\n            _id: id\n          }, op.o));\n        } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n          newDoc._id = id;\n\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\") throw e; // We didn't understand the modifier.  Re-fetch.\n\n            self._needToFetch.set(id, op.ts.toString());\n\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n\n            return;\n          }\n\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n          self._needToFetch.set(id, op.ts.toString());\n\n          if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n  // Yields!\n  _runInitialQuery: function () {\n    var self = this;\n    if (self._stopped) throw new Error(\"oplog stopped surprisingly early\");\n\n    self._runQuery({\n      initial: true\n    }); // yields\n\n\n    if (self._stopped) return; // can happen on queryError\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n\n    self._multiplexer.ready();\n\n    self._doneQuerying(); // yields\n\n  },\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped) return; // Yay, we get to forget about all the things we thought we had to fetch.\n\n      self._needToFetch = new LocalCollection._IdMap();\n      self._currentlyFetching = null;\n      ++self._fetchGeneration; // ignore any in-flight fetches\n\n      self._registerPhaseChange(PHASE.QUERYING); // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n\n\n      Meteor.defer(function () {\n        self._runQuery();\n\n        self._doneQuerying();\n      });\n    });\n  },\n  // Yields!\n  _runQuery: function (options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer; // This while loop is just to retry failures.\n\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped) return;\n      newResults = new LocalCollection._IdMap();\n      newBuffer = new LocalCollection._IdMap(); // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n\n      var cursor = self._cursorForQuery({\n        limit: self._limit * 2\n      });\n\n      try {\n        cursor.forEach(function (doc, i) {\n          // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof e.code === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          self._multiplexer.queryError(e);\n\n          return;\n        } // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n\n\n        Meteor._debug(\"Got exception while polling query\", e);\n\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped) return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped) return; // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n\n        throw new SwitchedToQuery();\n      } // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n\n\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n  // Yields!\n  _doneQuerying: function () {\n    var self = this;\n    if (self._stopped) return;\n\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields\n\n\n    if (self._stopped) return;\n    if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase);\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._requeryWhenDoneThisQuery) {\n        self._requeryWhenDoneThisQuery = false;\n\n        self._pollQuery();\n      } else if (self._needToFetch.empty()) {\n        self._beSteady();\n      } else {\n        self._fetchModifiedDocuments();\n      }\n    });\n  },\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = _.clone(self._cursorDescription.options); // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n\n\n      _.extend(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform; // We are NOT deep cloning fields or selector here, which should be OK.\n\n      var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      } // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n\n\n      var idsToRemove = [];\n\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id)) idsToRemove.push(id);\n      });\n\n      _.each(idsToRemove, function (id) {\n        self._removePublished(id);\n      }); // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n\n\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      }); // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n\n      if (self._published.size() !== newResults.size()) {\n        throw Error(\"The Mongo server and the Meteor query disagree on how \" + \"many documents match your query. Maybe it is hitting a Mongo \" + \"edge case? The query is: \" + EJSON.stringify(self._cursorDescription.selector));\n      }\n\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      }); // Finally, replace the buffer\n\n\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._stopped = true;\n\n    _.each(self._stopHandles, function (handle) {\n      handle.stop();\n    }); // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n\n\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n      w.committed(); // maybe yields?\n    });\n\n    self._writesToCommitWhenWeReachSteady = null; // Proactively drop references to potentially big things.\n\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  },\n  _registerPhaseChange: function (phase) {\n    var self = this;\n\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date();\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n}); // Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\n\n\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options; // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n\n  if (options.disableOplog || options._disableOplog) return false; // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n\n  if (options.skip || options.limit && !options.sort) return false; // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n\n  if (options.fields) {\n    try {\n      LocalCollection._checkSupportedProjection(options.fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  } // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n\n\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;","map":{"version":3,"sources":["packages/mongo/oplog_observe_driver.js"],"names":["Future","Npm","require","PHASE","QUERYING","FETCHING","STEADY","SwitchedToQuery","finishIfNeedToPollQuery","f","apply","arguments","e","currentId","OplogObserveDriver","options","self","_usesOplog","_id","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_multiplexer","multiplexer","ordered","Error","sorter","comparator","getComparator","limit","heapOptions","IdMap","LocalCollection","_IdMap","_limit","_comparator","_sorter","_unpublishedBuffer","MinMaxHeap","_published","MaxHeap","_safeAppendToBuffer","_stopped","_stopHandles","Package","Facts","incrementServerFact","_registerPhaseChange","_matcher","matcher","projection","fields","_projectionFn","_compileProjection","_sharedProjection","combineIntoProjection","_sharedProjectionFn","_needToFetch","_currentlyFetching","_fetchGeneration","_requeryWhenDoneThisQuery","_writesToCommitWhenWeReachSteady","push","_oplogHandle","onSkippedEntries","_needToPollQuery","forEachTrigger","trigger","onOplogEntry","notification","Meteor","_noYieldsAllowed","op","dropCollection","dropDatabase","_phase","_handleOplogEntryQuerying","_handleOplogEntrySteadyOrFetching","listenAll","fence","DDPServer","_CurrentWriteFence","get","fired","_oplogObserveDrivers","onBeforeFire","drivers","waitUntilCaughtUp","_","each","driver","write","beginWrite","onFlush","committed","_onFailover","defer","_runInitialQuery","extend","prototype","_addPublished","id","doc","clone","set","added","size","overflowingDocId","maxElementId","overflowingDoc","EJSON","equals","remove","removed","_addBuffered","_removePublished","empty","newDocId","minElementId","newDoc","_removeBuffered","_changePublished","oldDoc","projectedNew","projectedOld","changed","DiffSequence","makeChangedFields","isEmpty","maxBufferedId","_addMatching","has","maxPublished","maxBuffered","toPublish","canAppendToBuffer","canInsertIntoBuffer","toBuffer","_removeMatching","_handleDoc","matchesNow","documentMatches","result","publishedBefore","bufferedBefore","cachedBefore","minBuffered","staysInPublished","staysInBuffer","_fetchModifiedDocuments","thisGeneration","waiting","fut","forEach","cacheKey","_docFetcher","fetch","collectionName","err","_debug","return","wait","_beSteady","writes","w","idForOp","ts","toString","o","isReplace","canDirectlyModifyDoc","modifierCanBeDirectlyApplied","_modify","name","canBecomeTrueByModifier","affectedByModifier","_runQuery","initial","ready","_doneQuerying","_pollQuery","newResults","newBuffer","cursor","_cursorForQuery","i","code","queryError","_sleepForMs","_publishNewResults","optionsOverwrite","transform","description","CursorDescription","selector","Cursor","clear","idsToRemove","stringify","stop","handle","_oplogEntryHandle","_listenersHandle","phase","now","Date","timeDiff","_phaseStartTime","cursorSupported","disableOplog","_disableOplog","skip","sort","_checkSupportedProjection","hasWhere","hasGeoQuery","modifier","all","operation","value","field","test","MongoInternals"],"mappings":"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","sourcesContent":["var Future = Npm.require('fibers/future');\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery))\n        throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows\n// the Mongo operation log instead of just re-polling the query. It obeys the\n// same simple interface: constructing it starts sending observeChanges\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop\n// it by calling the stop() method.\nOplogObserveDriver = function (options) {\n  var self = this;\n  self._usesOplog = true;  // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  var sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  var comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Min Heap (also implements IdMap methods)\n\n    var heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    self._published = new LocalCollection._IdMap;\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  self._matcher = options.matcher;\n  var projection = self._cursorDescription.options.fields || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter)\n    self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(\n    self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap;\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n\n  // If the oplog handle tells us that it skipped some entries (because it got\n  // behind, say), re-poll.\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(\n    finishIfNeedToPollQuery(function () {\n      self._needToPollQuery();\n    })\n  ));\n\n  forEachTrigger(self._cursorDescription, function (trigger) {\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(\n      trigger, function (notification) {\n        Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n          var op = notification.op;\n          if (notification.dropCollection || notification.dropDatabase) {\n            // Note: this call is not allowed to block on anything (especially\n            // on waiting for oplog entries to catch up) because that will block\n            // onOplogEntry!\n            self._needToPollQuery();\n          } else {\n            // All other operators should be handled depending on phase\n            if (self._phase === PHASE.QUERYING) {\n              self._handleOplogEntryQuerying(op);\n            } else {\n              self._handleOplogEntrySteadyOrFetching(op);\n            }\n          }\n        }));\n      }\n    ));\n  });\n\n  // XXX ordering w.r.t. everything else?\n  self._stopHandles.push(listenAll(\n    self._cursorDescription, function (notification) {\n      // If we're not in a pre-fire write fence, we don't have to do anything.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (!fence || fence.fired)\n        return;\n\n      if (fence._oplogObserveDrivers) {\n        fence._oplogObserveDrivers[self._id] = self;\n        return;\n      }\n\n      fence._oplogObserveDrivers = {};\n      fence._oplogObserveDrivers[self._id] = self;\n\n      fence.onBeforeFire(function () {\n        var drivers = fence._oplogObserveDrivers;\n        delete fence._oplogObserveDrivers;\n\n        // This fence cannot fire until we've caught up to \"this point\" in the\n        // oplog, and all observers made it back to the steady state.\n        self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n        _.each(drivers, function (driver) {\n          if (driver._stopped)\n            return;\n\n          var write = fence.beginWrite();\n          if (driver._phase === PHASE.STEADY) {\n            // Make sure that all of the callbacks have made it through the\n            // multiplexer and been delivered to ObserveHandles before committing\n            // writes.\n            driver._multiplexer.onFlush(function () {\n              write.committed();\n            });\n          } else {\n            driver._writesToCommitWhenWeReachSteady.push(write);\n          }\n        });\n      });\n    }\n  ));\n\n  // When Mongo fails over, we need to repoll the query, in case we processed an\n  // oplog entry that got rolled back.\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(\n    function () {\n      self._needToPollQuery();\n    })));\n\n  // Give _observeChanges a chance to add the new ObserveHandle to our\n  // multiplexer, so that the added calls get streamed.\n  Meteor.defer(finishIfNeedToPollQuery(function () {\n    self._runInitialQuery();\n  }));\n};\n\n_.extend(OplogObserveDriver.prototype, {\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = _.clone(doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" +\n                          (self._published.size() - self._limit) +\n                          \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (! self._limit || self._published.size() === self._limit)\n        return;\n\n      if (self._published.size() > self._limit)\n        throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING)\n        return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer)\n        return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(\n        projectedNew, projectedOld);\n      if (!_.isEmpty(changed))\n        self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (! self._unpublishedBuffer.size() && ! self._safeAppendToBuffer)\n        self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id))\n        throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id))\n        throw Error(\"tried to add something already existed in buffer \" + id);\n\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = (limit && self._published.size() > 0) ?\n        self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = (limit && self._unpublishedBuffer.size() > 0)\n        ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId())\n        : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = ! limit || self._published.size() < limit ||\n        comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer &&\n        self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered &&\n        comparator(doc, maxBuffered) <= 0;\n\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (! self._published.has(id) && ! self._limit)\n        throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() &&\n          self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n        var maxBuffered;\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = ! self._limit ||\n            self._unpublishedBuffer.size() === 0 ||\n            comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            maxBuffered = self._unpublishedBuffer.get(\n              self._unpublishedBuffer.maxElementId());\n\n            var toBuffer = self._safeAppendToBuffer ||\n                  (maxBuffered && comparator(newDoc, maxBuffered) <= 0);\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(\n            self._published.maxElementId());\n          maxBuffered = self._unpublishedBuffer.size() &&\n                self._unpublishedBuffer.get(\n                  self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = (! toPublish && self._safeAppendToBuffer) ||\n                (!toPublish && maxBuffered &&\n                 comparator(newDoc, maxBuffered) <= 0);\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (! self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.FETCHING);\n      // Defer, because nothing called from the oplog entry handler may yield,\n      // but fetch() yields.\n      Meteor.defer(finishIfNeedToPollQuery(function () {\n        while (!self._stopped && !self._needToFetch.empty()) {\n          if (self._phase === PHASE.QUERYING) {\n            // While fetching, we decided to go into QUERYING mode, and then we\n            // saw another oplog entry, so _needToFetch is not empty. But we\n            // shouldn't fetch these documents until AFTER the query is done.\n            break;\n          }\n\n          // Being in steady phase here would be surprising.\n          if (self._phase !== PHASE.FETCHING)\n            throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n          self._currentlyFetching = self._needToFetch;\n          var thisGeneration = ++self._fetchGeneration;\n          self._needToFetch = new LocalCollection._IdMap;\n          var waiting = 0;\n          var fut = new Future;\n          // This loop is safe, because _currentlyFetching will not be updated\n          // during this loop (in fact, it is never mutated).\n          self._currentlyFetching.forEach(function (cacheKey, id) {\n            waiting++;\n            self._mongoHandle._docFetcher.fetch(\n              self._cursorDescription.collectionName, id, cacheKey,\n              finishIfNeedToPollQuery(function (err, doc) {\n                try {\n                  if (err) {\n                    Meteor._debug(\"Got exception while fetching documents\",\n                                  err);\n                    // If we get an error from the fetcher (eg, trouble\n                    // connecting to Mongo), let's just abandon the fetch phase\n                    // altogether and fall back to polling. It's not like we're\n                    // getting live updates anyway.\n                    if (self._phase !== PHASE.QUERYING) {\n                      self._needToPollQuery();\n                    }\n                  } else if (!self._stopped && self._phase === PHASE.FETCHING\n                             && self._fetchGeneration === thisGeneration) {\n                    // We re-check the generation in case we've had an explicit\n                    // _pollQuery call (eg, in another fiber) which should\n                    // effectively cancel this round of fetches.  (_pollQuery\n                    // increments the generation.)\n                    self._handleDoc(id, doc);\n                  }\n                } finally {\n                  waiting--;\n                  // Because fetch() never calls its callback synchronously,\n                  // this is safe (ie, we won't call fut.return() before the\n                  // forEach is done).\n                  if (waiting === 0)\n                    fut.return();\n                }\n              }));\n          });\n          fut.wait();\n          // Exit now if we've had a _pollQuery call (here or in another fiber).\n          if (self._phase === PHASE.QUERYING)\n            return;\n          self._currentlyFetching = null;\n        }\n        // We're done fetching, so we can be steady, unless we've had a\n        // _pollQuery call (here or in another fiber).\n        if (self._phase !== PHASE.QUERYING)\n          self._beSteady();\n      }));\n    });\n  },\n  _beSteady: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._registerPhaseChange(PHASE.STEADY);\n      var writes = self._writesToCommitWhenWeReachSteady;\n      self._writesToCommitWhenWeReachSteady = [];\n      self._multiplexer.onFlush(function () {\n        _.each(writes, function (w) {\n          w.committed();\n        });\n      });\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op.ts.toString());\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n      if (self._phase === PHASE.FETCHING &&\n          ((self._currentlyFetching && self._currentlyFetching.has(id)) ||\n           self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op.ts.toString());\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) ||\n            (self._limit && self._unpublishedBuffer.has(id)))\n          self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id))\n          throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id))\n          throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result)\n          self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc =\n          !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, _.extend({_id: id}, op.o));\n        } else if ((publishedBefore || bufferedBefore) &&\n                   canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id)\n            ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\")\n              throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op.ts.toString());\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc ||\n                   self._matcher.canBecomeTrueByModifier(op.o) ||\n                   (self._sorter && self._sorter.affectedByModifier(op.o))) {\n          self._needToFetch.set(id, op.ts.toString());\n          if (self._phase === PHASE.STEADY)\n            self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n  // Yields!\n  _runInitialQuery: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"oplog stopped surprisingly early\");\n\n    self._runQuery({initial: true});  // yields\n\n    if (self._stopped)\n      return;  // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    self._multiplexer.ready();\n\n    self._doneQuerying();  // yields\n  },\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap;\n      self._currentlyFetching = null;\n      ++self._fetchGeneration;  // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(function () {\n        self._runQuery();\n        self._doneQuerying();\n      });\n    });\n  },\n\n  // Yields!\n  _runQuery: function (options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped)\n        return;\n\n      newResults = new LocalCollection._IdMap;\n      newBuffer = new LocalCollection._IdMap;\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n      try {\n        cursor.forEach(function (doc, i) {  // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof(e.code) === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query\", e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery;\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n\n  // Yields!\n  _doneQuerying: function () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp();  // yields\n    if (self._stopped)\n      return;\n    if (self._phase !== PHASE.QUERYING)\n      throw Error(\"Phase unexpectedly \" + self._phase);\n\n    Meteor._noYieldsAllowed(function () {\n      if (self._requeryWhenDoneThisQuery) {\n        self._requeryWhenDoneThisQuery = false;\n        self._pollQuery();\n      } else if (self._needToFetch.empty()) {\n        self._beSteady();\n      } else {\n        self._fetchModifiedDocuments();\n      }\n    });\n  },\n\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = _.clone(self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      _.extend(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(\n        self._cursorDescription.collectionName,\n        self._cursorDescription.selector,\n        options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          idsToRemove.push(id);\n      });\n      _.each(idsToRemove, function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        throw Error(\n          \"The Mongo server and the Meteor query disagree on how \" +\n            \"many documents match your query. Maybe it is hitting a Mongo \" +\n            \"edge case? The query is: \" +\n            EJSON.stringify(self._cursorDescription.selector));\n      }\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    _.each(self._stopHandles, function (handle) {\n      handle.stop();\n    });\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n      w.committed();  // maybe yields?\n    });\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  },\n\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date;\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n          \"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog)\n    return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || (options.limit && !options.sort)) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  if (options.fields) {\n    try {\n      LocalCollection._checkSupportedProjection(options.fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return _.all(modifier, function (fields, operation) {\n    return _.all(fields, function (value, field) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;\n"]},"sourceType":"script","hash":"7fea4045dba5aa84039797f7fdc303d8dead44f3"}
