{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/minimongo/minimongo_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/minimongo/minimongo_server.js","filename":"packages/minimongo/minimongo_server.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","generatorOpts":{"filename":"packages/minimongo/minimongo_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/minimongo_server.js"}},"code":"module.watch(require(\"./minimongo_common.js\"));\nvar hasOwn, isNumericKey, isOperatorObject, pathsToTree, projectionDetails;\nmodule.watch(require(\"./common.js\"), {\n  hasOwn: function (v) {\n    hasOwn = v;\n  },\n  isNumericKey: function (v) {\n    isNumericKey = v;\n  },\n  isOperatorObject: function (v) {\n    isOperatorObject = v;\n  },\n  pathsToTree: function (v) {\n    pathsToTree = v;\n  },\n  projectionDetails: function (v) {\n    projectionDetails = v;\n  }\n}, 0);\n\nMinimongo._pathsElidingNumericKeys = function (paths) {\n  return paths.map(function (path) {\n    return path.split('.').filter(function (part) {\n      return !isNumericKey(part);\n    }).join('.');\n  });\n}; // Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\n\n\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n\n  var meaningfulPaths = this._getPaths();\n\n  var modifiedPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n  return modifiedPaths.some(function (path) {\n    var mod = path.split('.');\n    return meaningfulPaths.some(function (meaningfulPath) {\n      var sel = meaningfulPath.split('.');\n      var i = 0,\n          j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      } // One is a prefix of another, taking numeric fields into account\n\n\n      return true;\n    });\n  });\n}; // @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\n\n\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n  var _this = this;\n\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({\n    $set: {},\n    $unset: {}\n  }, modifier);\n  var modifierPaths = [].concat(Object.keys(modifier.$set), Object.keys(modifier.$unset));\n\n  if (this._getPaths().some(pathHasNumericKeys) || modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  } // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n\n\n  var expectedScalarIsObject = Object.keys(this._selector).some(function (path) {\n    if (!isOperatorObject(_this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(function (modifierPath) {\n      return modifierPath.startsWith(path + \".\");\n    });\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  } // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n\n\n  var matchingDocument = EJSON.clone(this.matchingDocument()); // The selector is too complex, anything can happen.\n\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n}; // Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\n\n\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n  var selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths()); // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n\n\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n}; // Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\n\n\nMinimongo.Matcher.prototype.matchingDocument = function () {\n  var _this2 = this;\n\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  } // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n\n\n  var fallback = false;\n  this._matchingDocument = pathsToTree(this._getPaths(), function (path) {\n    var valueSelector = _this2._selector[path];\n\n    if (isOperatorObject(valueSelector)) {\n      // if there is a strict equality, there is a good\n      // chance we can use one of those as \"matching\"\n      // dummy value\n      if (valueSelector.$eq) {\n        return valueSelector.$eq;\n      }\n\n      if (valueSelector.$in) {\n        var matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        }); // Return anything from $in that matches the whole selector for this\n        // path. If nothing matches, returns `undefined` as nothing can make\n        // this selector into `true`.\n\n        return valueSelector.$in.find(function (placeholder) {\n          return matcher.documentMatches({\n            placeholder: placeholder\n          }).result;\n        });\n      }\n\n      if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n        var lowerBound = -Infinity;\n        var upperBound = Infinity;\n        ['$lte', '$lt'].forEach(function (op) {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] < upperBound) {\n            upperBound = valueSelector[op];\n          }\n        });\n        ['$gte', '$gt'].forEach(function (op) {\n          if (hasOwn.call(valueSelector, op) && valueSelector[op] > lowerBound) {\n            lowerBound = valueSelector[op];\n          }\n        });\n        var middle = (lowerBound + upperBound) / 2;\n\n        var _matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        });\n\n        if (!_matcher.documentMatches({\n          placeholder: middle\n        }).result && (middle === lowerBound || middle === upperBound)) {\n          fallback = true;\n        }\n\n        return middle;\n      }\n\n      if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n        // Since this._isSimple makes sure $nin and $ne are not combined with\n        // objects or arrays, we can confidently return an empty object as it\n        // never matches any scalar.\n        return {};\n      }\n\n      fallback = true;\n    }\n\n    return _this2._selector[path];\n  }, function (x) {\n    return x;\n  });\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n}; // Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\n\n\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function (projection) {\n  return combineImportantPathsIntoProjection(Minimongo._pathsElidingNumericKeys(this._getPaths()), projection);\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  var details = projectionDetails(projection); // merge the paths to include\n\n  var tree = pathsToTree(paths, function (path) {\n    return true;\n  }, function (node, path, fullPath) {\n    return true;\n  }, details.tree);\n  var mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n\n\n  var mergedExclProjection = {};\n  Object.keys(mergedProjection).forEach(function (path) {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths); // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n} // A helper to ensure object has only certain keys\n\n\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(function (k) {\n    return keys.includes(k);\n  });\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n} // Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\n\n\nfunction treeToPaths(tree) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var result = {};\n  Object.keys(tree).forEach(function (key) {\n    var value = tree[key];\n\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, prefix + key + \".\"));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["packages/minimongo/minimongo_server.js"],"names":["module","watch","require","hasOwn","isNumericKey","isOperatorObject","pathsToTree","projectionDetails","v","Minimongo","_pathsElidingNumericKeys","paths","map","path","split","filter","part","join","Matcher","prototype","affectedByModifier","modifier","Object","assign","$set","$unset","meaningfulPaths","_getPaths","modifiedPaths","concat","keys","some","mod","sel","meaningfulPath","i","j","length","canBecomeTrueByModifier","isSimple","modifierPaths","pathHasNumericKeys","expectedScalarIsObject","_selector","modifierPath","startsWith","matchingDocument","EJSON","clone","LocalCollection","_modify","error","name","setPropertyError","documentMatches","result","combineIntoProjection","projection","selectorPaths","includes","combineImportantPathsIntoProjection","_matchingDocument","undefined","fallback","valueSelector","$eq","$in","matcher","placeholder","find","onlyContainsKeys","lowerBound","Infinity","upperBound","forEach","call","op","middle","x","Sorter","_selectorForAffectedByModifier","details","tree","node","fullPath","mergedProjection","treeToPaths","including","mergedExclProjection","getPaths","selector","_paths","obj","every","k","prefix","value","key"],"mappings":"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","sourcesContent":["import './minimongo_common.js';\nimport {\n  hasOwn,\n  isNumericKey,\n  isOperatorObject,\n  pathsToTree,\n  projectionDetails,\n} from './common.js';\n\nMinimongo._pathsElidingNumericKeys = paths => paths.map(path =>\n  path.split('.').filter(part => !isNumericKey(part)).join('.')\n);\n\n// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function(modifier) {\n  // safe check for $set/$unset being objects\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const meaningfulPaths = this._getPaths();\n  const modifiedPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  return modifiedPaths.some(path => {\n    const mod = path.split('.');\n\n    return meaningfulPaths.some(meaningfulPath => {\n      const sel = meaningfulPath.split('.');\n\n      let i = 0, j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) {\n            i++;\n            j++;\n          } else {\n            return false;\n          }\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) {\n          i++;\n          j++;\n        } else {\n          return false;\n        }\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function(modifier) {\n  if (!this.affectedByModifier(modifier)) {\n    return false;\n  }\n\n  if (!this.isSimple()) {\n    return true;\n  }\n\n  modifier = Object.assign({$set: {}, $unset: {}}, modifier);\n\n  const modifierPaths = [].concat(\n    Object.keys(modifier.$set),\n    Object.keys(modifier.$unset)\n  );\n\n  if (this._getPaths().some(pathHasNumericKeys) ||\n      modifierPaths.some(pathHasNumericKeys)) {\n    return true;\n  }\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  const expectedScalarIsObject = Object.keys(this._selector).some(path => {\n    if (!isOperatorObject(this._selector[path])) {\n      return false;\n    }\n\n    return modifierPaths.some(modifierPath =>\n      modifierPath.startsWith(`${path}.`)\n    );\n  });\n\n  if (expectedScalarIsObject) {\n    return false;\n  }\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  const matchingDocument = EJSON.clone(this.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null) {\n    return true;\n  }\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (error) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (error.name === 'MinimongoError' && error.setPropertyError) {\n      return false;\n    }\n\n    throw error;\n  }\n\n  return this.documentMatches(matchingDocument).result;\n};\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function(projection) {\n  const selectorPaths = Minimongo._pathsElidingNumericKeys(this._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (selectorPaths.includes('')) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function() {\n  // check if it was computed before\n  if (this._matchingDocument !== undefined) {\n    return this._matchingDocument;\n  }\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  let fallback = false;\n\n  this._matchingDocument = pathsToTree(\n    this._getPaths(),\n    path => {\n      const valueSelector = this._selector[path];\n\n      if (isOperatorObject(valueSelector)) {\n        // if there is a strict equality, there is a good\n        // chance we can use one of those as \"matching\"\n        // dummy value\n        if (valueSelector.$eq) {\n          return valueSelector.$eq;\n        }\n\n        if (valueSelector.$in) {\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          // Return anything from $in that matches the whole selector for this\n          // path. If nothing matches, returns `undefined` as nothing can make\n          // this selector into `true`.\n          return valueSelector.$in.find(placeholder =>\n            matcher.documentMatches({placeholder}).result\n          );\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n          let lowerBound = -Infinity;\n          let upperBound = Infinity;\n\n          ['$lte', '$lt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] < upperBound) {\n              upperBound = valueSelector[op];\n            }\n          });\n\n          ['$gte', '$gt'].forEach(op => {\n            if (hasOwn.call(valueSelector, op) &&\n                valueSelector[op] > lowerBound) {\n              lowerBound = valueSelector[op];\n            }\n          });\n\n          const middle = (lowerBound + upperBound) / 2;\n          const matcher = new Minimongo.Matcher({placeholder: valueSelector});\n\n          if (!matcher.documentMatches({placeholder: middle}).result &&\n              (middle === lowerBound || middle === upperBound)) {\n            fallback = true;\n          }\n\n          return middle;\n        }\n\n        if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n          // Since this._isSimple makes sure $nin and $ne are not combined with\n          // objects or arrays, we can confidently return an empty object as it\n          // never matches any scalar.\n          return {};\n        }\n\n        fallback = true;\n      }\n\n      return this._selector[path];\n    },\n    x => x);\n\n  if (fallback) {\n    this._matchingDocument = null;\n  }\n\n  return this._matchingDocument;\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function(modifier) {\n  return this._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\nMinimongo.Sorter.prototype.combineIntoProjection = function(projection) {\n  return combineImportantPathsIntoProjection(\n    Minimongo._pathsElidingNumericKeys(this._getPaths()),\n    projection\n  );\n};\n\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  const details = projectionDetails(projection);\n\n  // merge the paths to include\n  const tree = pathsToTree(\n    paths,\n    path => true,\n    (node, path, fullPath) => true,\n    details.tree\n  );\n  const mergedProjection = treeToPaths(tree);\n\n  if (details.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  }\n\n  // selector is pointing at fields to include\n  // projection is pointing at fields to exclude\n  // make sure we don't exclude important paths\n  const mergedExclProjection = {};\n\n  Object.keys(mergedProjection).forEach(path => {\n    if (!mergedProjection[path]) {\n      mergedExclProjection[path] = false;\n    }\n  });\n\n  return mergedExclProjection;\n}\n\nfunction getPaths(selector) {\n  return Object.keys(new Minimongo.Matcher(selector)._paths);\n\n  // XXX remove it?\n  // return Object.keys(selector).map(k => {\n  //   // we don't know how to handle $where because it can be anything\n  //   if (k === '$where') {\n  //     return ''; // matches everything\n  //   }\n\n  //   // we branch from $or/$and/$nor operator\n  //   if (['$or', '$and', '$nor'].includes(k)) {\n  //     return selector[k].map(getPaths);\n  //   }\n\n  //   // the value is a literal or some comparison operator\n  //   return k;\n  // })\n  //   .reduce((a, b) => a.concat(b), [])\n  //   .filter((a, b, c) => c.indexOf(a) === b);\n}\n\n// A helper to ensure object has only certain keys\nfunction onlyContainsKeys(obj, keys) {\n  return Object.keys(obj).every(k => keys.includes(k));\n}\n\nfunction pathHasNumericKeys(path) {\n  return path.split('.').some(isNumericKey);\n}\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nfunction treeToPaths(tree, prefix = '') {\n  const result = {};\n\n  Object.keys(tree).forEach(key => {\n    const value = tree[key];\n    if (value === Object(value)) {\n      Object.assign(result, treeToPaths(value, `${prefix + key}.`));\n    } else {\n      result[prefix + key] = value;\n    }\n  });\n\n  return result;\n}\n"]},"sourceType":"script","hash":"594c0baf9c0409d64b6cd5bb91cf711003678c37"}
