{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/ddp-server/livedata_server_tests.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/ddp-server/livedata_server_tests.js","filename":"packages/ddp-server/livedata_server_tests.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/ddp-server/livedata_server_tests.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/livedata_server_tests.js"}},"code":"var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"livedata server - connectionHandle.onClose()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // On the server side, wait for the connection to be closed.\n    serverConn.onClose(function () {\n      test.isTrue(true); // Add a new onClose after the connection is already\n      // closed. See that it fires.\n\n      serverConn.onClose(function () {\n        onComplete();\n      });\n    }); // Close the connection from the client.\n\n    clientConn.disconnect();\n  }, onComplete);\n});\nTinytest.addAsync(\"livedata server - connectionHandle.close()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Wait for the connection to be closed from the server side.\n    simplePoll(function () {\n      return !clientConn.status().connected;\n    }, onComplete, function () {\n      test.fail(\"timeout waiting for the connection to be closed on the server side\");\n      onComplete();\n    }); // Close the connection from the server.\n\n    serverConn.close();\n  }, onComplete);\n});\ntestAsyncMulti(\"livedata server - onConnection doesn't get callback after stop.\", [function (test, expect) {\n  var afterStop = false;\n  var expectStop1 = expect();\n  var stopHandle1 = Meteor.onConnection(function (conn) {\n    stopHandle2.stop();\n    stopHandle1.stop();\n    afterStop = true; // yield to the event loop for a moment to see that no other calls\n    // to listener2 are called.\n\n    Meteor.setTimeout(expectStop1, 10);\n  });\n  var stopHandle2 = Meteor.onConnection(function (conn) {\n    test.isFalse(afterStop);\n  }); // trigger a connection\n\n  var expectConnection = expect();\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Close the connection from the client.\n    clientConn.disconnect();\n    expectConnection();\n  }, expectConnection);\n}]);\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection && this.connection.id;\n  },\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  },\n  livedata_server_test_setuserid: function (userId) {\n    this.setUserId(userId);\n  }\n});\nTinytest.addAsync(\"livedata server - onMessage hook\", function (test, onComplete) {\n  var cb = Meteor.onMessage(function (msg, session) {\n    test.equal(msg.method, 'livedata_server_test_inner');\n    cb.stop();\n    onComplete();\n  });\n  makeTestConnection(test, function (clientConn, serverConn) {\n    clientConn.call('livedata_server_test_inner');\n    clientConn.disconnect();\n  }, onComplete);\n});\nTinytest.addAsync(\"livedata server - connection in method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_inner');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\nTinytest.addAsync(\"livedata server - connection in nested method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_outer');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n}); // connectionId -> callback\n\nvar onSubscription = {};\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) callback(this);\n  this.stop();\n});\nMeteor.publish(\"livedata_server_test_sub_method\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n\n  if (callback) {\n    var id = Meteor.call('livedata_server_test_inner');\n    callback(id);\n  }\n\n  this.stop();\n});\nMeteor.publish(\"livedata_server_test_sub_context\", function (connectionId, userId) {\n  var callback = onSubscription[connectionId];\n\n  var methodInvocation = DDP._CurrentMethodInvocation.get();\n\n  var publicationInvocation = DDP._CurrentPublicationInvocation.get(); // Check the publish function's environment variables and context.\n\n\n  if (callback) {\n    callback.call(this, methodInvocation, publicationInvocation);\n  } // Check that onStop callback is have the same context as the publish function\n  // and that it runs with the same environment variables as this publish function.\n\n\n  this.onStop(function () {\n    var onStopMethodInvocation = DDP._CurrentMethodInvocation.get();\n\n    var onStopPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n\n    callback.call(this, onStopMethodInvocation, onStopPublicationInvocation, true);\n  });\n\n  if (this.userId) {\n    this.stop();\n  } else {\n    this.ready();\n    Meteor.call('livedata_server_test_setuserid', userId);\n  }\n});\nTinytest.addAsync(\"livedata server - connection in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (subscription) {\n      delete onSubscription[serverConn.id];\n      test.equal(subscription.connection.id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n\n    clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n  });\n});\nTinytest.addAsync(\"livedata server - connection in method called from publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (id) {\n      delete onSubscription[serverConn.id];\n      test.equal(id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n\n    clientConn.subscribe(\"livedata_server_test_sub_method\", serverConn.id);\n  });\n});\nTinytest.addAsync(\"livedata server - verify context in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var userId = 'someUserId';\n\n    onSubscription[serverConn.id] = function (methodInvocation, publicationInvocation, fromOnStop) {\n      // DDP._CurrentMethodInvocation should be undefined in a publish function\n      test.isUndefined(methodInvocation, 'Should have been undefined'); // DDP._CurrentPublicationInvocation should be set in a publish function\n\n      test.isNotUndefined(publicationInvocation, 'Should have been defined');\n\n      if (this.userId === userId && fromOnStop) {\n        delete onSubscription[serverConn.id];\n        clientConn.disconnect();\n        onComplete();\n      }\n    };\n\n    clientConn.subscribe(\"livedata_server_test_sub_context\", serverConn.id, userId);\n  });\n});\nlet onSubscriptions = {};\nMeteor.publish({\n  publicationObject() {\n    let callback = onSubscriptions;\n    if (callback) callback();\n    this.stop();\n  }\n\n});\nMeteor.publish({\n  \"publication_object\": function () {\n    let callback = onSubscriptions;\n    if (callback) callback();\n    this.stop();\n  }\n});\nMeteor.publish(\"publication_compatibility\", function () {\n  let callback = onSubscriptions;\n  if (callback) callback();\n  this.stop();\n});\nTinytest.addAsync(\"livedata server - publish object\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    let testsLength = 0;\n\n    onSubscriptions = function (subscription) {\n      delete onSubscriptions;\n      clientConn.disconnect();\n      testsLength++;\n\n      if (testsLength == 3) {\n        onComplete();\n      }\n    };\n\n    clientConn.subscribe(\"publicationObject\");\n    clientConn.subscribe(\"publication_object\");\n    clientConn.subscribe(\"publication_compatibility\");\n  });\n});\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentMethodInvocation.get();\n\n    return Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentMethodInvocation.get(); // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n\n\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  },\n\n  testRejectedPromiseWithGenericError(arg) {\n    return Promise.resolve(arg).then(result => {\n      const error = new Error('MESSAGE');\n      error.error = 'ERROR';\n      error.reason = 'REASON';\n      error.details = {\n        foo: 'bar'\n      };\n      error.isClientSafe = true;\n      throw error;\n    });\n  }\n\n});\nTinytest.addAsync(\"livedata server - waiting for Promise\", (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n  test.equal(clientConn.call(\"testResolvedPromise\", \"clientConn.call\"), \"clientConn.call after waiting\");\n  const clientCallPromise = new Promise((resolve, reject) => clientConn.call(\"testResolvedPromise\", \"clientConn.call with callback\", (error, result) => error ? reject(error) : resolve(result)));\n  const serverCallAsyncPromise = Meteor.server.callAsync(\"testResolvedPromise\", \"Meteor.server.callAsync\");\n  const serverApplyAsyncPromise = Meteor.server.applyAsync(\"testResolvedPromise\", [\"Meteor.server.applyAsync\"]);\n  const clientCallRejectedPromise = new Promise(resolve => {\n    clientConn.call(\"testRejectedPromise\", \"with callback\", (error, result) => resolve(error.message));\n  });\n  const clientCallRejectedPromiseWithGenericError = new Promise(resolve => {\n    clientConn.call(\"testRejectedPromiseWithGenericError\", (error, result) => resolve({\n      message: error.message,\n      error: error.error,\n      reason: error.reason,\n      details: error.details\n    }));\n  });\n  Promise.all([clientCallPromise, clientCallRejectedPromise, clientCallRejectedPromiseWithGenericError, serverCallAsyncPromise, serverApplyAsyncPromise]).then(results => test.equal(results, [\"clientConn.call with callback after waiting\", \"[with callback raised Meteor.Error]\", {\n    message: 'REASON [ERROR]',\n    error: 'ERROR',\n    reason: 'REASON',\n    details: {\n      foo: 'bar'\n    }\n  }, \"Meteor.server.callAsync after waiting\", \"Meteor.server.applyAsync after waiting\"]), error => test.fail(error)).then(onComplete);\n}));","map":{"version":3,"sources":["packages/ddp-server/livedata_server_tests.js"],"names":["Fiber","Npm","require","Tinytest","addAsync","test","onComplete","makeTestConnection","clientConn","serverConn","onClose","isTrue","disconnect","simplePoll","status","connected","fail","close","testAsyncMulti","expect","afterStop","expectStop1","stopHandle1","Meteor","onConnection","conn","stopHandle2","stop","setTimeout","isFalse","expectConnection","methods","livedata_server_test_inner","connection","id","livedata_server_test_outer","call","livedata_server_test_setuserid","userId","setUserId","cb","onMessage","msg","session","equal","method","res","onSubscription","publish","connectionId","callback","methodInvocation","DDP","_CurrentMethodInvocation","get","publicationInvocation","_CurrentPublicationInvocation","onStop","onStopMethodInvocation","onStopPublicationInvocation","ready","subscription","subscribe","fromOnStop","isUndefined","isNotUndefined","onSubscriptions","publicationObject","testsLength","testResolvedPromise","arg","invocation1","Promise","resolve","then","result","invocation2","Error","testRejectedPromise","testRejectedPromiseWithGenericError","error","reason","details","foo","isClientSafe","clientCallPromise","reject","serverCallAsyncPromise","server","callAsync","serverApplyAsyncPromise","applyAsync","clientCallRejectedPromise","message","clientCallRejectedPromiseWithGenericError","all","results"],"mappings":"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","sourcesContent":["var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection && this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  },\n\n  livedata_server_test_setuserid: function (userId) {\n    this.setUserId(userId);\n  }\n});\n\n\nTinytest.addAsync(\n    \"livedata server - onMessage hook\",\n    function (test, onComplete) {\n\n        var cb = Meteor.onMessage(function (msg, session) {\n            test.equal(msg.method, 'livedata_server_test_inner');\n            cb.stop();\n            onComplete();\n        });\n\n        makeTestConnection(\n            test,\n            function (clientConn, serverConn) {\n                clientConn.call('livedata_server_test_inner');\n                clientConn.disconnect();\n            },\n            onComplete\n        );\n    }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\nMeteor.publish(\"livedata_server_test_sub_method\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) {\n    var id = Meteor.call('livedata_server_test_inner');\n    callback(id);\n  }\n  this.stop();\n});\n\nMeteor.publish(\"livedata_server_test_sub_context\", function (connectionId, userId) {\n  var callback = onSubscription[connectionId];\n  var methodInvocation = DDP._CurrentMethodInvocation.get();\n  var publicationInvocation = DDP._CurrentPublicationInvocation.get();\n\n  // Check the publish function's environment variables and context.\n  if (callback) {\n    callback.call(this, methodInvocation, publicationInvocation);\n  }\n\n  // Check that onStop callback is have the same context as the publish function\n  // and that it runs with the same environment variables as this publish function.\n  this.onStop(function () {\n    var onStopMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var onStopPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    callback.call(this, onStopMethodInvocation, onStopPublicationInvocation, true);\n  });\n\n  if (this.userId) {\n    this.stop();\n  } else {\n    this.ready();\n    Meteor.call('livedata_server_test_setuserid', userId);\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connection in method called from publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (id) {\n          delete onSubscription[serverConn.id];\n          test.equal(id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub_method\", serverConn.id);\n      }\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - verify context in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var userId = 'someUserId';\n        onSubscription[serverConn.id] = function (methodInvocation, publicationInvocation, fromOnStop) {\n          // DDP._CurrentMethodInvocation should be undefined in a publish function\n          test.isUndefined(methodInvocation, 'Should have been undefined');\n          // DDP._CurrentPublicationInvocation should be set in a publish function\n          test.isNotUndefined(publicationInvocation, 'Should have been defined');\n          if (this.userId === userId && fromOnStop) {\n            delete onSubscription[serverConn.id];\n            clientConn.disconnect();\n            onComplete();\n          }\n        }\n        clientConn.subscribe(\"livedata_server_test_sub_context\", serverConn.id, userId);\n      }\n    );\n  }\n);\n\nlet onSubscriptions = {};\n\nMeteor.publish({\n  publicationObject () {\n    let callback = onSubscriptions;\n    if (callback)\n      callback();\n    this.stop();\n  }\n});\n\nMeteor.publish({\n  \"publication_object\": function () {\n    let callback = onSubscriptions;\n    if (callback)\n      callback();\n    this.stop();\n  }\n});\n\nMeteor.publish(\"publication_compatibility\", function () {\n  let callback = onSubscriptions;\n  if (callback)\n    callback();\n  this.stop();\n});\n\nTinytest.addAsync(\n  \"livedata server - publish object\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        let testsLength = 0;\n\n        onSubscriptions = function (subscription) {\n          delete onSubscriptions;\n          clientConn.disconnect();\n          testsLength++;\n          if(testsLength == 3){\n            onComplete();\n          }\n        };\n        clientConn.subscribe(\"publicationObject\");\n        clientConn.subscribe(\"publication_object\");\n        clientConn.subscribe(\"publication_compatibility\");\n      }\n    );\n  }\n);\n\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentMethodInvocation.get();\n    return Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentMethodInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  },\n\n  testRejectedPromiseWithGenericError(arg) {\n    return Promise.resolve(arg).then(result => {\n      const error = new Error('MESSAGE');\n      error.error = 'ERROR';\n      error.reason = 'REASON';\n      error.details = { foo: 'bar' };\n      error.isClientSafe = true;\n      throw error;\n    });\n  }\n});\n\nTinytest.addAsync(\n  \"livedata server - waiting for Promise\",\n  (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n    test.equal(\n      clientConn.call(\"testResolvedPromise\", \"clientConn.call\"),\n      \"clientConn.call after waiting\"\n    );\n\n    const clientCallPromise = new Promise(\n      (resolve, reject) => clientConn.call(\n        \"testResolvedPromise\",\n        \"clientConn.call with callback\",\n        (error, result) => error ? reject(error) : resolve(result)\n      )\n    );\n\n    const serverCallAsyncPromise = Meteor.server.callAsync(\n      \"testResolvedPromise\",\n      \"Meteor.server.callAsync\"\n    );\n\n    const serverApplyAsyncPromise = Meteor.server.applyAsync(\n      \"testResolvedPromise\",\n      [\"Meteor.server.applyAsync\"]\n    );\n\n    const clientCallRejectedPromise = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromise\",\n        \"with callback\",\n        (error, result) => resolve(error.message)\n      );\n    });\n\n    const clientCallRejectedPromiseWithGenericError = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromiseWithGenericError\",\n        (error, result) => resolve({\n          message: error.message,\n          error: error.error,\n          reason: error.reason,\n          details: error.details,\n        })\n      );\n    });\n\n    Promise.all([\n      clientCallPromise,\n      clientCallRejectedPromise,\n      clientCallRejectedPromiseWithGenericError,\n      serverCallAsyncPromise,\n      serverApplyAsyncPromise\n    ]).then(results => test.equal(results, [\n      \"clientConn.call with callback after waiting\",\n      \"[with callback raised Meteor.Error]\",\n      {\n        message: 'REASON [ERROR]',\n        error: 'ERROR',\n        reason: 'REASON',\n        details: { foo: 'bar' },\n      },\n      \"Meteor.server.callAsync after waiting\",\n      \"Meteor.server.applyAsync after waiting\"\n    ]), error => test.fail(error))\n      .then(onComplete);\n  })\n);\n"]},"sourceType":"script","hash":"4209267020d6e6b81a2a674d3d97d04556f41e15"}
