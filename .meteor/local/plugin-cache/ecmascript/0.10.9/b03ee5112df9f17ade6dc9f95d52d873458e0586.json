{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/minimongo/sorter.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/minimongo/sorter.js","filename":"packages/minimongo/sorter.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/minimongo/sorter.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/sorter.js"}},"code":"module.export({\n  default: () => Sorter\n});\nlet ELEMENT_OPERATORS, equalityElementMatcher, expandArraysInBranches, hasOwn, isOperatorObject, makeLookupFunction, regexpElementMatcher;\nmodule.watch(require(\"./common.js\"), {\n  ELEMENT_OPERATORS(v) {\n    ELEMENT_OPERATORS = v;\n  },\n\n  equalityElementMatcher(v) {\n    equalityElementMatcher = v;\n  },\n\n  expandArraysInBranches(v) {\n    expandArraysInBranches = v;\n  },\n\n  hasOwn(v) {\n    hasOwn = v;\n  },\n\n  isOperatorObject(v) {\n    isOperatorObject = v;\n  },\n\n  makeLookupFunction(v) {\n    makeLookupFunction = v;\n  },\n\n  regexpElementMatcher(v) {\n    regexpElementMatcher = v;\n  }\n\n}, 0);\n\nclass Sorter {\n  constructor(spec, options = {}) {\n    this._sortSpecParts = [];\n    this._sortFunction = null;\n\n    const addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n\n      if (path.charAt(0) === '$') {\n        throw Error(`unsupported sort key: ${path}`);\n      }\n\n      this._sortSpecParts.push({\n        ascending,\n        lookup: makeLookupFunction(path, {\n          forSort: true\n        }),\n        path\n      });\n    };\n\n    if (spec instanceof Array) {\n      spec.forEach(element => {\n        if (typeof element === 'string') {\n          addSpecPart(element, true);\n        } else {\n          addSpecPart(element[0], element[1] !== 'desc');\n        }\n      });\n    } else if (typeof spec === 'object') {\n      Object.keys(spec).forEach(key => {\n        addSpecPart(key, spec[key] >= 0);\n      });\n    } else if (typeof spec === 'function') {\n      this._sortFunction = spec;\n    } else {\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\n    } // If a function is specified for sorting, we skip the rest.\n\n\n    if (this._sortFunction) {\n      return;\n    } // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the\n    // same modifiers as this sort order. This is only implemented on the\n    // server.\n\n\n    if (this.affectedByModifier) {\n      const selector = {};\n\n      this._sortSpecParts.forEach(spec => {\n        selector[spec.path] = 1;\n      });\n\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n    }\n\n    this._keyComparator = composeComparators(this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))); // If you specify a matcher for this Sorter, _keyFilter may be set to a\n    // function which selects whether or not a given \"sort key\" (tuple of values\n    // for the different sort spec fields) is compatible with the selector.\n\n    this._keyFilter = null;\n\n    if (options.matcher) {\n      this._useWithMatcher(options.matcher);\n    }\n  }\n\n  getComparator(options) {\n    // If sort is specified or have no distances, just use the comparator from\n    // the source specification (which defaults to \"everything is equal\".\n    // issue #3599\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n    // sort effectively overrides $near\n    if (this._sortSpecParts.length || !options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    const distances = options.distances; // Return a comparator which compares using $near distances.\n\n    return (a, b) => {\n      if (!distances.has(a._id)) {\n        throw Error(`Missing distance for ${a._id}`);\n      }\n\n      if (!distances.has(b._id)) {\n        throw Error(`Missing distance for ${b._id}`);\n      }\n\n      return distances.get(a._id) - distances.get(b._id);\n    };\n  } // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n\n\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length || key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  } // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n\n\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    const pathFromIndices = indices => `${indices.join(',')},`;\n\n    let knownPaths = null; // maps index -> ({'' -> value} or {path -> value})\n\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      let branches = expandArraysInBranches(spec.lookup(doc), true); // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one null value.\n\n      if (!branches.length) {\n        branches = [{\n          value: null\n        }];\n      }\n\n      const element = Object.create(null);\n      let usedPaths = false;\n      branches.forEach(branch => {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n\n          element[''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n        const path = pathFromIndices(branch.arrayIndices);\n\n        if (hasOwn.call(element, path)) {\n          throw Error(`duplicate path: ${path}`);\n        }\n\n        element[path] = branch.value; // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!hasOwn.call(element, '') && Object.keys(knownPaths).length !== Object.keys(element).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n        Object.keys(element).forEach(path => {\n          knownPaths[path] = true;\n        });\n      }\n\n      return element;\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      const soleKey = valuesByIndexAndPath.map(values => {\n        if (!hasOwn.call(values, '')) {\n          throw Error('no value in sole key case?');\n        }\n\n        return values[''];\n      });\n      cb(soleKey);\n      return;\n    }\n\n    Object.keys(knownPaths).forEach(path => {\n      const key = valuesByIndexAndPath.map(values => {\n        if (hasOwn.call(values, '')) {\n          return values[''];\n        }\n\n        if (!hasOwn.call(values, path)) {\n          throw Error('missing path?');\n        }\n\n        return values[path];\n      });\n      cb(key);\n    });\n  } // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n\n\n  _getBaseComparator() {\n    if (this._sortFunction) {\n      return this._sortFunction;\n    } // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n\n\n    if (!this._sortSpecParts.length) {\n      return (doc1, doc2) => 0;\n    }\n\n    return (doc1, doc2) => {\n      const key1 = this._getMinKeyFromDoc(doc1);\n\n      const key2 = this._getMinKeyFromDoc(doc2);\n\n      return this._compareKeys(key1, key2);\n    };\n  } // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n\n\n  _getMinKeyFromDoc(doc) {\n    let minKey = null;\n\n    this._generateKeysFromDoc(doc, key => {\n      if (!this._keyCompatibleWithSelector(key)) {\n        return;\n      }\n\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    }); // This could happen if our key filter somehow filters out all the keys even\n    // though somehow the selector matches.\n\n\n    if (minKey === null) {\n      throw Error('sort selector found no keys in doc?');\n    }\n\n    return minKey;\n  }\n\n  _getPaths() {\n    return this._sortSpecParts.map(part => part.path);\n  }\n\n  _keyCompatibleWithSelector(key) {\n    return !this._keyFilter || this._keyFilter(key);\n  } // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n\n\n  _keyFieldComparator(i) {\n    const invert = !this._sortSpecParts[i].ascending;\n    return (key1, key2) => {\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n\n      return invert ? -compare : compare;\n    };\n  } // In MongoDB, if you have documents\n  //    {_id: 'x', a: [1, 10]} and\n  //    {_id: 'y', a: [5, 15]},\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n  // match the selector, and 5 comes before 10).\n  //\n  // The way this works is pretty subtle!  For example, if the documents\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n  // both follow this rule (y before x).  (ie, you do have to apply this\n  // through $elemMatch.)\n  //\n  // So if you pass a matcher to this sorter's constructor, we will attempt to\n  // skip sort keys that don't match the selector. The logic here is pretty\n  // subtle and undocumented; we've gotten as close as we can figure out based\n  // on our understanding of Mongo's behavior.\n\n\n  _useWithMatcher(matcher) {\n    if (this._keyFilter) {\n      throw Error('called _useWithMatcher twice?');\n    } // If we are only sorting by distance, then we're not going to bother to\n    // build a key filter.\n    // XXX figure out how geoqueries interact with this stuff\n\n\n    if (!this._sortSpecParts.length) {\n      return;\n    }\n\n    const selector = matcher._selector; // If the user just passed a falsey selector to find(),\n    // then we can't get a key filter from it.\n\n    if (!selector) {\n      return;\n    } // If the user just passed a literal function to find(), then we can't get a\n    // key filter from it.\n\n\n    if (selector instanceof Function) {\n      return;\n    }\n\n    const constraintsByPath = {};\n\n    this._sortSpecParts.forEach(spec => {\n      constraintsByPath[spec.path] = [];\n    });\n\n    Object.keys(selector).forEach(key => {\n      const subSelector = selector[key]; // XXX support $and and $or\n\n      const constraints = constraintsByPath[key];\n\n      if (!constraints) {\n        return;\n      } // XXX it looks like the real MongoDB implementation isn't \"does the\n      // regexp match\" but \"does the value fall into a range named by the\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But\n      // \"does the regexp match\" is a good approximation.\n\n\n      if (subSelector instanceof RegExp) {\n        // As far as we can tell, using either of the options that both we and\n        // MongoDB support ('i' and 'm') disables use of the key filter. This\n        // makes sense: MongoDB mostly appears to be calculating ranges of an\n        // index to use, which means it only cares about regexps that match\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the\n        // literal prefix of the regexp from actually meaning one range.\n        if (subSelector.ignoreCase || subSelector.multiline) {\n          return;\n        }\n\n        constraints.push(regexpElementMatcher(subSelector));\n        return;\n      }\n\n      if (isOperatorObject(subSelector)) {\n        Object.keys(subSelector).forEach(operator => {\n          const operand = subSelector[operator];\n\n          if (['$lt', '$lte', '$gt', '$gte'].includes(operator)) {\n            // XXX this depends on us knowing that these operators don't use any\n            // of the arguments to compileElementSelector other than operand.\n            constraints.push(ELEMENT_OPERATORS[operator].compileElementSelector(operand));\n          } // See comments in the RegExp block above.\n\n\n          if (operator === '$regex' && !subSelector.$options) {\n            constraints.push(ELEMENT_OPERATORS.$regex.compileElementSelector(operand, subSelector));\n          } // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n\n        });\n        return;\n      } // OK, it's an equality thing.\n\n\n      constraints.push(equalityElementMatcher(subSelector));\n    }); // It appears that the first sort field is treated differently from the\n    // others; we shouldn't create a key filter unless the first sort field is\n    // restricted, though after that point we can restrict the other sort fields\n    // or not as we wish.\n\n    if (!constraintsByPath[this._sortSpecParts[0].path].length) {\n      return;\n    }\n\n    this._keyFilter = key => this._sortSpecParts.every((specPart, index) => constraintsByPath[specPart.path].every(fn => fn(key[index])));\n  }\n\n}\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nfunction composeComparators(comparatorArray) {\n  return (a, b) => {\n    for (let i = 0; i < comparatorArray.length; ++i) {\n      const compare = comparatorArray[i](a, b);\n\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n\n    return 0;\n  };\n}","map":{"version":3,"sources":["packages/minimongo/sorter.js"],"names":["module","export","default","Sorter","ELEMENT_OPERATORS","equalityElementMatcher","expandArraysInBranches","hasOwn","isOperatorObject","makeLookupFunction","regexpElementMatcher","watch","require","v","constructor","spec","options","_sortSpecParts","_sortFunction","addSpecPart","path","ascending","Error","charAt","push","lookup","forSort","Array","forEach","element","Object","keys","key","JSON","stringify","affectedByModifier","selector","_selectorForAffectedByModifier","Minimongo","Matcher","_keyComparator","composeComparators","map","i","_keyFieldComparator","_keyFilter","matcher","_useWithMatcher","getComparator","length","distances","_getBaseComparator","a","b","has","_id","get","_compareKeys","key1","key2","_generateKeysFromDoc","doc","cb","pathFromIndices","indices","join","knownPaths","valuesByIndexAndPath","branches","value","create","usedPaths","branch","arrayIndices","call","soleKey","values","doc1","doc2","_getMinKeyFromDoc","minKey","_keyCompatibleWithSelector","_getPaths","part","invert","compare","LocalCollection","_f","_cmp","_selector","Function","constraintsByPath","subSelector","constraints","RegExp","ignoreCase","multiline","operator","operand","includes","compileElementSelector","$options","$regex","every","specPart","index","fn","comparatorArray"],"mappings":"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","sourcesContent":["import {\n  ELEMENT_OPERATORS,\n  equalityElementMatcher,\n  expandArraysInBranches,\n  hasOwn,\n  isOperatorObject,\n  makeLookupFunction,\n  regexpElementMatcher,\n} from './common.js';\n\n// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nexport default class Sorter {\n  constructor(spec, options = {}) {\n    this._sortSpecParts = [];\n    this._sortFunction = null;\n\n    const addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n\n      if (path.charAt(0) === '$') {\n        throw Error(`unsupported sort key: ${path}`);\n      }\n\n      this._sortSpecParts.push({\n        ascending,\n        lookup: makeLookupFunction(path, {forSort: true}),\n        path\n      });\n    };\n\n    if (spec instanceof Array) {\n      spec.forEach(element => {\n        if (typeof element === 'string') {\n          addSpecPart(element, true);\n        } else {\n          addSpecPart(element[0], element[1] !== 'desc');\n        }\n      });\n    } else if (typeof spec === 'object') {\n      Object.keys(spec).forEach(key => {\n        addSpecPart(key, spec[key] >= 0);\n      });\n    } else if (typeof spec === 'function') {\n      this._sortFunction = spec;\n    } else {\n      throw Error(`Bad sort specification: ${JSON.stringify(spec)}`);\n    }\n\n    // If a function is specified for sorting, we skip the rest.\n    if (this._sortFunction) {\n      return;\n    }\n\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the\n    // same modifiers as this sort order. This is only implemented on the\n    // server.\n    if (this.affectedByModifier) {\n      const selector = {};\n\n      this._sortSpecParts.forEach(spec => {\n        selector[spec.path] = 1;\n      });\n\n      this._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n    }\n\n    this._keyComparator = composeComparators(\n      this._sortSpecParts.map((spec, i) => this._keyFieldComparator(i))\n    );\n\n    // If you specify a matcher for this Sorter, _keyFilter may be set to a\n    // function which selects whether or not a given \"sort key\" (tuple of values\n    // for the different sort spec fields) is compatible with the selector.\n    this._keyFilter = null;\n\n    if (options.matcher) {\n      this._useWithMatcher(options.matcher);\n    }\n  }\n\n  getComparator(options) {\n    // If sort is specified or have no distances, just use the comparator from\n    // the source specification (which defaults to \"everything is equal\".\n    // issue #3599\n    // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n    // sort effectively overrides $near\n    if (this._sortSpecParts.length || !options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    const distances = options.distances;\n\n    // Return a comparator which compares using $near distances.\n    return (a, b) => {\n      if (!distances.has(a._id)) {\n        throw Error(`Missing distance for ${a._id}`);\n      }\n\n      if (!distances.has(b._id)) {\n        throw Error(`Missing distance for ${b._id}`);\n      }\n\n      return distances.get(a._id) - distances.get(b._id);\n    };\n  }\n\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length ||\n        key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  }\n\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    const pathFromIndices = indices => `${indices.join(',')},`;\n\n    let knownPaths = null;\n\n    // maps index -> ({'' -> value} or {path -> value})\n    const valuesByIndexAndPath = this._sortSpecParts.map(spec => {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      let branches = expandArraysInBranches(spec.lookup(doc), true);\n\n      // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one null value.\n      if (!branches.length) {\n        branches = [{value: null}];\n      }\n\n      const element = Object.create(null);\n      let usedPaths = false;\n\n      branches.forEach(branch => {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n\n          element[''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n\n        const path = pathFromIndices(branch.arrayIndices);\n\n        if (hasOwn.call(element, path)) {\n          throw Error(`duplicate path: ${path}`);\n        }\n\n        element[path] = branch.value;\n\n        // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n        if (knownPaths && !hasOwn.call(knownPaths, path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!hasOwn.call(element, '') &&\n            Object.keys(knownPaths).length !== Object.keys(element).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n\n        Object.keys(element).forEach(path => {\n          knownPaths[path] = true;\n        });\n      }\n\n      return element;\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      const soleKey = valuesByIndexAndPath.map(values => {\n        if (!hasOwn.call(values, '')) {\n          throw Error('no value in sole key case?');\n        }\n\n        return values[''];\n      });\n\n      cb(soleKey);\n\n      return;\n    }\n\n    Object.keys(knownPaths).forEach(path => {\n      const key = valuesByIndexAndPath.map(values => {\n        if (hasOwn.call(values, '')) {\n          return values[''];\n        }\n\n        if (!hasOwn.call(values, path)) {\n          throw Error('missing path?');\n        }\n\n        return values[path];\n      });\n\n      cb(key);\n    });\n  }\n\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator() {\n    if (this._sortFunction) {\n      return this._sortFunction;\n    }\n\n    // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n    if (!this._sortSpecParts.length) {\n      return (doc1, doc2) => 0;\n    }\n\n    return (doc1, doc2) => {\n      const key1 = this._getMinKeyFromDoc(doc1);\n      const key2 = this._getMinKeyFromDoc(doc2);\n      return this._compareKeys(key1, key2);\n    };\n  }\n\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc(doc) {\n    let minKey = null;\n\n    this._generateKeysFromDoc(doc, key => {\n      if (!this._keyCompatibleWithSelector(key)) {\n        return;\n      }\n\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    // This could happen if our key filter somehow filters out all the keys even\n    // though somehow the selector matches.\n    if (minKey === null) {\n      throw Error('sort selector found no keys in doc?');\n    }\n\n    return minKey;\n  }\n\n  _getPaths() {\n    return this._sortSpecParts.map(part => part.path);\n  }\n\n  _keyCompatibleWithSelector(key) {\n    return !this._keyFilter || this._keyFilter(key);\n  }\n\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator(i) {\n    const invert = !this._sortSpecParts[i].ascending;\n\n    return (key1, key2) => {\n      const compare = LocalCollection._f._cmp(key1[i], key2[i]);\n      return invert ? -compare : compare;\n    };\n  }\n\n  // In MongoDB, if you have documents\n  //    {_id: 'x', a: [1, 10]} and\n  //    {_id: 'y', a: [5, 15]},\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n  // match the selector, and 5 comes before 10).\n  //\n  // The way this works is pretty subtle!  For example, if the documents\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n  // both follow this rule (y before x).  (ie, you do have to apply this\n  // through $elemMatch.)\n  //\n  // So if you pass a matcher to this sorter's constructor, we will attempt to\n  // skip sort keys that don't match the selector. The logic here is pretty\n  // subtle and undocumented; we've gotten as close as we can figure out based\n  // on our understanding of Mongo's behavior.\n  _useWithMatcher(matcher) {\n    if (this._keyFilter) {\n      throw Error('called _useWithMatcher twice?');\n    }\n\n    // If we are only sorting by distance, then we're not going to bother to\n    // build a key filter.\n    // XXX figure out how geoqueries interact with this stuff\n    if (!this._sortSpecParts.length) {\n      return;\n    }\n\n    const selector = matcher._selector;\n\n    // If the user just passed a falsey selector to find(),\n    // then we can't get a key filter from it.\n    if (!selector) {\n      return;\n    }\n\n    // If the user just passed a literal function to find(), then we can't get a\n    // key filter from it.\n    if (selector instanceof Function) {\n      return;\n    }\n\n    const constraintsByPath = {};\n\n    this._sortSpecParts.forEach(spec => {\n      constraintsByPath[spec.path] = [];\n    });\n\n    Object.keys(selector).forEach(key => {\n      const subSelector = selector[key];\n\n      // XXX support $and and $or\n      const constraints = constraintsByPath[key];\n      if (!constraints) {\n        return;\n      }\n\n      // XXX it looks like the real MongoDB implementation isn't \"does the\n      // regexp match\" but \"does the value fall into a range named by the\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But\n      // \"does the regexp match\" is a good approximation.\n      if (subSelector instanceof RegExp) {\n        // As far as we can tell, using either of the options that both we and\n        // MongoDB support ('i' and 'm') disables use of the key filter. This\n        // makes sense: MongoDB mostly appears to be calculating ranges of an\n        // index to use, which means it only cares about regexps that match\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the\n        // literal prefix of the regexp from actually meaning one range.\n        if (subSelector.ignoreCase || subSelector.multiline) {\n          return;\n        }\n\n        constraints.push(regexpElementMatcher(subSelector));\n        return;\n      }\n\n      if (isOperatorObject(subSelector)) {\n        Object.keys(subSelector).forEach(operator => {\n          const operand = subSelector[operator];\n\n          if (['$lt', '$lte', '$gt', '$gte'].includes(operator)) {\n            // XXX this depends on us knowing that these operators don't use any\n            // of the arguments to compileElementSelector other than operand.\n            constraints.push(\n              ELEMENT_OPERATORS[operator].compileElementSelector(operand)\n            );\n          }\n\n          // See comments in the RegExp block above.\n          if (operator === '$regex' && !subSelector.$options) {\n            constraints.push(\n              ELEMENT_OPERATORS.$regex.compileElementSelector(\n                operand,\n                subSelector\n              )\n            );\n          }\n\n          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n        });\n\n        return;\n      }\n\n      // OK, it's an equality thing.\n      constraints.push(equalityElementMatcher(subSelector));\n    });\n\n    // It appears that the first sort field is treated differently from the\n    // others; we shouldn't create a key filter unless the first sort field is\n    // restricted, though after that point we can restrict the other sort fields\n    // or not as we wish.\n    if (!constraintsByPath[this._sortSpecParts[0].path].length) {\n      return;\n    }\n\n    this._keyFilter = key =>\n      this._sortSpecParts.every((specPart, index) =>\n        constraintsByPath[specPart.path].every(fn => fn(key[index]))\n      )\n    ;\n  }\n}\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nfunction composeComparators(comparatorArray) {\n  return (a, b) => {\n    for (let i = 0; i < comparatorArray.length; ++i) {\n      const compare = comparatorArray[i](a, b);\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n\n    return 0;\n  };\n}\n"]},"sourceType":"script","hash":"b03ee5112df9f17ade6dc9f95d52d873458e0586"}
