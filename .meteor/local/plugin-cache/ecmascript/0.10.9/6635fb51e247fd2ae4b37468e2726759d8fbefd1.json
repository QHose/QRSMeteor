{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"imports/api/server/QRSFunctionsApp.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"imports/api/server/QRSFunctionsApp.js","filename":"imports/api/server/QRSFunctionsApp.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"imports/api/server/QRSFunctionsApp.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/api/server/QRSFunctionsApp.js"}},"code":"module.export({\n  uploadAndPublishTemplateApps: () => uploadAndPublishTemplateApps,\n  generateStreamAndApp: () => generateStreamAndApp,\n  setAppIDs: () => setAppIDs,\n  createAppConnections: () => createAppConnections,\n  createAppConnection: () => createAppConnection,\n  copyApp: () => copyApp,\n  getApps: () => getApps,\n  deleteApp: () => deleteApp,\n  publishApp: () => publishApp,\n  importApp: () => importApp\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet http;\nmodule.watch(require(\"meteor/meteor\"), {\n  http(v) {\n    http = v;\n  }\n\n}, 1);\nlet Apps, TemplateApps, GeneratedResources;\nmodule.watch(require(\"/imports/api/apps\"), {\n  Apps(v) {\n    Apps = v;\n  },\n\n  TemplateApps(v) {\n    TemplateApps = v;\n  },\n\n  GeneratedResources(v) {\n    GeneratedResources = v;\n  }\n\n}, 2);\nlet QSStream;\nmodule.watch(require(\"/imports/api/server/QRSFunctionsStream\"), {\n  \"*\"(v) {\n    QSStream = v;\n  }\n\n}, 3);\nlet gitHubLinks;\nmodule.watch(require(\"/imports/ui/UIHelpers\"), {\n  gitHubLinks(v) {\n    gitHubLinks = v;\n  }\n\n}, 4);\nlet Streams;\nmodule.watch(require(\"/imports/api/streams\"), {\n  Streams(v) {\n    Streams = v;\n  }\n\n}, 5);\nlet Customers;\nmodule.watch(require(\"/imports/api/customers\"), {\n  Customers(v) {\n    Customers = v;\n  }\n\n}, 6);\nlet createVirtualProxies;\nmodule.watch(require(\"/imports/api/server/QPSFunctions\"), {\n  createVirtualProxies(v) {\n    createVirtualProxies = v;\n  }\n\n}, 7);\n\nlet qlikHDRServer, senseConfig, enigmaServerConfig, qrsSrv, qrs, configCerticates, _slideGeneratorAppId;\n\nmodule.watch(require(\"/imports/api/config.js\"), {\n  qlikHDRServer(v) {\n    qlikHDRServer = v;\n  },\n\n  senseConfig(v) {\n    senseConfig = v;\n  },\n\n  enigmaServerConfig(v) {\n    enigmaServerConfig = v;\n  },\n\n  qrsSrv(v) {\n    qrsSrv = v;\n  },\n\n  qrs(v) {\n    qrs = v;\n  },\n\n  configCerticates(v) {\n    configCerticates = v;\n  },\n\n  _slideGeneratorAppId(v) {\n    _slideGeneratorAppId = v;\n  }\n\n}, 8);\nlet APILogs, REST_Log;\nmodule.watch(require(\"/imports/api/APILogs\"), {\n  APILogs(v) {\n    APILogs = v;\n  },\n\n  REST_Log(v) {\n    REST_Log = v;\n  }\n\n}, 9);\nlet lodash;\nmodule.watch(require(\"lodash\"), {\n  default(v) {\n    lodash = v;\n  }\n\n}, 10);\n_ = lodash; //\n// ─── INSTALL NPM MODULES ────────────────────────────────────────────────────────\n//\n\nconst path = require('path');\n\nconst fs = require('fs-extra');\n\nconst enigma = require('enigma.js');\n\nvar promise = require('bluebird');\n\nvar request = require('request');\n\nvar sanitize = require(\"sanitize-filename\"); //\n// ─── UPLOAD APPS FOR THE INITIAL SETUP OF QLIK SENSE ─────────────────────────\n//\n// UPLOAD TEMPLATES APPS FROM FOLDER, AND PUBLISH INTO THE TEMPLATES STREAM\n\n\nfunction uploadAndPublishTemplateApps() {\n  return Promise.asyncApply(() => {\n    console.log('------------------------------------');\n    console.log('uploadAndPublishTemplateApps');\n    console.log('------------------------------------');\n    var newFolder = path.join(Meteor.settings.broker.automationBaseFolder, 'apps');\n    console.log('uploadAndPublishTemplateApps: Read all files in the template apps folder \"' + newFolder + '\" and upload them to Qlik Sense.'); //GET THE ID OF THE IMPORTANT STREAMS (streams that QRSMeteor needs)\n\n    var everyOneStreamId = QSStream.getStreamByName(Meteor.settings.broker.qlikSense.EveryoneAppStreamName).id;\n    var templateStreamId = QSStream.getStreamByName(Meteor.settings.public.TemplateAppStreamName).id;\n    var APIAppsStreamID = QSStream.getStreamByName(Meteor.settings.broker.qlikSense.APIAppStreamName).id;\n\n    try {\n      check(newFolder, String);\n      check(everyOneStreamId, String);\n      check(templateStreamId, String);\n      check(APIAppsStreamID, String);\n    } catch (err) {\n      console.error('You did not specify the templateAppsFrom, everyone, api apps or template stream name in the settings.json file?');\n      throw new Meteor.Error('Missing Settings', 'You did not specify the everone, api apps or template stream name in the settings.json file?');\n    } // LOAD ALL SENSE APPS IN FOLDER\n\n\n    var appsInFolder = Promise.await(fs.readdir(newFolder)); // FOR EACH APP FOUND: PUBLISH IT    \n\n    return Promise.await(Promise.all(appsInFolder.map(QVF => Promise.asyncApply(() => {\n      try {\n        //GET THE NAME OF THE APP AND CREATE A FILEPATH\n        var appName = QVF.substr(0, QVF.indexOf('.'));\n        var filePath = path.join(newFolder, QVF); //ONLY UPLOAD APPS IF THEY DO NOT ALREADY EXIST\n\n        if (!getApps(appName).length) {\n          //UPLOAD THE APP, GET THE APP ID BACK\n          var appId = Promise.await(uploadApp(filePath, appName)); //BASED ON THE APP WE WANT TO PUBLISH IT INTO A DIFFERENT STREAM                      \n\n          if (appName === 'SSBI') {\n            //should be published in the everyone stream\n            _SSBIApp = appId; // for the client side HTML/IFrames etc.                                \n\n            publishApp(appId, appName, everyOneStreamId);\n          } else if (appName === 'Sales') {\n            //THIS ONE NEEDS TO BE COPIED AND PUBLISHED INTO 2 STREAMS: AS TEMPLATE AND FOR THE EVERYONE STREAM.\n            publishApp(appId, appName, everyOneStreamId);\n            var copiedAppId = copyApp(appId, appName);\n            publishApp(copiedAppId, appName, templateStreamId);\n          } else if (appName === 'Slide generator') {\n            _slideGeneratorAppId = appId, publishApp(appId, appName, APIAppsStreamID);\n          } else {\n            //Insert into template apps stream\n            publishApp(appId, appName, templateStreamId);\n          }\n        } else {\n          console.log('App ' + appName + ' already exists in Qlik Sense');\n        }\n\n        ;\n      } catch (err) {\n        console.error(err);\n        throw new Meteor.Error('Unable to upload the app to Qlik Sense. ', err);\n      }\n    }))));\n  });\n}\n\nfunction generateStreamAndApp(customers, generationUserId) {\n  return Promise.asyncApply(() => {\n    console.log('METHOD called: generateStreamAndApp for the template apps as stored in the database of the fictive OEM');\n\n    try {\n      var templateApps = checkTemplateAppExists(generationUserId); //is a template app selected, and does the guid still exist in Sense? if yes, return the valid templates\n\n      checkCustomersAreSelected(customers); //have we selected a  customer to do the generation for?\n\n      console.log('------------------------------------');\n      console.log('start generation for ', customers);\n      console.log('------------------------------------');\n\n      for (const customer of customers) {\n        for (const templateApp of templateApps) {\n          Promise.await(generateAppForTemplate(templateApp, customer, generationUserId));\n        }\n      }\n\n      ;\n    } catch (error) {\n      console.error(error);\n    }\n  });\n}\n\n;\n\nfunction setAppIDs(params) {\n  console.log('------------------------------------');\n  console.log('SET APP IDs');\n  console.log('------------------------------------');\n\n  try {\n    console.log('check if all settings.json parameters are set...');\n    check(Meteor.settings.public.slideGenerator, {\n      name: String,\n      stream: String,\n      selectionSheet: String,\n      dataObject: String,\n      slideObject: String,\n      virtualProxy: String\n    });\n    check(Meteor.settings.public.SSBI, {\n      name: String,\n      stream: String,\n      sheetId: String,\n      appId: String\n    });\n  } catch (err) {\n    console.error('Missing parameters in your settings.json file for the SSBI or slidegenerator...', err);\n  }\n\n  try {\n    var slideGeneratorApps = getApps(Meteor.settings.public.slideGenerator.name, Meteor.settings.public.slideGenerator.stream);\n    var SSBIApps = getApps(Meteor.settings.public.SSBI.name, Meteor.settings.public.SSBI.stream);\n\n    if (slideGeneratorApps.length > 1) {\n      throw new Error('Can not automatically set the app ID for the slide generator. You have not one but you have multiple slide generator apps under the name ' + Meteor.settings.public.slideGenerator.name + ' in the stream ' + Meteor.settings.public.slideGenerator.stream);\n    }\n\n    if (SSBIApps.length > 1) {\n      throw new Error('Can not automatically set the app ID for the Self Service BI app. You have not one but you have multiple Self Service apps under the name ' + Meteor.settings.public.SSBI.name + ' in the stream ' + Meteor.settings.public.SSBI.stream);\n    }\n\n    senseConfig.SSBIApp = SSBIApps[0].id; //\n\n    console.log('The SSBI app id has been set to ', senseConfig.SSBIApp);\n    senseConfig.slideGeneratorAppId = slideGeneratorApps[0].id;\n    console.log('The slide generator app id has been set to ', senseConfig.slideGeneratorAppId);\n    console.log('------------------------------------');\n    console.log('YOU HAVE SUCCESFULLY STARTED QRSMETEOR, WE ARE CONNECTED TO QLIK SENSE');\n    console.log('------------------------------------');\n  } catch (err) {\n    console.error(err);\n    throw new Meteor.Error('The slideGenerator or Self Service BI app can not be found in Qlik sense, or you did not have all parameters set as defined in the the settings.json example file.', err);\n  }\n}\n\nfunction generateAppForTemplate(templateApp, customer, generationUserId) {\n  return Promise.asyncApply(() => {\n    console.log('--------------------------GENERATE APPS FOR TEMPLATE'); // console.log(templateApp);\n    // console.log('############## START CREATING THE TEMPLATE ' + templateApp.name + ' FOR THIS CUSTOMER: ' + customer.name + ' FOR generationUserId: ' + generationUserId);\n\n    const call = {};\n    call.action = 'Start of generation of app ' + templateApp.name + ' for ' + customer.name;\n    call.createdBy = generationUserId;\n    call.request = 'Start creating app ' + templateApp.name + ' for customer ' + customer.name;\n    REST_Log(call, generationUserId);\n\n    try {\n      var streamId = checkStreamStatus(customer, generationUserId); //create a stream for the customer if it not already exists \n\n      var customerDataFolder = Promise.await(createDirectory(customer.name)); //for data like XLS/qvd specific for a customer\n\n      if (Meteor.settings.broker.createDataConnectionPerCustomer) {\n        Promise.await(createAppConnection('folder', customer.name, customerDataFolder));\n      }\n\n      var newAppId = copyApp(templateApp.id, templateApp.name, generationUserId);\n      var result = reloadAppAndReplaceScriptviaEngine(newAppId, templateApp.name, streamId, customer, customerDataFolder, '', generationUserId);\n      var publishedAppId = publishApp(newAppId, templateApp.name, streamId, customer.name, generationUserId); //logging only\n\n      const call = {};\n      call.action = 'Finished generation for ' + customer.name;\n      call.request = templateApp.name + ' has been created and reloaded with data from the ' + customer.name + ' database';\n      REST_Log(call, generationUserId);\n      console.log('############## FINISHED CREATING THE TEMPLATE ' + templateApp.name + ' FOR THIS CUSTOMER: ' + customer.name);\n      GeneratedResources.insert({\n        'generationUserId': generationUserId,\n        'customer': customer.name,\n        'streamId': streamId,\n        'appId': newAppId\n      });\n    } catch (err) {\n      console.error('Failed to generate...', err);\n      throw new Meteor.Error('Generation failed', 'The server has an internal error, please check the server command logs');\n    }\n\n    return;\n  });\n}\n\n; //Example to demo that you can also use the Engine API to get all the apps, or reload an app, set the script etc.\n//source based on loic's work: https://github.com/pouc/qlik-elastic/blob/master/app.js\n\nfunction reloadAppAndReplaceScriptviaEngine(appId, newAppName, streamId, customer, customerDataFolder, scriptReplace, generationUserId) {\n  return Promise.asyncApply(() => {\n    console.log('--------------------------REPLACE SCRIPT AND RELOAD APP'); //set the app ID to be used in the enigma connection to the engine API\n\n    var config = Object.assign({}, enigmaServerConfig);\n    config.appId = appId;\n\n    try {\n      process.on('unhandledRejection', up => {//ignore \n      });\n      check(appId, String);\n      check(customer.name, String);\n      check(customerDataFolder, String);\n      check(generationUserId, String); //connect to the engine\n\n      var qix = Promise.await(enigma.getService('qix', config));\n      var call = {};\n      call.action = 'Connect to Qlik Sense';\n      call.request = 'Connect to Engine API (using Enigma.js) using an appId: ' + appId;\n      call.url = gitHubLinks.replaceAndReloadApp;\n      REST_Log(call, generationUserId);\n      /* try {\n          //create folder connection \n          console.log('create folder connection, if you see a warning below that means the connection already existed.');\n          var qConnectionId = await qix.createConnection({\n              \"qName\": customer.name,\n              \"qType\": \"folder\",\n              \"qConnectionString\": customerDataFolder\n          })\n          var call = {};\n          call.action = 'Create data/folder connection';\n          call.url = '';\n          call.request = 'Link to a folder on the server where users can put files/QVD, or create a REST/ODBC/OLEDB... database connection.';\n          call.response = 'created folder connection: ' + qConnectionId;\n          console.log('created folder connection: ', qConnectionId);\n      } catch (error) {\n          console.info('No issue, existing customer so his data folder connection already exists', error);\n      } */\n      //get the script\n\n      var script = Promise.await(qix.getScript());\n      var call = {};\n      call.action = 'Get data load script';\n      call.url = gitHubLinks.getScript;\n      call.request = 'We extracted the following load script from the app';\n      call.response = script;\n      REST_Log(call, generationUserId); //set the new script\n\n      var call = {};\n      call.response = Promise.await(qix.setScript(replaceScript(script))); //we now just include the old script in this app\n\n      call.action = 'Insert customer specific data load script for its database';\n      call.url = gitHubLinks.setScript;\n      call.request = 'The script of the app has been replaced with a customer specific one. Normally you would replace the database connection for each customer. Or you can insert a customer specific script to enable customization per customer. ';\n      REST_Log(call, generationUserId); //reload the app\n\n      var call = {};\n      call.response = Promise.await(qix.doReload());\n      call.action = 'Reload the app';\n      call.url = gitHubLinks.reloadApp;\n      call.request = 'Has the app been reloaded with customer specific data?';\n      REST_Log(call, generationUserId); //save the app\n\n      var call = {};\n      call.action = 'Save app';\n      call.url = gitHubLinks.saveApp;\n      call.request = 'App with GUID ' + appId + ' has been saved to disk';\n      REST_Log(call, generationUserId);\n      Promise.await(qix.doSave());\n      REST_Log(call, generationUserId);\n      process.on('unhandledRejection', up => {\n        throw up;\n      });\n    } catch (error) {\n      console.error('error in reloadAppAndReplaceScriptviaEngine via Enigma.JS, did you used the correct schema definition in the settings.json file?', error);\n    }\n\n    function replaceScript(script) {\n      //var scriptMarker = '§dummyDatabaseString§';\n      // if you want to replace the database connection per customer use the script below.\n      //return doc.setScript(script.replace(scriptMarker, scriptReplace)).then(function (result) {\n      //you can also change the sense database connection: https://github.com/mindspank/qsocks/blob/master/examples/App/create-dataconnection.js\n      return script;\n    }\n  });\n}\n\nfunction createAppConnections() {\n  return Promise.asyncApply(() => {\n    console.log('------------------------------------');\n    console.log('create app connections');\n    console.log('------------------------------------'); //create the default demo import folder where all the csv and qvf files are...\n\n    var senseDemoMaterials = path.join(Meteor.absolutePath, 'Sense Demo materials');\n    console.log('senseDemoMaterials', senseDemoMaterials);\n    Promise.await(createAppConnection('folder', 'Import demo', senseDemoMaterials));\n\n    for (let c of Meteor.settings.broker.dataConnections) {\n      Promise.await(createAppConnection(c.type, c.name, c.connectionString));\n    }\n  });\n}\n\nfunction createAppConnection(type, name, path) {\n  return Promise.asyncApply(() => {\n    //set the app ID to be used in the enigma connection to the engine API\n    var config = Object.assign({}, enigmaServerConfig);\n    config.appId = getApps('sales', 'Everyone')[0].id;\n    console.log('createAppConnection: ' + type + ' ' + name + ' ' + path + ' using the sales app in the everyone stream to create the connection: ' + config.appId);\n\n    try {\n      check(type, String);\n      check(path, String);\n      check(name, String);\n      check(config.appId, String);\n    } catch (error) {\n      console.error('Missing parameters to create a data connection', error);\n    }\n\n    try {\n      //connect to the engine\n      var qix = Promise.await(enigma.getService('qix', config)); //create folder connection \n\n      console.log('create folder connection, if you see a warning below that means the connection already existed.');\n      var qConnectionId = Promise.await(qix.createConnection({\n        \"qName\": name,\n        \"qType\": type,\n        \"qConnectionString\": path\n      }));\n      console.log('created folder connection: ', qConnectionId);\n    } catch (error) {\n      console.error('Failed to create data connection', error);\n    }\n  });\n}\n\nfunction deleteDirectoryAndDataConnection(customerName) {\n  console.log('deleteDirectoryAndDataConnection'); //@TODO a bit dangerous, so better to do by hand. Make sure you can't delete root folder... \n  // https://stackoverflow.com/questions/18052762/remove-directory-which-is-not-empty\n}\n\nfunction createDirectory(customerName) {\n  return Promise.asyncApply(() => {\n    console.log('createDirectory ', customerName);\n\n    try {\n      check(customerName, String);\n      var filename = sanitize(customerName);\n      const dir = path.join(Meteor.settings.broker.customerDataDir, customerName);\n      console.log('Meteor.settings.broker.customerDataDir', dir);\n      Promise.await(fs.ensureDir(dir));\n      return dir;\n    } catch (error) {\n      throw new Meteor.Error('Failed to create directory for ', customerName);\n    }\n  });\n}\n\nfunction checkCustomersAreSelected(customers) {\n  if (!customers.length) {\n    // = 0\n    throw new Meteor.Error('No customers', 'user has not specified at least one customer for which an app can be generated');\n  }\n}\n\n; // CHECK IF SELECTED TEMPLATE APP EXISTS IN QLIK SENSE\n//These are the apps that the OEM partner has in his database, but do they still exists on the qliks sense side?\n\nfunction checkTemplateAppExists(generationUserId) {\n  console.log('------------------------------------');\n  console.log('checkTemplateAppExists for userID ', generationUserId);\n  console.log('------------------------------------');\n  var templateApps = TemplateApps.find({\n    'generationUserId': Meteor.userId()\n  }).fetch();\n  return templateApps; // console.log('templateApps found: ', templateApps)\n  // if (templateApps.length === 0) { //user has not specified a template\n  //     throw new Meteor.Error('No Template', 'user has not specified a template for which apps can be generated');\n  // }\n  // currentAppsInSense = getApps();\n  // if (!currentAppsInSense) {\n  //     throw new Meteor.Error('No apps have been received from Qlik Sense. Therefore you have selected a Qlik Sense App: ' + templateApp.name + ' with guid: ' + templateApp.id + ' which does not exist in Sense anymore. Have you deleted the template in Sense?');\n  // }\n  // _.each(templateApps, function(templateApp) {\n  //     console.log('templateApp in MongoDB: ', templateApp)\n  //     var templateFound = _.some(currentAppsInSense, ['id', templateApp.id]);\n  //     if (!templateFound) {\n  //         console.log('------------------------------------');\n  //         console.log('!! template app exists in mongoDB but not in Qlik Sense');\n  //         console.log('------------------------------------');\n  //         throw new Meteor.Error('You have selected a Qlik Sense App: ' + templateApp.name + ' with guid: ' + templateApp.id + ' which does not exist in Sense anymore. Have you deleted the template in Sense?');\n  //     } else {\n  //         console.log('checkTemplateAppExists: True, template guid exist: ', templateApp.id);\n  //     }\n  // })\n  // return templateApps;\n}\n\n; //\n// ─── UPLOAD APP ─────────────────────────────────────────────────────────────────\n//\n\nfunction uploadApp(filePath, appName) {\n  return Promise.asyncApply(() => {\n    console.log('Upload app: ' + appName + ' from path: ' + filePath + ' via header authentication server: ' + qlikHDRServer);\n    return Promise.await(new Promise(function (resolve, reject) {\n      var formData = {\n        my_file: fs.createReadStream(filePath)\n      };\n\n      try {\n        request.post({\n          url: qlikHDRServer + '/qrs/app/upload?name=' + appName + '&xrfkey=' + senseConfig.xrfkey,\n          headers: {\n            'Content-Type': 'application/vnd.qlik.sense.app',\n            'hdr-usr': senseConfig.headerValue,\n            'X-Qlik-xrfkey': senseConfig.xrfkey\n          },\n          formData: formData\n        }, function (error, res, body) {\n          if (!error) {\n            var appId = JSON.parse(body).id;\n            console.log('Uploaded \"' + appName + '.qvf\" to Qlik Sense and got appID: ' + appId);\n            resolve(appId);\n          } else {\n            console.error(\"Failed to upload app\" + appName, error);\n            reject(error);\n          }\n        });\n      } catch (error) {\n        console.error('failed to upload app', error);\n      }\n    }));\n  });\n} //\n// ─── COPYAPP ────────────────────────────────────────────────────────────────────\n//\n\n\nfunction copyApp(guid, name, generationUserId) {\n  check(guid, String);\n  check(name, String); // console.log('QRS Functions copy App, copy the app id: ' + guid + ' to app with name: ', name);\n\n  const call = {};\n\n  try {\n    call.request = qrsSrv + '/qrs/app/' + guid + '/copy';\n    call.response = HTTP.post(call.request, {\n      'npmRequestOptions': configCerticates,\n      params: {\n        'xrfkey': senseConfig.xrfkey,\n        \"name\": name\n      },\n      data: {}\n    });\n    REST_Log(call, generationUserId);\n    var newGuid = call.response.data.id; // console.log('Step 2: the new app id is: ', newGuid);\n    //addTag('App', newGuid);\n\n    return newGuid;\n  } catch (err) {\n    console.error(err);\n    call.action = 'Copy app FAILED';\n    call.response = err.message;\n    REST_Log(call, generationUserId);\n    throw new Meteor.Error('Copy app for selected customers failed', err.message);\n  }\n}\n\n; //\n// ─── CHECKSTREAMSTATUS ──────────────────────────────────────────────────────────\n//\n\nfunction checkStreamStatus(customer, generationUserId) {\n  console.log('checkStreamStatus for: ' + customer.name); //first update the list of streams we have from Sense. (we keep a private copy, which should reflect the state of Sense)\n\n  Meteor.call('updateLocalSenseCopyStreams');\n  var stream = Streams.findOne({\n    name: customer.name\n  }); //Find the stream for the name of the customer in Mongo, and get his Id from the returned object\n\n  var streamId = '';\n\n  if (stream) {\n    console.log('Stream already exists: ', stream.id);\n    streamId = stream.id;\n  } else {\n    console.log('No stream for customer exist, so create one: ' + customer.name);\n    streamId = QSStream.createStream(customer.name, generationUserId).id;\n    console.log('Step 1: the (new) stream ID for ' + customer.name + ' is: ', streamId);\n  }\n\n  return streamId;\n} //\n// ─── GETAPPS ────────────────────────────────────────────────────────────────────\n//    \n\n\nfunction getApps(name, stream) {\n  console.log('getApps ' + name + ' with stream: ' + stream);\n  var path = '/qrs/app/full'; //if a name/stream is provided only search the apps with this name\n\n  if (name) {\n    path += \"?filter=Name eq '\" + name + \"'\";\n\n    if (stream) {\n      path += \" and stream.name eq '\" + stream + \"'\";\n      console.log('getApps(name: ' + name + ' and stream ' + stream + ' via API path: ' + path);\n    }\n  } else {\n    console.log('getApps via API path: ' + path);\n  }\n\n  var call = {\n    action: 'Get list of apps',\n    request: path\n  }; // REST_Log(call,generationUserId);\n\n  try {\n    return qrs.get(call.request);\n  } catch (error) {\n    console.error('Error while getting the apps via the QRS API: we can not connect to Qlik Sense');\n    console.log(error);\n  }\n}\n\n; //\n// ─── DELETEAPP ──────────────────────────────────────────────────────────────────\n//\n\nfunction deleteApp(guid, generationUserId = 'Not defined') {\n  console.log('QRSApp deleteApp: ', guid);\n\n  try {\n    const call = {};\n    call.request = qrsSrv + '/qrs/app/' + guid;\n    call.response = HTTP.del(call.request, {\n      params: {\n        xrfkey: senseConfig.xrfkey\n      },\n      npmRequestOptions: configCerticates,\n      data: {}\n    }); // Meteor.call('updateLocalSenseCopy');\n    //logging only\n\n    call.action = 'Delete app';\n    call.url = gitHubLinks.deleteApp;\n    call.response = call.response;\n    REST_Log(call, generationUserId);\n    return call.response;\n  } catch (err) {\n    console.error(err);\n    throw new Meteor.Error('App delete failed', err.message);\n  }\n}\n\n; //\n// ─── PUBLISHAPP ─────────────────────────────────────────────────────────────────\n//\n\nfunction publishApp(appGuid, appName, streamId, customerName, generationUserId) {\n  console.log('Publish app: ' + appName + ' to stream: ' + streamId);\n  check(appGuid, String);\n  check(appName, String);\n  check(streamId, String);\n\n  try {\n    const call = {};\n    call.request = qrsSrv + '/qrs/app/' + appGuid + '/publish?name=' + appName + '&stream=' + streamId;\n    call.response = HTTP.put(call.request, {\n      params: {\n        xrfkey: senseConfig.xrfkey\n      },\n      npmRequestOptions: configCerticates,\n      data: {}\n    }); //logging into database\n\n    call.action = 'Publish app';\n    call.url = gitHubLinks.publishApp;\n    REST_Log(call, generationUserId);\n    return call.response;\n  } catch (err) {\n    console.error(err); // // IF APP ALREADY EXISTED TRY TO PUBLISH OVERWRITE IT (REPLACE)\n    // if(err.response.statusCode == 400){\n    //     replaceApp()\n    // }\n    // console.error('statusCode:', err.response.statusCode);\n    // console.info('Try to PUBLISH OVERWRITE THE APP, SINCE IT WAS ALREADY PUBLISHED');\n\n    throw new Meteor.Error('Publication of app ' + appName + ' for customer ' + customerName + ' failed: ', err.message);\n  }\n}\n\n; // REPLACE APP \n// export function replaceApp(targetApp, replaceByApp, generationUserId) {\n//     console.log('Function: Replace app: ' + targetApp + ' by app ' + targetApp);\n//     check(appGuid, String);\n//     check(replaceByApp, String);\n//     try {\n//         const result = HTTP.put(qlikHDRServer + '/qrs/app/' + replaceByApp + '/replace?app=' + targetApp + '&xrfkey=' + senseConfig.xrfkey, {\n//             headers: {\n//                 'hdr-usr': senseConfig.headerValue,\n//                 'X-Qlik-xrfkey': senseConfig.xrfkey\n//             }\n//         });\n//         //logging into database\n//         const call = {};\n//         call.action = 'Replace app';\n//         call.request = 'HTTP.put(' + qlikHDRServer + '/qrs/app/' + replaceByApp + '/replace?app=' + targetApp + '&xrfkey=' + senseConfig.xrfkey;\n//         call.response = result;\n//         call.url = 'http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-App-Replace.htm';\n//         REST_Log(call, generationUserId);\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Publication of app ' + appName + ' for customer ' + customerName + ' failed: ', err.message);\n//     }\n// };\n// function createTag(name) {\n//     check(name, String);\n//     // console.log('QRS Functions Appp, create a tag: ' + name);\n//     try {\n//         const result = HTTP.post(qlikHDRServer + '/qrs/Tag', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 \"name\": name\n//             }\n//         })\n//         //logging only\n//         const call = {};\n//         call.action = 'create Tag';\n//         call.request = 'HTTP.get(http://' + senseConfig.SenseServerInternalLanIP + ':' + senseConfig.port + '/' + senseConfig.virtualProxy + '/qrs/tag';\n//         call.response = result;\n//         REST_Log(call, generationUserId);\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Tag: ' + name + ' create failed ', err.message);\n//     }\n// };\n// function addTag(type, guid, tagName) {\n//     check(type, String);\n//     check(guid, String);\n//     //check if tag with tagName already exists\n//     var selectionId = createSelection(type, guid);\n//     addTagViaSyntheticToType('App', selectionId, tagGuid)\n// }\n// function createSelection(type, guid) {\n//     check(type, String);\n//     check(guid, String);\n//     console.log('QRS Functions APP, create selection for type: ', type + ' ' + guid);\n//     try {\n//         const result = HTTP.post(qlikHDRServer + '/qrs/Selection', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 items: [{\n//                     type: type,\n//                     objectID: guid\n//                 }]\n//             }\n//         })\n//         console.log('the result of selection for type: ', type + ' ' + guid);\n//         console.log(result);\n//         return result.id;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection: ' + type + ' failed for guid ' + guid, err.message);\n//     }\n// };\n// function deleteSelection(selectionId) {\n//     check(selectionId, String);\n//     console.log('QRS Functions APP, deleteSelection selection for selectionId: ', selectionId);\n//     try {\n//         const result = HTTP.delete(qlikHDRServer + '/qrs/Selection/' + selectionId, {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             }\n//         })\n//         console.log(result);\n//         return result.id;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection delete failed: ', err.message);\n//     }\n// };\n// function buildModDate() {\n//     var d = new Date();\n//     return d.toISOString();\n// }\n// function addTagViaSyntheticToType(type, selectionId, tagGuid) {\n//     check(type, String);\n//     check(guid, String);\n//     console.log('QRS Functions Appp, Update all entities of a specific type: ' + type + ' in the selection set identified by {id} ' + selectionId + ' based on an existing synthetic object. : ');\n//     try {\n//         const result = HTTP.put(qlikHDRServer + '/qrs/Selection/' + selectionId + '/' + type + '/synthetic', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 \"latestModifiedDate\": buildModDate(),\n//                 \"properties\": [{\n//                     \"name\": \"refList_Tag\",\n//                     \"value\": {\n//                         \"added\": [tagGuid]\n//                     },\n//                     \"valueIsModified\": true\n//                 }],\n//                 \"type\": type\n//             }\n//         })\n//         console.log('the result of selection for type: ', type + ' ' + guid);\n//         console.log(result);\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection: ' + type + ' failed for guid ' + guid, err.message);\n//     }\n// };\n// async function uploadPublishTemplateApps() {\n//     //check if template apps have been uploaded and published in the templates stream\n//     // if (true) { // (!Apps.find({ \"stream.name\": \"Templates\" }).count()) {\n//     console.warn('no template apps found, so upload from the templates dir.');\n//     var folder = Meteor.settings.private.templateAppsFrom;\n//     // var folder = await copyTemplatesToQRSFolder();\n//     console.log('apps folder', folder);\n//     uploadAndPublishApps(folder);\n//     // } else {}\n// }\n// //upload and publish all apps found in the folder to the templates stream\n// async function copyTemplatesToQRSFolder() {\n//     var newFolder = Meteor.settings.private.templateAppsTo + '\\\\' + process.env.USERDOMAIN + '\\\\' + process.env.USERNAME;\n//     try {\n//         await fs.copy(Meteor.settings.private.templateAppsFrom, newFolder, {\n//             overwrite: true\n//         }); //\"QLIK-AB0Q2URN5T\\\\Qlikexternal\",\n//         return newFolder\n//     } catch (err) {\n//         console.error('error copy Templates from ' + Meteor.settings.private.templateAppsFrom + ' To QRSFolder ' + Meteor.settings.private.templateAppsDir, err);\n//     }\n// }\n// For a system service account, the app must be in the %ProgramData%\\Qlik\\Sense\\Repository\\DefaultApps folder.\n// For any other account, the app must be in the %ProgramData%\\Qlik\\Sense\\Apps\\<login domain>\\<login user> folder.\n//so you have to copy your apps there first. in a fresh sense installation.\n\nfunction importApp(fileName, name, generationUserId = 'no user set') {// check(fileName, String);\n  // check(name, String);\n  // console.log('QRS Functions import App, with name ' + name + ', with fileName: ', fileName);\n  // try {\n  //     const call = {};\n  //     call.action = 'Import app';\n  //     call.url = 'http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-App-Import-App.htm'\n  //     call.request = qlikHDRServer + '/qrs/app/import?keepData=true&name=' + name + '&xrfkey=' + senseConfig.xrfkey; //using header auth.\n  //     call.response = HTTP.post(call.request, {\n  //         headers: {\n  //             'hdr-usr': senseConfig.headerValue,\n  //             'X-Qlik-xrfkey': senseConfig.xrfkey\n  //         },\n  //         data: '\"Sales.qvf\"'\n  //     });\n  //     REST_Log(call, generationUserId);\n  //     var newGuid = call.response.data.id;\n  //     return newGuid;\n  // } catch (err) {\n  //     console.error(err);\n  //     const call = {};\n  //     call.action = 'Import app FAILED';\n  //     call.response = err.message;\n  //     REST_Log(call, generationUserId);\n  //     throw new Meteor.Error('Import app failed', err.message);\n  // }\n}\n\n; //https://www.npmjs.com/package/request#forms\n// function uploadApp(filePath, fileSize, appName) {\n//     console.log('QRS Functions upload App, with name ' + appName + ', with fileSize: ', fileSize + ' and filePath ' + filePath);\n//     var formData = {\n//         my_file: fs.createReadStream(filePath)\n//     };\n//     request.post({\n//         url: qlikHDRServer + '/qrs/app/upload?name=' + appName + '&xrfkey=' + senseConfig.xrfkey,\n//         headers: {\n//             'Content-Type': 'application/vnd.qlik.sense.app',\n//             'hdr-usr': senseConfig.headerValue,\n//             'X-Qlik-xrfkey': senseConfig.xrfkey\n//         },\n//         formData: formData\n//     }, function optionalCallback(err, httpResponse, body) {\n//         if (err) {\n//             return console.error('upload failed:', err);\n//         }\n//         console.log('Upload successful!  Server responded with:', body);\n//     });\n// }","map":{"version":3,"sources":["imports/api/server/QRSFunctionsApp.js"],"names":["module","export","uploadAndPublishTemplateApps","generateStreamAndApp","setAppIDs","createAppConnections","createAppConnection","copyApp","getApps","deleteApp","publishApp","importApp","Meteor","watch","require","v","http","Apps","TemplateApps","GeneratedResources","QSStream","gitHubLinks","Streams","Customers","createVirtualProxies","qlikHDRServer","senseConfig","enigmaServerConfig","qrsSrv","qrs","configCerticates","_slideGeneratorAppId","APILogs","REST_Log","lodash","default","_","path","fs","enigma","promise","request","sanitize","console","log","newFolder","join","settings","broker","automationBaseFolder","everyOneStreamId","getStreamByName","qlikSense","EveryoneAppStreamName","id","templateStreamId","public","TemplateAppStreamName","APIAppsStreamID","APIAppStreamName","check","String","err","error","Error","appsInFolder","readdir","Promise","all","map","QVF","appName","substr","indexOf","filePath","length","appId","uploadApp","_SSBIApp","copiedAppId","customers","generationUserId","templateApps","checkTemplateAppExists","checkCustomersAreSelected","customer","templateApp","generateAppForTemplate","params","slideGenerator","name","stream","selectionSheet","dataObject","slideObject","virtualProxy","SSBI","sheetId","slideGeneratorApps","SSBIApps","SSBIApp","slideGeneratorAppId","call","action","createdBy","streamId","checkStreamStatus","customerDataFolder","createDirectory","createDataConnectionPerCustomer","newAppId","result","reloadAppAndReplaceScriptviaEngine","publishedAppId","insert","newAppName","scriptReplace","config","Object","assign","process","on","up","qix","getService","url","replaceAndReloadApp","script","getScript","response","setScript","replaceScript","doReload","reloadApp","saveApp","doSave","senseDemoMaterials","absolutePath","c","dataConnections","type","connectionString","qConnectionId","createConnection","deleteDirectoryAndDataConnection","customerName","filename","dir","customerDataDir","ensureDir","find","userId","fetch","resolve","reject","formData","my_file","createReadStream","post","xrfkey","headers","headerValue","res","body","JSON","parse","guid","HTTP","data","newGuid","message","findOne","createStream","get","del","npmRequestOptions","appGuid","put","fileName"],"mappings":"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;AAEA,MAAI;AACA,UAAMyC,OAAO,EAAb;AACAA,SAAK7D,OAAL,GAAeb,SAAS,WAAT,GAAuBoJ,OAAvB,GAAiC,gBAAjC,GAAoDzG,OAApD,GAA8D,UAA9D,GAA2EkC,QAA1F;AACAH,SAAK2B,QAAL,GAAgBsC,KAAKU,GAAL,CAAS3E,KAAK7D,OAAd,EAAuB;AACnC+C,cAAQ;AACJuE,gBAAQrI,YAAYqI;AADhB,OAD2B;AAInCgB,yBAAmBjJ,gBAJgB;AAKnC0I,YAAM;AAL6B,KAAvB,CAAhB,CAHA,CAYA;;AACAlE,SAAKC,MAAL,GAAc,aAAd;AACAD,SAAKuB,GAAL,GAAWxG,YAAYX,UAAvB;AACAuB,aAASqE,IAAT,EAAerB,gBAAf;AACA,WAAOqB,KAAK2B,QAAZ;AACH,GAjBD,CAiBE,OAAOnE,GAAP,EAAY;AACVnB,YAAQoB,KAAR,CAAcD,GAAd,EADU,CAGV;AACA;AACA;AACA;AACA;AACA;;AACA,UAAM,IAAIlD,OAAOoD,KAAX,CAAiB,wBAAwBO,OAAxB,GAAkC,gBAAlC,GAAqD0E,YAArD,GAAoE,WAArF,EAAkGnF,IAAI4G,OAAtG,CAAN;AACH;AACJ;;AAAA,C,CAED;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACO,SAAS/J,SAAT,CAAmBuK,QAAnB,EAA6BxF,IAA7B,EAAmCT,mBAAmB,aAAtD,EAAqE,CACxE;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {\n    Meteor\n} from 'meteor/meteor';\nimport {\n    http\n} from 'meteor/meteor';\nimport {\n    Apps,\n    TemplateApps,\n    GeneratedResources\n} from '/imports/api/apps';\nimport * as QSStream from '/imports/api/server/QRSFunctionsStream';\nimport {\n    gitHubLinks\n} from '/imports/ui/UIHelpers';\n\n//import meteor collections\nimport {\n    Streams\n} from '/imports/api/streams';\nimport {\n    Customers\n} from '/imports/api/customers';\n\nimport {\n    createVirtualProxies\n} from '/imports/api/server/QPSFunctions';\n\n\n//import config for Qlik Sense QRS and Engine API//\nimport {\n    qlikHDRServer, // Qlik sense QRS endpoint via header authentication\n    senseConfig,\n    enigmaServerConfig,\n    qrsSrv,\n    qrs,\n    configCerticates,\n    _slideGeneratorAppId\n} from '/imports/api/config.js';\nimport {\n    APILogs,\n    REST_Log\n} from '/imports/api/APILogs';\nimport lodash from 'lodash';\n_ = lodash;\n\n//\n// ─── INSTALL NPM MODULES ────────────────────────────────────────────────────────\n//\nconst path = require('path');\nconst fs = require('fs-extra');\nconst enigma = require('enigma.js');\nvar promise = require('bluebird');\nvar request = require('request');\nvar sanitize = require(\"sanitize-filename\");\n\n\n//\n// ─── UPLOAD APPS FOR THE INITIAL SETUP OF QLIK SENSE ─────────────────────────\n//\n\n\n// UPLOAD TEMPLATES APPS FROM FOLDER, AND PUBLISH INTO THE TEMPLATES STREAM\nexport async function uploadAndPublishTemplateApps() {\n    console.log('------------------------------------');\n    console.log('uploadAndPublishTemplateApps');\n    console.log('------------------------------------');\n    var newFolder = path.join(Meteor.settings.broker.automationBaseFolder, 'apps');\n    console.log('uploadAndPublishTemplateApps: Read all files in the template apps folder \"' + newFolder + '\" and upload them to Qlik Sense.');\n\n    //GET THE ID OF THE IMPORTANT STREAMS (streams that QRSMeteor needs)\n    var everyOneStreamId = QSStream.getStreamByName(Meteor.settings.broker.qlikSense.EveryoneAppStreamName).id;\n    var templateStreamId = QSStream.getStreamByName(Meteor.settings.public.TemplateAppStreamName).id;\n    var APIAppsStreamID = QSStream.getStreamByName(Meteor.settings.broker.qlikSense.APIAppStreamName).id;\n    try {\n        check(newFolder, String);\n        check(everyOneStreamId, String);\n        check(templateStreamId, String);\n        check(APIAppsStreamID, String);\n    } catch (err) {\n        console.error('You did not specify the templateAppsFrom, everyone, api apps or template stream name in the settings.json file?');\n        throw new Meteor.Error('Missing Settings', 'You did not specify the everone, api apps or template stream name in the settings.json file?');\n    }\n\n    // LOAD ALL SENSE APPS IN FOLDER\n    var appsInFolder = await fs.readdir(newFolder);\n\n    // FOR EACH APP FOUND: PUBLISH IT    \n    return await Promise.all(appsInFolder.map(async(QVF) => {\n        try {\n            //GET THE NAME OF THE APP AND CREATE A FILEPATH\n            var appName = QVF.substr(0, QVF.indexOf('.'));\n            var filePath = path.join(newFolder, QVF);\n\n            //ONLY UPLOAD APPS IF THEY DO NOT ALREADY EXIST\n            if (!getApps(appName).length) {\n                //UPLOAD THE APP, GET THE APP ID BACK\n                var appId = await uploadApp(filePath, appName);\n\n                //BASED ON THE APP WE WANT TO PUBLISH IT INTO A DIFFERENT STREAM                      \n                if (appName === 'SSBI') { //should be published in the everyone stream\n                    _SSBIApp = appId; // for the client side HTML/IFrames etc.                                \n                    publishApp(appId, appName, everyOneStreamId);\n                } else if (appName === 'Sales') { //THIS ONE NEEDS TO BE COPIED AND PUBLISHED INTO 2 STREAMS: AS TEMPLATE AND FOR THE EVERYONE STREAM.\n                    publishApp(appId, appName, everyOneStreamId);\n                    var copiedAppId = copyApp(appId, appName);\n                    publishApp(copiedAppId, appName, templateStreamId);\n                } else if (appName === 'Slide generator') {\n                    _slideGeneratorAppId = appId,\n                        publishApp(appId, appName, APIAppsStreamID);\n                } else {\n                    //Insert into template apps stream\n                    publishApp(appId, appName, templateStreamId);\n                }\n            } else {\n                console.log('App ' + appName + ' already exists in Qlik Sense')\n            };\n        } catch (err) {\n            console.error(err);\n            throw new Meteor.Error('Unable to upload the app to Qlik Sense. ', err)\n        }\n    }))\n}\n\nexport async function generateStreamAndApp(customers, generationUserId) {\n    console.log('METHOD called: generateStreamAndApp for the template apps as stored in the database of the fictive OEM');\n\n    try {\n        var templateApps = checkTemplateAppExists(generationUserId); //is a template app selected, and does the guid still exist in Sense? if yes, return the valid templates\n        checkCustomersAreSelected(customers); //have we selected a  customer to do the generation for?\n\n        console.log('------------------------------------');\n        console.log('start generation for ', customers);\n        console.log('------------------------------------');\n        for (const customer of customers) {\n            for (const templateApp of templateApps) {\n                await generateAppForTemplate(templateApp, customer, generationUserId);\n            }\n        };\n    } catch (error) {\n        console.error(error);\n    }\n\n};\n\nexport function setAppIDs(params) {\n    console.log('------------------------------------');\n    console.log('SET APP IDs');\n    console.log('------------------------------------');\n    try {\n        console.log('check if all settings.json parameters are set...')\n        check(Meteor.settings.public.slideGenerator, {\n            name: String,\n            stream: String,\n            selectionSheet: String,\n            dataObject: String,\n            slideObject: String,\n            virtualProxy: String\n        });\n        check(Meteor.settings.public.SSBI, {\n            name: String,\n            stream: String,\n            sheetId: String,\n            appId: String\n        });\n    } catch (err) {\n        console.error('Missing parameters in your settings.json file for the SSBI or slidegenerator...', err)\n    }\n\n    try {\n        var slideGeneratorApps = getApps(Meteor.settings.public.slideGenerator.name, Meteor.settings.public.slideGenerator.stream);\n        var SSBIApps = getApps(Meteor.settings.public.SSBI.name, Meteor.settings.public.SSBI.stream);\n        if (slideGeneratorApps.length > 1) {\n            throw new Error('Can not automatically set the app ID for the slide generator. You have not one but you have multiple slide generator apps under the name ' + Meteor.settings.public.slideGenerator.name + ' in the stream ' + Meteor.settings.public.slideGenerator.stream);\n        }\n        if (SSBIApps.length > 1) {\n            throw new Error('Can not automatically set the app ID for the Self Service BI app. You have not one but you have multiple Self Service apps under the name ' + Meteor.settings.public.SSBI.name + ' in the stream ' + Meteor.settings.public.SSBI.stream);\n        }\n        senseConfig.SSBIApp = SSBIApps[0].id; //\n        console.log('The SSBI app id has been set to ', senseConfig.SSBIApp);\n\n        senseConfig.slideGeneratorAppId = slideGeneratorApps[0].id;\n        console.log('The slide generator app id has been set to ', senseConfig.slideGeneratorAppId);\n        console.log('------------------------------------');\n        console.log('YOU HAVE SUCCESFULLY STARTED QRSMETEOR, WE ARE CONNECTED TO QLIK SENSE');\n        console.log('------------------------------------');\n    } catch (err) {\n        console.error(err)\n        throw new Meteor.Error('The slideGenerator or Self Service BI app can not be found in Qlik sense, or you did not have all parameters set as defined in the the settings.json example file.', err);\n    }\n}\n\n\nasync function generateAppForTemplate(templateApp, customer, generationUserId) {\n    console.log('--------------------------GENERATE APPS FOR TEMPLATE');\n    // console.log(templateApp);\n    // console.log('############## START CREATING THE TEMPLATE ' + templateApp.name + ' FOR THIS CUSTOMER: ' + customer.name + ' FOR generationUserId: ' + generationUserId);\n    const call = {};\n    call.action = 'Start of generation of app ' + templateApp.name + ' for ' + customer.name;\n    call.createdBy = generationUserId;\n    call.request = 'Start creating app ' + templateApp.name + ' for customer ' + customer.name;\n    REST_Log(call, generationUserId);\n\n    try {\n        var streamId = checkStreamStatus(customer, generationUserId) //create a stream for the customer if it not already exists \n        var customerDataFolder = await createDirectory(customer.name); //for data like XLS/qvd specific for a customer\n        if (Meteor.settings.broker.createDataConnectionPerCustomer)\n         {await createAppConnection('folder', customer.name, customerDataFolder);}\n        var newAppId = copyApp(templateApp.id, templateApp.name, generationUserId);\n        var result = reloadAppAndReplaceScriptviaEngine(newAppId, templateApp.name, streamId, customer, customerDataFolder, '', generationUserId);\n        var publishedAppId = publishApp(newAppId, templateApp.name, streamId, customer.name, generationUserId);\n\n        //logging only\n        const call = {};\n        call.action = 'Finished generation for ' + customer.name;\n        call.request = templateApp.name + ' has been created and reloaded with data from the ' + customer.name + ' database';\n        REST_Log(call, generationUserId);\n        console.log('############## FINISHED CREATING THE TEMPLATE ' + templateApp.name + ' FOR THIS CUSTOMER: ' + customer.name);\n        GeneratedResources.insert({\n            'generationUserId': generationUserId,\n            'customer': customer.name,\n            'streamId': streamId,\n            'appId': newAppId\n        });\n    } catch (err) {\n        console.error('Failed to generate...', err);\n        throw new Meteor.Error('Generation failed', 'The server has an internal error, please check the server command logs');\n    }\n    return;\n};\n\n\n//Example to demo that you can also use the Engine API to get all the apps, or reload an app, set the script etc.\n//source based on loic's work: https://github.com/pouc/qlik-elastic/blob/master/app.js\nasync function reloadAppAndReplaceScriptviaEngine(appId, newAppName, streamId, customer, customerDataFolder, scriptReplace, generationUserId) {\n    console.log('--------------------------REPLACE SCRIPT AND RELOAD APP');\n\n    //set the app ID to be used in the enigma connection to the engine API\n    var config = Object.assign({}, enigmaServerConfig);\n    config.appId = appId;\n\n    try {\n        process.on('unhandledRejection', up => { //ignore \n        })\n        check(appId, String);\n        check(customer.name, String);\n        check(customerDataFolder, String);\n        check(generationUserId, String);\n\n        //connect to the engine\n        var qix = await enigma.getService('qix', config);\n        var call = {};\n        call.action = 'Connect to Qlik Sense';\n        call.request = 'Connect to Engine API (using Enigma.js) using an appId: ' + appId;\n        call.url = gitHubLinks.replaceAndReloadApp;\n        REST_Log(call, generationUserId);\n\n        /* try {\n            //create folder connection \n            console.log('create folder connection, if you see a warning below that means the connection already existed.');\n            var qConnectionId = await qix.createConnection({\n                \"qName\": customer.name,\n                \"qType\": \"folder\",\n                \"qConnectionString\": customerDataFolder\n            })\n            var call = {};\n            call.action = 'Create data/folder connection';\n            call.url = '';\n            call.request = 'Link to a folder on the server where users can put files/QVD, or create a REST/ODBC/OLEDB... database connection.';\n            call.response = 'created folder connection: ' + qConnectionId;\n            console.log('created folder connection: ', qConnectionId);\n        } catch (error) {\n            console.info('No issue, existing customer so his data folder connection already exists', error);\n        } */\n\n        //get the script\n        var script = await qix.getScript();\n        var call = {};\n        call.action = 'Get data load script';\n        call.url = gitHubLinks.getScript;\n        call.request = 'We extracted the following load script from the app';\n        call.response = script;\n        REST_Log(call, generationUserId);\n\n        //set the new script\n        var call = {};\n        call.response = await qix.setScript(replaceScript(script)) //we now just include the old script in this app\n        call.action = 'Insert customer specific data load script for its database';\n        call.url = gitHubLinks.setScript;\n        call.request = 'The script of the app has been replaced with a customer specific one. Normally you would replace the database connection for each customer. Or you can insert a customer specific script to enable customization per customer. ';\n        REST_Log(call, generationUserId);\n\n        //reload the app\n        var call = {};\n        call.response = await qix.doReload()\n        call.action = 'Reload the app';\n        call.url = gitHubLinks.reloadApp;\n        call.request = 'Has the app been reloaded with customer specific data?';\n        REST_Log(call, generationUserId);\n\n        //save the app\n        var call = {};\n        call.action = 'Save app'\n        call.url = gitHubLinks.saveApp;\n        call.request = 'App with GUID ' + appId + ' has been saved to disk';\n        REST_Log(call, generationUserId);\n        await qix.doSave();\n\n        REST_Log(call, generationUserId);\n        process.on('unhandledRejection', up => { throw up })\n    } catch (error) {\n        console.error('error in reloadAppAndReplaceScriptviaEngine via Enigma.JS, did you used the correct schema definition in the settings.json file?', error);\n    }\n\n    function replaceScript(script) {\n        //var scriptMarker = '§dummyDatabaseString§';\n        // if you want to replace the database connection per customer use the script below.\n        //return doc.setScript(script.replace(scriptMarker, scriptReplace)).then(function (result) {\n        //you can also change the sense database connection: https://github.com/mindspank/qsocks/blob/master/examples/App/create-dataconnection.js\n        return script;\n    }\n}\nexport async function createAppConnections() {\n    console.log('------------------------------------');\n    console.log('create app connections');\n    console.log('------------------------------------');\n    //create the default demo import folder where all the csv and qvf files are...\n    var senseDemoMaterials = path.join(Meteor.absolutePath, 'Sense Demo materials');\n    console.log('senseDemoMaterials', senseDemoMaterials)\n    await createAppConnection('folder', 'Import demo', senseDemoMaterials);\n\n    for (let c of Meteor.settings.broker.dataConnections) {\n        await createAppConnection(c.type, c.name, c.connectionString);\n    }\n}\n\nexport async function createAppConnection(type, name, path) {\n\n    //set the app ID to be used in the enigma connection to the engine API\n    var config = Object.assign({}, enigmaServerConfig);\n    config.appId = getApps('sales', 'Everyone')[0].id;\n    console.log('createAppConnection: ' + type + ' ' + name + ' ' + path + ' using the sales app in the everyone stream to create the connection: ' + config.appId);\n    try {\n        check(type, String);\n        check(path, String);\n        check(name, String);\n        check(config.appId, String);\n    } catch (error) {\n        console.error('Missing parameters to create a data connection', error);\n    }\n\n    try {\n        //connect to the engine\n        var qix = await enigma.getService('qix', config);\n\n        //create folder connection \n        console.log('create folder connection, if you see a warning below that means the connection already existed.');\n\n        var qConnectionId = await qix.createConnection({\n            \"qName\": name,\n            \"qType\": type,\n            \"qConnectionString\": path\n        })\n        console.log('created folder connection: ', qConnectionId);\n    } catch (error) {\n        console.error('Failed to create data connection', error);\n    }\n}\n\nfunction deleteDirectoryAndDataConnection(customerName) {\n    console.log('deleteDirectoryAndDataConnection');\n    //@TODO a bit dangerous, so better to do by hand. Make sure you can't delete root folder... \n    // https://stackoverflow.com/questions/18052762/remove-directory-which-is-not-empty\n}\n\nasync function createDirectory(customerName) {\n    console.log('createDirectory ', customerName)\n    try {\n        check(customerName, String);\n        var filename = sanitize(customerName);\n        const dir = path.join(Meteor.settings.broker.customerDataDir, customerName);\n        console.log('Meteor.settings.broker.customerDataDir', dir)\n        await fs.ensureDir(dir)\n        return dir;\n    } catch (error) {\n        throw new Meteor.Error('Failed to create directory for ', customerName);\n    }\n\n}\n\nfunction checkCustomersAreSelected(customers) {\n    if (!customers.length) { // = 0\n        throw new Meteor.Error('No customers', 'user has not specified at least one customer for which an app can be generated');\n    }\n};\n\n// CHECK IF SELECTED TEMPLATE APP EXISTS IN QLIK SENSE\n//These are the apps that the OEM partner has in his database, but do they still exists on the qliks sense side?\nfunction checkTemplateAppExists(generationUserId) {\n    console.log('------------------------------------');\n    console.log('checkTemplateAppExists for userID ', generationUserId)\n    console.log('------------------------------------');\n\n    var templateApps = TemplateApps.find({\n            'generationUserId': Meteor.userId()\n        })\n        .fetch();\n    return templateApps;\n\n    // console.log('templateApps found: ', templateApps)\n\n    // if (templateApps.length === 0) { //user has not specified a template\n    //     throw new Meteor.Error('No Template', 'user has not specified a template for which apps can be generated');\n    // }\n\n    // currentAppsInSense = getApps();\n    // if (!currentAppsInSense) {\n    //     throw new Meteor.Error('No apps have been received from Qlik Sense. Therefore you have selected a Qlik Sense App: ' + templateApp.name + ' with guid: ' + templateApp.id + ' which does not exist in Sense anymore. Have you deleted the template in Sense?');\n    // }\n\n    // _.each(templateApps, function(templateApp) {\n    //     console.log('templateApp in MongoDB: ', templateApp)\n    //     var templateFound = _.some(currentAppsInSense, ['id', templateApp.id]);\n\n    //     if (!templateFound) {\n    //         console.log('------------------------------------');\n    //         console.log('!! template app exists in mongoDB but not in Qlik Sense');\n    //         console.log('------------------------------------');\n    //         throw new Meteor.Error('You have selected a Qlik Sense App: ' + templateApp.name + ' with guid: ' + templateApp.id + ' which does not exist in Sense anymore. Have you deleted the template in Sense?');\n    //     } else {\n    //         console.log('checkTemplateAppExists: True, template guid exist: ', templateApp.id);\n    //     }\n    // })\n    // return templateApps;\n};\n\n//\n// ─── UPLOAD APP ─────────────────────────────────────────────────────────────────\n//\n\n\nasync function uploadApp(filePath, appName) {\n    console.log('Upload app: ' + appName + ' from path: ' + filePath + ' via header authentication server: ' + qlikHDRServer);\n    return await new Promise(function(resolve, reject) {\n        var formData = {\n            my_file: fs.createReadStream(filePath)\n        };\n\n        try {\n            request.post({\n                url: qlikHDRServer + '/qrs/app/upload?name=' + appName + '&xrfkey=' + senseConfig.xrfkey,\n                headers: {\n                    'Content-Type': 'application/vnd.qlik.sense.app',\n                    'hdr-usr': senseConfig.headerValue,\n                    'X-Qlik-xrfkey': senseConfig.xrfkey\n                },\n                formData: formData\n            }, function(error, res, body) {\n                if (!error) {\n                    var appId = JSON.parse(body).id;\n                    console.log('Uploaded \"' + appName + '.qvf\" to Qlik Sense and got appID: ' + appId);\n                    resolve(appId);\n                } else {\n                    console.error(\"Failed to upload app\" + appName, error);\n                    reject(error);\n                }\n            });\n        } catch (error) {\n            console.error('failed to upload app', error);\n        }\n    });\n}\n//\n// ─── COPYAPP ────────────────────────────────────────────────────────────────────\n//\n\n\nexport function copyApp(guid, name, generationUserId) {\n    check(guid, String);\n    check(name, String);\n    // console.log('QRS Functions copy App, copy the app id: ' + guid + ' to app with name: ', name);\n    const call = {};\n\n    try {\n        call.request = qrsSrv + '/qrs/app/' + guid + '/copy';\n        call.response = HTTP.post(call.request, {\n            'npmRequestOptions': configCerticates,\n            params: {\n                'xrfkey': senseConfig.xrfkey,\n                \"name\": name\n            },\n            data: {}\n        });\n\n\n        REST_Log(call, generationUserId);\n        var newGuid = call.response.data.id;\n        // console.log('Step 2: the new app id is: ', newGuid);\n        //addTag('App', newGuid);\n        return newGuid;\n    } catch (err) {\n        console.error(err);\n        call.action = 'Copy app FAILED';\n        call.response = err.message;\n        REST_Log(call, generationUserId);\n        throw new Meteor.Error('Copy app for selected customers failed', err.message);\n    }\n};\n\n//\n// ─── CHECKSTREAMSTATUS ──────────────────────────────────────────────────────────\n//\n\n\nfunction checkStreamStatus(customer, generationUserId) {\n    console.log('checkStreamStatus for: ' + customer.name);\n    //first update the list of streams we have from Sense. (we keep a private copy, which should reflect the state of Sense)\n    Meteor.call('updateLocalSenseCopyStreams');\n\n    var stream = Streams.findOne({\n        name: customer.name\n    }); //Find the stream for the name of the customer in Mongo, and get his Id from the returned object\n    var streamId = '';\n    if (stream) {\n        console.log('Stream already exists: ', stream.id);\n        streamId = stream.id;\n    } else {\n        console.log('No stream for customer exist, so create one: ' + customer.name);\n        streamId = QSStream.createStream(customer.name, generationUserId).id;\n        console.log('Step 1: the (new) stream ID for ' + customer.name + ' is: ', streamId);\n    }\n\n    return streamId;\n}\n\n//\n// ─── GETAPPS ────────────────────────────────────────────────────────────────────\n//    \n\nexport function getApps(name, stream) {\n    console.log('getApps ' + name + ' with stream: ' + stream);\n    var path = '/qrs/app/full';\n\n    //if a name/stream is provided only search the apps with this name\n    if (name) {\n        path += \"?filter=Name eq '\" + name + \"'\"\n        if (stream) {\n            path += \" and stream.name eq '\" + stream + \"'\"\n            console.log('getApps(name: ' + name + ' and stream ' + stream + ' via API path: ' + path);\n        }\n    } else {\n        console.log('getApps via API path: ' + path);\n    }\n\n    var call = {\n        action: 'Get list of apps',\n        request: path\n    };\n    // REST_Log(call,generationUserId);\n    try {\n        return qrs.get(call.request);\n    } catch (error) {\n        console.error('Error while getting the apps via the QRS API: we can not connect to Qlik Sense');\n        console.log(error);\n    }\n};\n\n//\n// ─── DELETEAPP ──────────────────────────────────────────────────────────────────\n//\n\n\nexport function deleteApp(guid, generationUserId = 'Not defined') {\n    console.log('QRSApp deleteApp: ', guid);\n    try {\n        const call = {};\n        call.request = qrsSrv + '/qrs/app/' + guid;\n        call.response = HTTP.del(call.request, {\n            params: {\n                xrfkey: senseConfig.xrfkey\n            },\n            npmRequestOptions: configCerticates,\n            data: {}\n        });\n\n        // Meteor.call('updateLocalSenseCopy');\n        //logging only\n        call.action = 'Delete app';\n        call.url = gitHubLinks.deleteApp;\n        call.response = call.response;\n        REST_Log(call, generationUserId);\n        return call.response;\n    } catch (err) {\n        console.error(err);\n        throw new Meteor.Error('App delete failed', err.message);\n    }\n};\n\n\n//\n// ─── PUBLISHAPP ─────────────────────────────────────────────────────────────────\n//\n\n\nexport function publishApp(appGuid, appName, streamId, customerName, generationUserId) {\n    console.log('Publish app: ' + appName + ' to stream: ' + streamId);\n    check(appGuid, String);\n    check(appName, String);\n    check(streamId, String);\n\n    try {\n        const call = {};\n        call.request = qrsSrv + '/qrs/app/' + appGuid + '/publish?name=' + appName + '&stream=' + streamId;\n        call.response = HTTP.put(call.request, {\n            params: {\n                xrfkey: senseConfig.xrfkey\n            },\n            npmRequestOptions: configCerticates,\n            data: {}\n        });\n\n\n        //logging into database\n        call.action = 'Publish app';\n        call.url = gitHubLinks.publishApp;\n        REST_Log(call, generationUserId);\n        return call.response;\n    } catch (err) {\n        console.error(err);\n\n        // // IF APP ALREADY EXISTED TRY TO PUBLISH OVERWRITE IT (REPLACE)\n        // if(err.response.statusCode == 400){\n        //     replaceApp()\n        // }\n        // console.error('statusCode:', err.response.statusCode);\n        // console.info('Try to PUBLISH OVERWRITE THE APP, SINCE IT WAS ALREADY PUBLISHED');\n        throw new Meteor.Error('Publication of app ' + appName + ' for customer ' + customerName + ' failed: ', err.message);\n    }\n};\n\n// REPLACE APP \n// export function replaceApp(targetApp, replaceByApp, generationUserId) {\n//     console.log('Function: Replace app: ' + targetApp + ' by app ' + targetApp);\n//     check(appGuid, String);\n//     check(replaceByApp, String);\n\n//     try {\n//         const result = HTTP.put(qlikHDRServer + '/qrs/app/' + replaceByApp + '/replace?app=' + targetApp + '&xrfkey=' + senseConfig.xrfkey, {\n//             headers: {\n//                 'hdr-usr': senseConfig.headerValue,\n//                 'X-Qlik-xrfkey': senseConfig.xrfkey\n//             }\n//         });\n\n//         //logging into database\n//         const call = {};\n//         call.action = 'Replace app';\n//         call.request = 'HTTP.put(' + qlikHDRServer + '/qrs/app/' + replaceByApp + '/replace?app=' + targetApp + '&xrfkey=' + senseConfig.xrfkey;\n//         call.response = result;\n//         call.url = 'http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-App-Replace.htm';\n//         REST_Log(call, generationUserId);\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Publication of app ' + appName + ' for customer ' + customerName + ' failed: ', err.message);\n//     }\n// };\n\n\n// function createTag(name) {\n//     check(name, String);\n//     // console.log('QRS Functions Appp, create a tag: ' + name);\n\n//     try {\n//         const result = HTTP.post(qlikHDRServer + '/qrs/Tag', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 \"name\": name\n//             }\n//         })\n\n//         //logging only\n//         const call = {};\n//         call.action = 'create Tag';\n//         call.request = 'HTTP.get(http://' + senseConfig.SenseServerInternalLanIP + ':' + senseConfig.port + '/' + senseConfig.virtualProxy + '/qrs/tag';\n//         call.response = result;\n//         REST_Log(call, generationUserId);\n\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Tag: ' + name + ' create failed ', err.message);\n//     }\n// };\n\n// function addTag(type, guid, tagName) {\n//     check(type, String);\n//     check(guid, String);\n\n//     //check if tag with tagName already exists\n\n//     var selectionId = createSelection(type, guid);\n//     addTagViaSyntheticToType('App', selectionId, tagGuid)\n\n// }\n\n// function createSelection(type, guid) {\n//     check(type, String);\n//     check(guid, String);\n//     console.log('QRS Functions APP, create selection for type: ', type + ' ' + guid);\n\n//     try {\n//         const result = HTTP.post(qlikHDRServer + '/qrs/Selection', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 items: [{\n//                     type: type,\n//                     objectID: guid\n//                 }]\n//             }\n//         })\n//         console.log('the result of selection for type: ', type + ' ' + guid);\n//         console.log(result);\n//         return result.id;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection: ' + type + ' failed for guid ' + guid, err.message);\n//     }\n// };\n\n// function deleteSelection(selectionId) {\n//     check(selectionId, String);\n//     console.log('QRS Functions APP, deleteSelection selection for selectionId: ', selectionId);\n\n//     try {\n//         const result = HTTP.delete(qlikHDRServer + '/qrs/Selection/' + selectionId, {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             }\n//         })\n//         console.log(result);\n//         return result.id;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection delete failed: ', err.message);\n//     }\n// };\n\n// function buildModDate() {\n//     var d = new Date();\n//     return d.toISOString();\n// }\n\n// function addTagViaSyntheticToType(type, selectionId, tagGuid) {\n//     check(type, String);\n//     check(guid, String);\n//     console.log('QRS Functions Appp, Update all entities of a specific type: ' + type + ' in the selection set identified by {id} ' + selectionId + ' based on an existing synthetic object. : ');\n\n//     try {\n//         const result = HTTP.put(qlikHDRServer + '/qrs/Selection/' + selectionId + '/' + type + '/synthetic', {\n//             headers: authHeaders,\n//             params: {\n//                 'xrfkey': senseConfig.xrfkey\n//             },\n//             data: {\n//                 \"latestModifiedDate\": buildModDate(),\n//                 \"properties\": [{\n//                     \"name\": \"refList_Tag\",\n//                     \"value\": {\n//                         \"added\": [tagGuid]\n//                     },\n//                     \"valueIsModified\": true\n//                 }],\n//                 \"type\": type\n//             }\n//         })\n//         console.log('the result of selection for type: ', type + ' ' + guid);\n//         console.log(result);\n//         return result;\n//     } catch (err) {\n//         console.error(err);\n//         throw new Meteor.Error('Selection: ' + type + ' failed for guid ' + guid, err.message);\n//     }\n// };\n\n\n// async function uploadPublishTemplateApps() {\n//     //check if template apps have been uploaded and published in the templates stream\n//     // if (true) { // (!Apps.find({ \"stream.name\": \"Templates\" }).count()) {\n//     console.warn('no template apps found, so upload from the templates dir.');\n//     var folder = Meteor.settings.private.templateAppsFrom;\n//     // var folder = await copyTemplatesToQRSFolder();\n//     console.log('apps folder', folder);\n//     uploadAndPublishApps(folder);\n//     // } else {}\n// }\n\n// //upload and publish all apps found in the folder to the templates stream\n// async function copyTemplatesToQRSFolder() {\n//     var newFolder = Meteor.settings.private.templateAppsTo + '\\\\' + process.env.USERDOMAIN + '\\\\' + process.env.USERNAME;\n//     try {\n//         await fs.copy(Meteor.settings.private.templateAppsFrom, newFolder, {\n//             overwrite: true\n//         }); //\"QLIK-AB0Q2URN5T\\\\Qlikexternal\",\n//         return newFolder\n//     } catch (err) {\n//         console.error('error copy Templates from ' + Meteor.settings.private.templateAppsFrom + ' To QRSFolder ' + Meteor.settings.private.templateAppsDir, err);\n//     }\n// }\n\n// For a system service account, the app must be in the %ProgramData%\\Qlik\\Sense\\Repository\\DefaultApps folder.\n// For any other account, the app must be in the %ProgramData%\\Qlik\\Sense\\Apps\\<login domain>\\<login user> folder.\n//so you have to copy your apps there first. in a fresh sense installation.\nexport function importApp(fileName, name, generationUserId = 'no user set') {\n    // check(fileName, String);\n    // check(name, String);\n    // console.log('QRS Functions import App, with name ' + name + ', with fileName: ', fileName);\n\n    // try {\n    //     const call = {};\n    //     call.action = 'Import app';\n    //     call.url = 'http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-App-Import-App.htm'\n    //     call.request = qlikHDRServer + '/qrs/app/import?keepData=true&name=' + name + '&xrfkey=' + senseConfig.xrfkey; //using header auth.\n    //     call.response = HTTP.post(call.request, {\n    //         headers: {\n    //             'hdr-usr': senseConfig.headerValue,\n    //             'X-Qlik-xrfkey': senseConfig.xrfkey\n    //         },\n    //         data: '\"Sales.qvf\"'\n    //     });\n\n    //     REST_Log(call, generationUserId);\n    //     var newGuid = call.response.data.id;\n    //     return newGuid;\n    // } catch (err) {\n    //     console.error(err);\n    //     const call = {};\n    //     call.action = 'Import app FAILED';\n    //     call.response = err.message;\n    //     REST_Log(call, generationUserId);\n    //     throw new Meteor.Error('Import app failed', err.message);\n    // }\n};\n\n//https://www.npmjs.com/package/request#forms\n// function uploadApp(filePath, fileSize, appName) {\n//     console.log('QRS Functions upload App, with name ' + appName + ', with fileSize: ', fileSize + ' and filePath ' + filePath);\n//     var formData = {\n//         my_file: fs.createReadStream(filePath)\n//     };\n//     request.post({\n//         url: qlikHDRServer + '/qrs/app/upload?name=' + appName + '&xrfkey=' + senseConfig.xrfkey,\n//         headers: {\n//             'Content-Type': 'application/vnd.qlik.sense.app',\n//             'hdr-usr': senseConfig.headerValue,\n//             'X-Qlik-xrfkey': senseConfig.xrfkey\n//         },\n//         formData: formData\n//     }, function optionalCallback(err, httpResponse, body) {\n//         if (err) {\n//             return console.error('upload failed:', err);\n//         }\n//         console.log('Upload successful!  Server responded with:', body);\n//     });\n// }"]},"sourceType":"script","hash":"6635fb51e247fd2ae4b37468e2726759d8fbefd1"}
