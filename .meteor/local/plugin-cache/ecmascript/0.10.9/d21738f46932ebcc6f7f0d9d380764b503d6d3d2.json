{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/ddp-client/test/livedata_connection_tests.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/ddp-client/test/livedata_connection_tests.js","filename":"packages/ddp-client/test/livedata_connection_tests.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","generatorOpts":{"filename":"packages/ddp-client/test/livedata_connection_tests.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-client/test/livedata_connection_tests.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar lolex;\nmodule.watch(require(\"lolex\"), {\n  \"default\": function (v) {\n    lolex = v;\n  }\n}, 0);\nvar DDP;\nmodule.watch(require(\"../common/namespace.js\"), {\n  DDP: function (v) {\n    DDP = v;\n  }\n}, 1);\nvar Connection;\nmodule.watch(require(\"../common/livedata_connection.js\"), {\n  Connection: function (v) {\n    Connection = v;\n  }\n}, 2);\n\nvar newConnection = function (stream, options) {\n  // Some of these tests leave outstanding methods with no result yet\n  // returned. This should not block us from re-running tests when sources\n  // change.\n  return new Connection(stream, _.extend({\n    reloadWithOutstanding: true,\n    bufferedWritesInterval: 0\n  }, options));\n};\n\nvar makeConnectMessage = function (session) {\n  var msg = {\n    msg: 'connect',\n    version: DDPCommon.SUPPORTED_DDP_VERSIONS[0],\n    support: DDPCommon.SUPPORTED_DDP_VERSIONS\n  };\n  if (session) msg.session = session;\n  return msg;\n}; // Tests that stream got a message that matches expected.\n// Expected is normally an object, and allows a wildcard value of '*',\n// which will then match any value.\n// Returns the message (parsed as a JSON object if expected is an object);\n// which is particularly handy if you want to extract a value that was\n// matched as a wildcard.\n\n\nvar testGotMessage = function (test, stream, expected) {\n  if (stream.sent.length === 0) {\n    test.fail({\n      error: 'no message received',\n      expected: expected\n    });\n    return undefined;\n  }\n\n  var got = stream.sent.shift();\n  if (typeof got === 'string' && (0, _typeof2.default)(expected) === 'object') got = JSON.parse(got); // An expected value of '*' matches any value, and the matching value (or\n  // array of matching values, if there are multiple) is returned from this\n  // function.\n\n  if ((0, _typeof2.default)(expected) === 'object') {\n    var keysWithStarValues = [];\n\n    _.each(expected, function (v, k) {\n      if (v === '*') keysWithStarValues.push(k);\n    });\n\n    _.each(keysWithStarValues, function (k) {\n      expected[k] = got[k];\n    });\n  }\n\n  test.equal(got, expected);\n  return got;\n};\n\nvar startAndConnect = function (test, stream) {\n  stream.reset(); // initial connection start.\n\n  testGotMessage(test, stream, makeConnectMessage());\n  test.length(stream.sent, 0);\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID\n  });\n  test.length(stream.sent, 0);\n};\n\nvar SESSION_ID = '17';\nTinytest.add('livedata stub - receive data', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // data comes in for unknown collection.\n\n  var coll_name = Random.id();\n  stream.receive({\n    msg: 'added',\n    collection: coll_name,\n    id: '1234',\n    fields: {\n      a: 1\n    }\n  }); // break throught the black box and test internal state\n\n  test.length(conn._updatesForUnknownStores[coll_name], 1); // XXX: Test that the old signature of passing manager directly instead of in\n  // options works.\n\n  var coll = new Mongo.Collection(coll_name, conn); // queue has been emptied and doc is in db.\n\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n  test.equal(coll.find({}).fetch(), [{\n    _id: '1234',\n    a: 1\n  }]); // second message. applied directly to the db.\n\n  stream.receive({\n    msg: 'changed',\n    collection: coll_name,\n    id: '1234',\n    fields: {\n      a: 2\n    }\n  });\n  test.equal(coll.find({}).fetch(), [{\n    _id: '1234',\n    a: 2\n  }]);\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n});\nTinytest.add('livedata stub - buffering data', function (test) {\n  // Install special setTimeout that allows tick-by-tick control in tests using sinonjs 'lolex'\n  // This needs to be before the connection is instantiated.\n  var clock = lolex.install();\n\n  var tick = function (timeout) {\n    return clock.tick(timeout);\n  };\n\n  var stream = new StubStream();\n  var conn = newConnection(stream, {\n    bufferedWritesInterval: 10,\n    bufferedWritesMaxAge: 40\n  });\n  startAndConnect(test, stream);\n  var coll_name = Random.id();\n  var coll = new Mongo.Collection(coll_name, conn);\n\n  var testDocCount = function (count) {\n    return test.equal(coll.find({}).count(), count);\n  };\n\n  var addDoc = function () {\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: Random.id(),\n      fields: {}\n    });\n  }; // Starting at 0 ticks.  At this point we haven't advanced the fake clock at all.\n\n\n  addDoc(); // 1st Doc\n\n  testDocCount(0); // No doc been recognized yet because it's buffered, waiting for more.\n\n  tick(6); // 6 total ticks\n\n  testDocCount(0); // Ensure that the doc still hasn't shown up, despite the clock moving forward.\n\n  tick(4); // 10 total ticks, 1st buffer interval\n\n  testDocCount(1); // No other docs have arrived, so we 'see' the 1st doc.\n\n  addDoc(); // 2nd doc\n\n  tick(1); // 11 total ticks (1 since last flush)\n\n  testDocCount(1); // Again, second doc hasn't arrived because we're waiting for more...\n\n  tick(9); // 20 total ticks (10 ticks since last flush & the 2nd 10-tick interval)\n\n  testDocCount(2); // Now we're here and got the second document.\n  // Add several docs, frequently enough that we buffer multiple times before the next flush.\n\n  addDoc(); // 3 docs\n\n  tick(6); // 26 ticks (6 since last flush)\n\n  addDoc(); // 4 docs\n\n  tick(6); // 32 ticks (12 since last flush)\n\n  addDoc(); // 5 docs\n\n  tick(6); // 38 ticks (18 since last flush)\n\n  addDoc(); // 6 docs\n\n  tick(6); // 44 ticks (24 since last flush)\n\n  addDoc(); // 7 docs\n\n  tick(9); // 53 ticks (33 since last flush)\n\n  addDoc(); // 8 docs\n\n  tick(9); // 62 ticks! (42 ticks since last flush, over max-age - next interval triggers flush)\n\n  testDocCount(2); // Still at 2 from before! (Just making sure)\n\n  tick(1); // Ok, 63 ticks (10 since last doc, so this should cause the flush of all the docs)\n\n  testDocCount(8); // See all the docs.\n  // Put things back how they were.\n\n  clock.uninstall();\n});\nTinytest.add('livedata stub - subscribe', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var callback_fired = false;\n  var sub = conn.subscribe('my_data', function () {\n    callback_fired = true;\n  });\n  test.isFalse(callback_fired);\n  test.length(stream.sent, 1);\n  var message = JSON.parse(stream.sent.shift());\n  var id = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'my_data',\n    params: []\n  });\n  var reactivelyReady = false;\n  var autorunHandle = Tracker.autorun(function () {\n    reactivelyReady = sub.ready();\n  });\n  test.isFalse(reactivelyReady); // get the sub satisfied. callback fires.\n\n  stream.receive({\n    msg: 'ready',\n    subs: [id]\n  });\n  test.isTrue(callback_fired);\n  Tracker.flush();\n  test.isTrue(reactivelyReady); // Unsubscribe.\n\n  sub.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: id\n  });\n  Tracker.flush();\n  test.isFalse(reactivelyReady); // Resubscribe.\n\n  conn.subscribe('my_data');\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  var id2 = message.id;\n  test.notEqual(id, id2);\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'my_data',\n    params: []\n  });\n});\nTinytest.add('livedata stub - reactive subscribe', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var rFoo = new ReactiveVar('foo1');\n  var rBar = new ReactiveVar('bar1');\n  var onReadyCount = {};\n\n  var onReady = function (tag) {\n    return function () {\n      if (_.has(onReadyCount, tag)) ++onReadyCount[tag];else onReadyCount[tag] = 1;\n    };\n  }; // Subscribe to some subs.\n\n\n  var stopperHandle, completerHandle;\n  var autorunHandle = Tracker.autorun(function () {\n    conn.subscribe('foo', rFoo.get(), onReady(rFoo.get()));\n    conn.subscribe('bar', rBar.get(), onReady(rBar.get()));\n    completerHandle = conn.subscribe('completer', onReady('completer'));\n    stopperHandle = conn.subscribe('stopper', onReady('stopper'));\n  });\n  var completerReady;\n  var readyAutorunHandle = Tracker.autorun(function () {\n    completerReady = completerHandle.ready();\n  }); // Check sub messages. (Assume they are sent in the order executed.)\n\n  test.length(stream.sent, 4);\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo1']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idBar1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'bar',\n    params: ['bar1']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idCompleter = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'completer',\n    params: []\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idStopper = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'stopper',\n    params: []\n  }); // Haven't hit onReady yet.\n\n  test.equal(onReadyCount, {});\n  Tracker.flush();\n  test.isFalse(completerReady); // \"completer\" gets ready now. its callback should fire.\n\n  stream.receive({\n    msg: 'ready',\n    subs: [idCompleter]\n  });\n  test.equal(onReadyCount, {\n    completer: 1\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(completerReady); // Stop 'stopper'.\n\n  stopperHandle.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idStopper\n  });\n  test.equal(onReadyCount, {\n    completer: 1\n  });\n  Tracker.flush();\n  test.isTrue(completerReady); // Change the foo subscription and flush. We should sub to the new foo\n  // subscription, re-sub to the stopper subscription, and then unsub from the old\n  // foo subscription. The bar subscription should be unaffected. The completer\n  // subscription should call its new onReady callback, because we always\n  // call onReady for a given reactively-saved subscription.\n  // The completerHandle should have been reestablished to the ready handle.\n\n  rFoo.set('foo2');\n  Tracker.flush();\n  test.length(stream.sent, 3);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo2']\n  });\n  message = JSON.parse(stream.sent.shift());\n  var idStopperAgain = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'stopper',\n    params: []\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo1\n  });\n  test.equal(onReadyCount, {\n    completer: 2\n  });\n  test.isTrue(completerReady); // Ready the stopper and bar subs. Completing stopper should call only the\n  // onReady from the new subscription because they were separate subscriptions\n  // started at different times and the first one was explicitly torn down by\n  // the client; completing bar should call the onReady from the new\n  // subscription because we always call onReady for a given reactively-saved\n  // subscription.\n\n  stream.receive({\n    msg: 'ready',\n    subs: [idStopperAgain, idBar1]\n  });\n  test.equal(onReadyCount, {\n    completer: 2,\n    bar1: 1,\n    stopper: 1\n  }); // Shut down the autorun. This should unsub us from all current subs at flush\n  // time.\n\n  autorunHandle.stop();\n  Tracker.flush();\n  test.isFalse(completerReady);\n  readyAutorunHandle.stop();\n  test.length(stream.sent, 4); // The order of unsubs here is not important.\n\n  var unsubMessages = _.map(stream.sent, JSON.parse);\n\n  stream.sent.length = 0;\n  test.equal(_.unique(_.pluck(unsubMessages, 'msg')), ['unsub']);\n\n  var actualIds = _.pluck(unsubMessages, 'id');\n\n  var expectedIds = [idFoo2, idBar1, idCompleter, idStopperAgain];\n  actualIds.sort();\n  expectedIds.sort();\n  test.equal(actualIds, expectedIds);\n});\nTinytest.add('livedata stub - reactive subscribe handle correct', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var rFoo = new ReactiveVar('foo1'); // Subscribe to some subs.\n\n  var fooHandle, fooReady;\n  var autorunHandle = Tracker.autorun(function () {\n    fooHandle = conn.subscribe('foo', rFoo.get());\n    Tracker.autorun(function () {\n      fooReady = fooHandle.ready();\n    });\n  });\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo1']\n  }); // Not ready yet\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, reading the new false value, and\n  // setting up a new dep which goes true soon\n\n  rFoo.set('foo2');\n  Tracker.flush();\n  test.length(stream.sent, 2);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo2']\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo1\n  });\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // \"foo\" gets ready now. The handle should be ready and the autorun rerun\n\n  stream.receive({\n    msg: 'ready',\n    subs: [idFoo2]\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady); // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, making fooReady false too\n\n  rFoo.set('foo3');\n  Tracker.flush();\n  test.length(stream.sent, 2);\n  message = JSON.parse(stream.sent.shift());\n  var idFoo3 = message.id;\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo',\n    params: ['foo3']\n  });\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, {\n    msg: 'unsub',\n    id: idFoo2\n  });\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady); // \"foo\" gets ready again\n\n  stream.receive({\n    msg: 'ready',\n    subs: [idFoo3]\n  });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n  autorunHandle.stop();\n});\nTinytest.add('livedata stub - this', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  conn.methods({\n    test_this: function () {\n      test.isTrue(this.isSimulation);\n      this.unblock(); // should be a no-op\n    }\n  }); // should throw no exceptions\n\n  conn.call('test_this', _.identity); // satisfy method, quiesce connection\n\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'test_this',\n    params: [],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n  stream.receive({\n    msg: 'result',\n    id: message.id,\n    result: null\n  });\n  stream.receive({\n    msg: 'updated',\n    methods: [message.id]\n  });\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - methods', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    }); // setup method\n\n    conn.methods({\n      do_something: function (x) {\n        coll.insert({\n          value: x\n        });\n      }\n    }); // setup observers\n\n    var counts = {\n      added: 0,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    };\n    var handle = coll.find({}).observe({\n      addedAt: function () {\n        counts.added += 1;\n      },\n      removedAt: function () {\n        counts.removed += 1;\n      },\n      changedAt: function () {\n        counts.changed += 1;\n      },\n      movedTo: function () {\n        counts.moved += 1;\n      }\n    }); // call method with results callback\n\n    var callback1Fired = false;\n    conn.call('do_something', 'friday!', function (err, res) {\n      test.isUndefined(err);\n      test.equal(res, '1234');\n      callback1Fired = true;\n    });\n    test.isFalse(callback1Fired); // observers saw the method run.\n\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // get response from server\n\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: ['friday!'],\n      id: '*',\n      randomSeed: '*'\n    });\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n\n    var docId = coll.findOne({\n      value: 'friday!'\n    })._id; // results does not yet result in callback, because data is not\n    // ready.\n\n\n    stream.receive({\n      msg: 'result',\n      id: message.id,\n      result: '1234'\n    });\n    test.isFalse(callback1Fired); // result message doesn't affect data\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // data methods do not show up (not quiescent yet)\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(docId),\n      fields: {\n        value: 'tuesday'\n      }\n    });\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'friday!'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 0,\n      moved: 0\n    }); // send another methods (unknown on client)\n\n    var callback2Fired = false;\n    conn.call('do_something_else', 'monday', function (err, res) {\n      callback2Fired = true;\n    });\n    test.isFalse(callback1Fired);\n    test.isFalse(callback2Fired); // test we still send a method request to server\n\n    var message2 = JSON.parse(stream.sent.shift());\n    test.isUndefined(message2.randomSeed);\n    test.equal(message2, {\n      msg: 'method',\n      method: 'do_something_else',\n      params: ['monday'],\n      id: message2.id\n    }); // get the first data satisfied message. changes are applied to database even\n    // though another method is outstanding, because the other method didn't have\n    // a stub. and its callback is called.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [message.id]\n    });\n    test.isTrue(callback1Fired);\n    test.isFalse(callback2Fired);\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'tuesday'\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 1,\n      moved: 0\n    }); // second result\n\n    stream.receive({\n      msg: 'result',\n      id: message2.id,\n      result: 'bupkis'\n    });\n    test.isFalse(callback2Fired); // get second satisfied; no new changes are applied.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [message2.id]\n    });\n    test.isTrue(callback2Fired);\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({\n      value: 'tuesday',\n      _id: docId\n    }).count(), 1);\n    test.equal(counts, {\n      added: 1,\n      removed: 0,\n      changed: 1,\n      moved: 0\n    });\n    handle.stop();\n  });\n}\n\nTinytest.add('livedata stub - mutating method args', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  conn.methods({\n    mutateArgs: function (arg) {\n      arg.foo = 42;\n    }\n  });\n  conn.call('mutateArgs', {\n    foo: 50\n  }, _.identity); // Method should be called with original arg, not mutated arg.\n\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'mutateArgs',\n    params: [{\n      foo: 50\n    }],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n});\n\nvar observeCursor = function (test, cursor) {\n  var counts = {\n    added: 0,\n    removed: 0,\n    changed: 0,\n    moved: 0\n  };\n\n  var expectedCounts = _.clone(counts);\n\n  var handle = cursor.observe({\n    addedAt: function () {\n      counts.added += 1;\n    },\n    removedAt: function () {\n      counts.removed += 1;\n    },\n    changedAt: function () {\n      counts.changed += 1;\n    },\n    movedTo: function () {\n      counts.moved += 1;\n    }\n  });\n  return {\n    stop: _.bind(handle.stop, handle),\n    expectCallbacks: function (delta) {\n      _.each(delta, function (mod, field) {\n        expectedCounts[field] += mod;\n      });\n\n      test.equal(counts, expectedCounts);\n    }\n  };\n}; // method calls another method in simulation. see not sent.\n\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - methods calling methods', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var coll_name = Random.id();\n    var coll = new Mongo.Collection(coll_name, {\n      connection: conn\n    }); // setup methods\n\n    conn.methods({\n      do_something: function () {\n        conn.call('do_something_else');\n      },\n      do_something_else: function () {\n        coll.insert({\n          a: 1\n        });\n      }\n    });\n    var o = observeCursor(test, coll.find()); // call method.\n\n    conn.call('do_something', _.identity); // see we only send message for outer methods\n\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    });\n    test.length(stream.sent, 0); // but inner method runs locally.\n\n    o.expectCallbacks({\n      added: 1\n    });\n    test.equal(coll.find().count(), 1);\n\n    var docId = coll.findOne()._id;\n\n    test.equal(coll.findOne(), {\n      _id: docId,\n      a: 1\n    }); // we get the results\n\n    stream.receive({\n      msg: 'result',\n      id: message.id,\n      result: '1234'\n    }); // get data from the method. data from this doc does not show up yet, but data\n    // from another doc does.\n\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: MongoID.idStringify(docId),\n      fields: {\n        value: 'tuesday'\n      }\n    });\n    o.expectCallbacks();\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      a: 1\n    });\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: 'monkey',\n      fields: {\n        value: 'bla'\n      }\n    });\n    o.expectCallbacks({\n      added: 1\n    });\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      a: 1\n    });\n    var newDoc = coll.findOne({\n      value: 'bla'\n    });\n    test.isTrue(newDoc);\n    test.equal(newDoc, {\n      _id: newDoc._id,\n      value: 'bla'\n    }); // get method satisfied. all data shows up. the 'a' field is reverted and\n    // 'value' field is set.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [message.id]\n    });\n    o.expectCallbacks({\n      changed: 1\n    });\n    test.equal(coll.findOne(docId), {\n      _id: docId,\n      value: 'tuesday'\n    });\n    test.equal(coll.findOne(newDoc._id), {\n      _id: newDoc._id,\n      value: 'bla'\n    });\n    o.stop();\n  });\n}\n\nTinytest.add('livedata stub - method call before connect', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  var callbackOutput = [];\n  conn.call('someMethod', function (err, result) {\n    callbackOutput.push(result);\n  });\n  test.equal(callbackOutput, []); // the real stream drops all output pre-connection\n\n  stream.sent.length = 0; // Now connect.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage());\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'someMethod',\n    params: [],\n    id: '*'\n  });\n});\nTinytest.add('livedata stub - reconnect', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  });\n  var o = observeCursor(test, coll.find()); // subscribe\n\n  var subCallbackFired = false;\n  var sub = conn.subscribe('my_data', function () {\n    subCallbackFired = true;\n  });\n  test.isFalse(subCallbackFired);\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'my_data',\n    params: [],\n    id: subMessage.id\n  }); // get some data. it shows up.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: {\n      a: 1\n    }\n  });\n  test.equal(coll.find({}).count(), 1);\n  o.expectCallbacks({\n    added: 1\n  });\n  test.isFalse(subCallbackFired);\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: {\n      b: 2\n    }\n  });\n  stream.receive({\n    msg: 'ready',\n    subs: [subMessage.id] // satisfy sub\n\n  });\n  test.isTrue(subCallbackFired);\n  subCallbackFired = false; // re-arm for test that it doesn't fire again.\n\n  test.equal(coll.find({\n    a: 1,\n    b: 2\n  }).count(), 1);\n  o.expectCallbacks({\n    changed: 1\n  }); // call method.\n\n  var methodCallbackFired = false;\n  conn.call('do_something', function () {\n    methodCallbackFired = true;\n  });\n  conn.apply('do_something_else', [], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something_later', [], _.identity);\n  test.isFalse(methodCallbackFired); // The non-wait method should send, but not the wait method.\n\n  var methodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(methodMessage.randomSeed);\n  test.equal(methodMessage, {\n    msg: 'method',\n    method: 'do_something',\n    params: [],\n    id: methodMessage.id\n  });\n  test.equal(stream.sent.length, 0); // more data. shows up immediately because there was no relevant method stub.\n\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: {\n      c: 3\n    }\n  });\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  o.expectCallbacks({\n    changed: 1\n  }); // stream reset. reconnect!  we send a connect, our pending method, and our\n  // sub. The wait method still is blocked.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, methodMessage);\n  testGotMessage(test, stream, subMessage); // reconnect with different session id\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  }); // resend data. doesn't show up: we're in reconnect quiescence.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4\n    }\n  });\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '2345',\n    fields: {\n      e: 5\n    }\n  });\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks(); // satisfy and return the method\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodMessage.id]\n  });\n  test.isFalse(methodCallbackFired);\n  stream.receive({\n    msg: 'result',\n    id: methodMessage.id,\n    result: 'bupkis'\n  }); // The callback still doesn't fire (and we don't send the wait method): we're\n  // still in global quiescence\n\n  test.isFalse(methodCallbackFired);\n  test.equal(stream.sent.length, 0); // still no update.\n\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3\n  });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks(); // re-satisfy sub\n\n  stream.receive({\n    msg: 'ready',\n    subs: [subMessage.id]\n  }); // now the doc changes and method callback is called, and the wait method is\n  // sent. the sub callback isn't re-called.\n\n  test.isTrue(methodCallbackFired);\n  test.isFalse(subCallbackFired);\n  test.equal(coll.findOne('1234'), {\n    _id: '1234',\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4\n  });\n  test.equal(coll.findOne('2345'), {\n    _id: '2345',\n    e: 5\n  });\n  o.expectCallbacks({\n    added: 1,\n    changed: 1\n  });\n  var waitMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(waitMethodMessage.randomSeed);\n  test.equal(waitMethodMessage, {\n    msg: 'method',\n    method: 'do_something_else',\n    params: [],\n    id: waitMethodMessage.id\n  });\n  test.equal(stream.sent.length, 0);\n  stream.receive({\n    msg: 'result',\n    id: waitMethodMessage.id,\n    result: 'bupkis'\n  });\n  test.equal(stream.sent.length, 0);\n  stream.receive({\n    msg: 'updated',\n    methods: [waitMethodMessage.id]\n  }); // wait method done means we can send the third method\n\n  test.equal(stream.sent.length, 1);\n  var laterMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(laterMethodMessage.randomSeed);\n  test.equal(laterMethodMessage, {\n    msg: 'method',\n    method: 'do_something_later',\n    params: [],\n    id: laterMethodMessage.id\n  });\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - reconnect non-idempotent method', function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/6108\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var firstMethodCallbackFired = false;\n    var firstMethodCallbackErrored = false;\n    var secondMethodCallbackFired = false;\n    var secondMethodCallbackErrored = false; // call with noRetry true so that the method should fail to retry on reconnect.\n\n    conn.apply('do_something', [], {\n      noRetry: true\n    }, function (error) {\n      firstMethodCallbackFired = true; // failure on reconnect should trigger an error.\n\n      if (error && error.error === 'invocation-failed') {\n        firstMethodCallbackErrored = true;\n      }\n    });\n    conn.apply('do_something_else', [], {\n      noRetry: true\n    }, function (error) {\n      secondMethodCallbackFired = true; // failure on reconnect should trigger an error.\n\n      if (error && error.error === 'invocation-failed') {\n        secondMethodCallbackErrored = true;\n      }\n    }); // The method has not succeeded yet\n\n    test.isFalse(firstMethodCallbackFired);\n    test.isFalse(secondMethodCallbackFired); // send the methods\n\n    stream.sent.shift();\n    stream.sent.shift(); // reconnect\n\n    stream.reset(); // verify that a reconnect message was sent.\n\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // Make sure that the stream triggers connection.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    }); //The method callback should fire even though the stream has not sent a response.\n    //the callback should have been fired with an error.\n\n    test.isTrue(firstMethodCallbackFired);\n    test.isTrue(firstMethodCallbackErrored);\n    test.isTrue(secondMethodCallbackFired);\n    test.isTrue(secondMethodCallbackErrored); // verify that the method message was not sent.\n\n    test.isUndefined(stream.sent.shift());\n  });\n}\n\nfunction addReconnectTests(name, testFunc) {\n  Tinytest.add(name + ' (deprecated)', function (test) {\n    function deprecatedSetOnReconnect(conn, handler) {\n      conn.onReconnect = handler;\n    }\n\n    testFunc.call(this, test, deprecatedSetOnReconnect);\n  });\n  Tinytest.add(name, function (test) {\n    var stopper;\n\n    function setOnReconnect(conn, handler) {\n      stopper && stopper.stop();\n      stopper = DDP.onReconnect(function (reconnectingConn) {\n        if (reconnectingConn === conn) {\n          handler();\n        }\n      });\n    }\n\n    testFunc.call(this, test, setOnReconnect);\n    stopper && stopper.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  addReconnectTests('livedata stub - reconnect method which only got result', function (test, setOnReconnect) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    var o = observeCursor(test, coll.find());\n    conn.methods({\n      writeSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      }\n    });\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 0); // Call a method. We'll get the result but not data-done before reconnect.\n\n    var callbackOutput = [];\n    var onResultReceivedOutput = [];\n    conn.apply('writeSomething', [], {\n      onResultReceived: function (err, result) {\n        onResultReceivedOutput.push(result);\n      }\n    }, function (err, result) {\n      callbackOutput.push(result);\n    }); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Callback not called.\n\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, []); // Method sent.\n\n    var methodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'writeSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 42\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Get the result.\n\n    stream.receive({\n      msg: 'result',\n      id: methodId,\n      result: 'bla'\n    }); // Data unaffected.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Callback not called, but onResultReceived is.\n\n    test.equal(callbackOutput, []);\n    test.equal(onResultReceivedOutput, ['bla']); // Reset stream. Method does NOT get resent, because its result is already\n    // in. Reconnect quiescence happens as soon as 'connected' is received because\n    // there are no pending methods or subs in need of revival.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // Still holding out hope for session resumption, so nothing updated yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, []); // Receive 'connected': time for reconnect quiescence! Data gets updated\n    // locally (ie, data is reset) and callback gets called.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    });\n    test.equal(coll.find().count(), 0);\n    o.expectCallbacks({\n      removed: 1\n    });\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']);\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 42\n      }\n    });\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      baz: 42\n    });\n    o.expectCallbacks({\n      added: 1\n    }); // Run method again. We're going to do the same thing this time, except we're\n    // also going to use an onReconnect to insert another method at reconnect\n    // time, which will delay reconnect quiescence.\n\n    conn.apply('writeSomething', [], {\n      onResultReceived: function (err, result) {\n        onResultReceivedOutput.push(result);\n      }\n    }, function (err, result) {\n      callbackOutput.push(result);\n    }); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId2 = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Callback not called.\n\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla']); // Method sent.\n\n    var methodId2 = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'writeSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId2),\n      fields: {\n        baz: 42\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Get the result.\n\n    stream.receive({\n      msg: 'result',\n      id: methodId2,\n      result: 'blab'\n    }); // Data unaffected.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks(); // Callback not called, but onResultReceived is.\n\n    test.equal(callbackOutput, ['bla']);\n    test.equal(onResultReceivedOutput, ['bla', 'blab']);\n    setOnReconnect(conn, function () {\n      conn.call('slowMethod', function (err, result) {\n        callbackOutput.push(result);\n      });\n    }); // Reset stream. Method does NOT get resent, because its result is already in,\n    // but slowMethod gets called via onReconnect. Reconnect quiescence is now\n    // blocking on slowMethod.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID + 1));\n    var slowMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'slowMethod',\n      params: [],\n      id: '*'\n    }).id; // Still holding out hope for session resumption, so nothing updated yet.\n\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']); // Receive 'connected'... but no reconnect quiescence yet due to slowMethod.\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 2\n    });\n    test.equal(coll.find().count(), 2);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla']); // Receive data matching our stub. It doesn't take effect yet.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId2),\n      fields: {\n        foo: 'bar'\n      }\n    });\n    o.expectCallbacks(); // slowMethod is done writing, so we get full reconnect quiescence (but no\n    // slowMethod callback)... ie, a reset followed by applying the data we just\n    // got, as well as calling the callback from the method that half-finished\n    // before reset. The net effect is deleting doc 'stubWrittenId'.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [slowMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId2), {\n      _id: stubWrittenId2,\n      foo: 'bar'\n    });\n    o.expectCallbacks({\n      removed: 1\n    });\n    test.equal(callbackOutput, ['bla', 'blab']); // slowMethod returns a value now.\n\n    stream.receive({\n      msg: 'result',\n      id: slowMethodId,\n      result: 'slow'\n    });\n    o.expectCallbacks();\n    test.equal(callbackOutput, ['bla', 'blab', 'slow']);\n    o.stop();\n  });\n}\n\nTinytest.add('livedata stub - reconnect method which only got data', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  });\n  var o = observeCursor(test, coll.find()); // Call a method. We'll get the data-done message but not the result before\n  // reconnect.\n\n  var callbackOutput = [];\n  var onResultReceivedOutput = [];\n  conn.apply('doLittle', [], {\n    onResultReceived: function (err, result) {\n      onResultReceivedOutput.push(result);\n    }\n  }, function (err, result) {\n    callbackOutput.push(result);\n  }); // Callbacks not called.\n\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Method sent.\n\n  var methodId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0); // Get some data.\n\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'photo',\n    fields: {\n      baz: 42\n    }\n  }); // It shows up instantly because the stub didn't write anything.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks({\n    added: 1\n  }); // Get the data-done message.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodId]\n  }); // Data still here.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks(); // Method callback not called yet (no result yet).\n\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Reset stream. Method gets resent (with same ID), and blocks reconnect\n  // quiescence.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: methodId\n  }); // Still holding out hope for session resumption, so nothing updated yet.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Receive 'connected'. Still blocking on reconnect quiescence.\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), {\n    _id: 'photo',\n    baz: 42\n  });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []); // Receive method result. onResultReceived is called but the main callback\n  // isn't (ie, we don't get confused by the fact that we got data-done the\n  // *FIRST* time through).\n\n  stream.receive({\n    msg: 'result',\n    id: methodId,\n    result: 'res'\n  });\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, ['res']); // Now we get data-done. Collection is reset and callback is called.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [methodId]\n  });\n  test.equal(coll.find().count(), 0);\n  o.expectCallbacks({\n    removed: 1\n  });\n  test.equal(callbackOutput, ['res']);\n  test.equal(onResultReceivedOutput, ['res']);\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - multiple stubs same doc', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    var o = observeCursor(test, coll.find());\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      },\n      updateIt: function (id) {\n        coll.update(id, {\n          $set: {\n            baz: 42\n          }\n        });\n      }\n    });\n    test.equal(coll.find().count(), 0); // Call the insert method.\n\n    conn.call('insertSomething', _.identity); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id;\n\n    o.expectCallbacks({\n      added: 1\n    }); // Method sent.\n\n    var insertMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'insertSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Call update method.\n\n    conn.call('updateIt', stubWrittenId, _.identity); // This stub write is visible too.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks({\n      changed: 1\n    }); // Method sent.\n\n    var updateMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'updateIt',\n      params: [stubWrittenId],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // Get some data... slightly different than what we wrote.\n\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        foo: 'barb',\n        other: 'field',\n        other2: 'bla'\n      }\n    }); // It doesn't show up yet.\n\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // And get the first method-done. Still no updates to minimongo: we can't\n    // quiesce the doc until the second method is done.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [insertMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // More data. Not quite what we wrote. Also ignored for now.\n\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        baz: 43\n      },\n      cleared: ['other']\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks(); // Second data-ready. Now everything takes effect!\n\n    stream.receive({\n      msg: 'updated',\n      methods: [updateMethodId]\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'barb',\n      other2: 'bla',\n      baz: 43\n    });\n    o.expectCallbacks({\n      changed: 1\n    });\n    o.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\"livedata stub - unsent methods don't block quiescence\", function (test) {\n    // This test is for https://github.com/meteor/meteor/issues/555\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      insertSomething: function () {\n        // stub write\n        coll.insert({\n          foo: 'bar'\n        });\n      }\n    });\n    test.equal(coll.find().count(), 0); // Call a random method (no-op)\n\n    conn.call('no-op', _.identity); // Call a wait method\n\n    conn.apply('no-op', [], {\n      wait: true\n    }, _.identity); // Call a method with a stub that writes.\n\n    conn.call('insertSomething', _.identity); // Stub write is visible.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 1);\n\n    var stubWrittenId = coll.findOne({\n      foo: 'bar'\n    })._id; // first method sent\n\n\n    var firstMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'no-op',\n      params: [],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the first method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [firstMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: firstMethodId\n    }); // Wait method sent.\n\n    var waitMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'no-op',\n      params: [],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the wait method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [waitMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: waitMethodId\n    }); // insert method sent.\n\n    var insertMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'insertSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0); // ack the insert method\n\n    stream.receive({\n      msg: 'updated',\n      methods: [insertMethodId]\n    });\n    stream.receive({\n      msg: 'result',\n      id: insertMethodId\n    }); // simulation reverted.\n\n    test.equal(coll.find({\n      foo: 'bar'\n    }).count(), 0);\n  });\n}\n\nTinytest.add('livedata stub - reactive resub', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var readiedSubs = {};\n\n  var markAllReady = function () {\n    // synthesize a \"ready\" message in response to any \"sub\"\n    // message with an id we haven't seen before\n    _.each(stream.sent, function (msg) {\n      msg = JSON.parse(msg);\n\n      if (msg.msg === 'sub' && !_.has(readiedSubs, msg.id)) {\n        stream.receive({\n          msg: 'ready',\n          subs: [msg.id]\n        });\n        readiedSubs[msg.id] = true;\n      }\n    });\n  };\n\n  var fooArg = new ReactiveVar('A');\n  var fooReady = 0;\n  var inner;\n  var outer = Tracker.autorun(function () {\n    inner = Tracker.autorun(function () {\n      conn.subscribe('foo-sub', fooArg.get(), function () {\n        fooReady++;\n      });\n    });\n  });\n  markAllReady();\n  var message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['A']\n  });\n  test.equal(fooReady, 1); // Rerun the inner autorun with different subscription\n  // arguments.\n\n  fooArg.set('B');\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['B']\n  });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'unsub'\n  });\n  test.equal(fooReady, 2); // Rerun inner again with same args; should be no re-sub.\n\n  inner.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 3); // Rerun outer!  Should still be no re-sub even though\n  // the inner computation is stopped and a new one is\n  // started.\n\n  outer.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 4); // Change the subscription.  Now we should get an onReady.\n\n  fooArg.set('C');\n  Tracker.flush();\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'sub',\n    name: 'foo-sub',\n    params: ['C']\n  });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, {\n    msg: 'unsub'\n  });\n  test.equal(fooReady, 5);\n});\nTinytest.add('livedata connection - reactive userId', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  test.equal(conn.userId(), null);\n  conn.setUserId(1337);\n  test.equal(conn.userId(), 1337);\n});\nTinytest.add('livedata connection - two wait methods', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, {\n    connection: conn\n  }); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  var responses = [];\n  conn.apply('do_something', ['one!'], function () {\n    responses.push('one');\n  });\n  var one_message = JSON.parse(stream.sent.shift());\n  test.equal(one_message.params, ['one!']);\n  conn.apply('do_something', ['two!'], {\n    wait: true\n  }, function () {\n    responses.push('two');\n  }); // 'two!' isn't sent yet, because it's a wait method.\n\n  test.equal(stream.sent.length, 0);\n  conn.apply('do_something', ['three!'], function () {\n    responses.push('three');\n  });\n  conn.apply('do_something', ['four!'], function () {\n    responses.push('four');\n  });\n  conn.apply('do_something', ['five!'], {\n    wait: true\n  }, function () {\n    responses.push('five');\n  });\n  conn.apply('do_something', ['six!'], function () {\n    responses.push('six');\n  }); // Verify that we did not send any more methods since we are still waiting on\n  // 'one!'.\n\n  test.equal(stream.sent.length, 0); // Receive some data. \"one\" is not a wait method and there are no stubs, so it\n  // gets applied immediately.\n\n  test.equal(coll.find().count(), 0);\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'foo',\n    fields: {\n      x: 1\n    }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1\n  }); // Let \"one!\" finish. Both messages are required to fire the callback.\n\n  stream.receive({\n    msg: 'result',\n    id: one_message.id\n  });\n  test.equal(responses, []);\n  stream.receive({\n    msg: 'updated',\n    methods: [one_message.id]\n  });\n  test.equal(responses, ['one']); // Now we've send out \"two!\".\n\n  var two_message = JSON.parse(stream.sent.shift());\n  test.equal(two_message.params, ['two!']); // But still haven't sent \"three!\".\n\n  test.equal(stream.sent.length, 0); // Receive more data. \"two\" is a wait method, so the data doesn't get applied\n  // yet.\n\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: 'foo',\n    fields: {\n      y: 3\n    }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1\n  }); // Let \"two!\" finish, with its end messages in the opposite order to \"one!\".\n\n  stream.receive({\n    msg: 'updated',\n    methods: [two_message.id]\n  });\n  test.equal(responses, ['one']);\n  test.equal(stream.sent.length, 0); // data-done message is enough to allow data to be written.\n\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), {\n    _id: 'foo',\n    x: 1,\n    y: 3\n  });\n  stream.receive({\n    msg: 'result',\n    id: two_message.id\n  });\n  test.equal(responses, ['one', 'two']); // Verify that we just sent \"three!\" and \"four!\" now that we got\n  // responses for \"one!\" and \"two!\"\n\n  test.equal(stream.sent.length, 2);\n  var three_message = JSON.parse(stream.sent.shift());\n  test.equal(three_message.params, ['three!']);\n  var four_message = JSON.parse(stream.sent.shift());\n  test.equal(four_message.params, ['four!']); // Out of order response is OK for non-wait methods.\n\n  stream.receive({\n    msg: 'result',\n    id: three_message.id\n  });\n  stream.receive({\n    msg: 'result',\n    id: four_message.id\n  });\n  stream.receive({\n    msg: 'updated',\n    methods: [four_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four']);\n  test.equal(stream.sent.length, 0); // Let three finish too.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [three_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four', 'three']); // Verify that we just sent \"five!\" (the next wait method).\n\n  test.equal(stream.sent.length, 1);\n  var five_message = JSON.parse(stream.sent.shift());\n  test.equal(five_message.params, ['five!']);\n  test.equal(responses, ['one', 'two', 'four', 'three']); // Let five finish.\n\n  stream.receive({\n    msg: 'result',\n    id: five_message.id\n  });\n  stream.receive({\n    msg: 'updated',\n    methods: [five_message.id]\n  });\n  test.equal(responses, ['one', 'two', 'four', 'three', 'five']);\n  var six_message = JSON.parse(stream.sent.shift());\n  test.equal(six_message.params, ['six!']);\n});\naddReconnectTests('livedata connection - onReconnect prepends messages correctly with a wait method', function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['reconnect zero'], _.identity);\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], {\n      wait: true\n    }, _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['three'], _.identity); // reconnect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n\n  test.equal(_.map(stream.sent, function (msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect zero', 'reconnect one']); // white-box test:\n\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [[false, ['reconnect zero', 'reconnect one']], [true, ['reconnect two']], [false, ['reconnect three', 'one']], [true, ['two']], [false, ['three']]]);\n});\nTinytest.add('livedata connection - ping without id', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  stream.receive({\n    msg: 'ping'\n  });\n  testGotMessage(test, stream, {\n    msg: 'pong'\n  });\n});\nTinytest.add('livedata connection - ping with id', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var id = Random.id();\n  stream.receive({\n    msg: 'ping',\n    id: id\n  });\n  testGotMessage(test, stream, {\n    msg: 'pong',\n    id: id\n  });\n});\n\n_.each(DDPCommon.SUPPORTED_DDP_VERSIONS, function (version) {\n  Tinytest.addAsync('livedata connection - ping from ' + version, function (test, onComplete) {\n    var connection = new Connection(getSelfConnectionUrl(), {\n      reloadWithOutstanding: true,\n      supportedDDPVersions: [version],\n      onDDPVersionNegotiationFailure: function () {\n        test.fail();\n        onComplete();\n      },\n      onConnected: function () {\n        test.equal(connection._version, version); // It's a little naughty to access _stream and _send, but it works...\n\n        connection._stream.on('message', function (json) {\n          var msg = JSON.parse(json);\n          var done = false;\n\n          if (msg.msg === 'pong') {\n            test.notEqual(version, 'pre1');\n            done = true;\n          } else if (msg.msg === 'error') {\n            // Version pre1 does not play ping-pong\n            test.equal(version, 'pre1');\n            done = true;\n          } else {\n            Meteor._debug('Got unexpected message: ' + json);\n          }\n\n          if (done) {\n            connection._stream.disconnect({\n              _permanent: true\n            });\n\n            onComplete();\n          }\n        });\n\n        connection._send({\n          msg: 'ping'\n        });\n      }\n    });\n  });\n});\n\nvar getSelfConnectionUrl = function () {\n  if (Meteor.isClient) {\n    var ddpUrl = Meteor._relativeToSiteRootUrl('/');\n\n    if (typeof __meteor_runtime_config__ !== 'undefined') {\n      if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL) ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n    }\n\n    return ddpUrl;\n  } else {\n    return Meteor.absoluteUrl();\n  }\n};\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    reverse: function (arg) {\n      // Return something notably different from reverse.meteor.com.\n      return arg.split('').reverse().join('') + ' LOCAL';\n    }\n  });\n}\n\ntestAsyncMulti('livedata connection - reconnect to a different server', [function (test, expect) {\n  var self = this;\n  self.conn = DDP.connect('reverse.meteor.com');\n  pollUntil(expect, function () {\n    return self.conn.status().connected;\n  }, 5000, 100, false);\n}, function (test, expect) {\n  var self = this;\n  self.doTest = self.conn.status().connected;\n\n  if (self.doTest) {\n    self.conn.call('reverse', 'foo', expect(function (err, res) {\n      test.equal(res, 'oof');\n    }));\n  }\n}, function (test, expect) {\n  var self = this;\n\n  if (self.doTest) {\n    self.conn.reconnect({\n      url: getSelfConnectionUrl()\n    });\n    self.conn.call('reverse', 'bar', expect(function (err, res) {\n      test.equal(res, 'rab LOCAL');\n    }));\n  }\n}]);\nTinytest.addAsync('livedata connection - version negotiation requires renegotiating', function (test, onComplete) {\n  var connection = new Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: ['garbled', DDPCommon.SUPPORTED_DDP_VERSIONS[0]],\n    onDDPVersionNegotiationFailure: function () {\n      test.fail();\n      onComplete();\n    },\n    onConnected: function () {\n      test.equal(connection._version, DDPCommon.SUPPORTED_DDP_VERSIONS[0]);\n\n      connection._stream.disconnect({\n        _permanent: true\n      });\n\n      onComplete();\n    }\n  });\n});\nTinytest.addAsync('livedata connection - version negotiation error', function (test, onComplete) {\n  var connection = new Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: ['garbled', 'more garbled'],\n    onDDPVersionNegotiationFailure: function () {\n      test.equal(connection.status().status, 'failed');\n      test.matches(connection.status().reason, /DDP version negotiation failed/);\n      test.isFalse(connection.status().connected);\n      onComplete();\n    },\n    onConnected: function () {\n      test.fail();\n      onComplete();\n    }\n  });\n});\naddReconnectTests('livedata connection - onReconnect prepends messages correctly without a wait method', function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['reconnect one'], _.identity);\n    conn.apply('do_something', ['reconnect two'], _.identity);\n    conn.apply('do_something', ['reconnect three'], _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity);\n  conn.apply('do_something', ['two'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['three'], {\n    wait: true\n  }, _.identity);\n  conn.apply('do_something', ['four'], _.identity); // reconnect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent what we expect to send, and we're blocked on\n  // what we expect to be blocked. The subsequent logic to correctly\n  // read the wait flag is tested separately.\n\n  test.equal(_.map(stream.sent, function (msg) {\n    return JSON.parse(msg).params[0];\n  }), ['reconnect one', 'reconnect two', 'reconnect three', 'one']); // white-box test:\n\n  test.equal(_.map(conn._outstandingMethodBlocks, function (block) {\n    return [block.wait, _.map(block.methods, function (method) {\n      return method._message.params[0];\n    })];\n  }), [[false, ['reconnect one', 'reconnect two', 'reconnect three', 'one']], [true, ['two']], [true, ['three']], [false, ['four']]]);\n});\naddReconnectTests('livedata connection - onReconnect with sent messages', function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // setup method\n\n  conn.methods({\n    do_something: function (x) {}\n  });\n  setOnReconnect(conn, function () {\n    conn.apply('do_something', ['login'], {\n      wait: true\n    }, _.identity);\n  });\n  conn.apply('do_something', ['one'], _.identity); // initial connect\n\n  stream.sent = [];\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId)); // Test that we sent just the login message.\n\n  var loginId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'do_something',\n    params: ['login'],\n    id: '*'\n  }).id; // we connect.\n\n  stream.receive({\n    msg: 'connected',\n    session: Random.id()\n  });\n  test.length(stream.sent, 0); // login got result (but not yet data)\n\n  stream.receive({\n    msg: 'result',\n    id: loginId,\n    result: 'foo'\n  });\n  test.length(stream.sent, 0); // login got data. now we send next method.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [loginId]\n  });\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'do_something',\n    params: ['one'],\n    id: '*'\n  }).id;\n});\naddReconnectTests('livedata stub - reconnect double wait method', function (test, setOnReconnect) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n  var output = [];\n  setOnReconnect(conn, function () {\n    conn.apply('reconnectMethod', [], {\n      wait: true\n    }, function (err, result) {\n      output.push('reconnect');\n    });\n  });\n  conn.apply('halfwayMethod', [], {\n    wait: true\n  }, function (err, result) {\n    output.push('halfway');\n  });\n  test.equal(output, []); // Method sent.\n\n  var halfwayId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'halfwayMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0); // Get the result. This means it will not be resent.\n\n  stream.receive({\n    msg: 'result',\n    id: halfwayId,\n    result: 'bla'\n  }); // Callback not called.\n\n  test.equal(output, []); // Reset stream. halfwayMethod does NOT get resent, but reconnectMethod does!\n  // Reconnect quiescence happens when reconnectMethod is done.\n\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  var reconnectId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'reconnectMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.length(stream.sent, 0); // Still holding out hope for session resumption, so no callbacks yet.\n\n  test.equal(output, []); // Receive 'connected', but reconnect quiescence is blocking on\n  // reconnectMethod.\n\n  stream.receive({\n    msg: 'connected',\n    session: SESSION_ID + 1\n  });\n  test.equal(output, []); // Data-done for reconnectMethod. This gets us to reconnect quiescence, so\n  // halfwayMethod's callback fires. reconnectMethod's is still waiting on its\n  // result.\n\n  stream.receive({\n    msg: 'updated',\n    methods: [reconnectId]\n  });\n  test.equal(output.shift(), 'halfway');\n  test.equal(output, []); // Get result of reconnectMethod. Its callback fires.\n\n  stream.receive({\n    msg: 'result',\n    id: reconnectId,\n    result: 'foo'\n  });\n  test.equal(output.shift(), 'reconnect');\n  test.equal(output, []); // Call another method. It should be delivered immediately. This is a\n  // regression test for a case where it never got delivered because there was\n  // an empty block in _outstandingMethodBlocks blocking it from being sent.\n\n  conn.call('lastMethod', _.identity);\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'lastMethod',\n    params: [],\n    id: '*'\n  });\n});\nTinytest.add('livedata stub - subscribe errors', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var onReadyFired = false;\n  var subErrorInStopped = null;\n  var subErrorInError = null;\n  conn.subscribe('unknownSub', {\n    onReady: function () {\n      onReadyFired = true;\n    },\n    // We now have two ways to get the error from a subscription:\n    // 1. onStop, which is called no matter what when the subscription is\n    //    stopped (a lifecycle callback)\n    // 2. onError, which is deprecated and is called only if there is an\n    //    error\n    onStop: function (error) {\n      subErrorInStopped = error;\n    },\n    onError: function (error) {\n      subErrorInError = error;\n    }\n  });\n  test.isFalse(onReadyFired);\n  test.equal(subErrorInStopped, null); // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n  test.equal(subErrorInError, null);\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'unknownSub',\n    params: [],\n    id: subMessage.id\n  }); // Reject the sub.\n\n  stream.receive({\n    msg: 'nosub',\n    id: subMessage.id,\n    error: new Meteor.Error(404, 'Subscription not found')\n  });\n  test.isFalse(onReadyFired); // Check the error passed to the stopped callback was correct\n\n  test.instanceOf(subErrorInStopped, Meteor.Error);\n  test.equal(subErrorInStopped.error, 404);\n  test.equal(subErrorInStopped.reason, 'Subscription not found'); // Check the error passed to the error callback was correct\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n  test.instanceOf(subErrorInError, Meteor.Error);\n  test.equal(subErrorInError.error, 404);\n  test.equal(subErrorInError.reason, 'Subscription not found'); // stream reset: reconnect!\n\n  stream.reset(); // We send a connect.\n\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID)); // We should NOT re-sub to the sub, because we processed the error.\n\n  test.length(stream.sent, 0);\n  test.isFalse(onReadyFired);\n});\nTinytest.add('livedata stub - subscribe stop', function (test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream); // subscribe\n\n  var onReadyFired = false;\n  var onStopFired = false;\n  var subErrorInStopped = null;\n  var sub = conn.subscribe('my_data', {\n    onStop: function (error) {\n      onStopFired = true;\n      subErrorInStopped = error;\n    }\n  });\n  test.equal(subErrorInStopped, null);\n  sub.stop();\n  test.isTrue(onStopFired);\n  test.equal(subErrorInStopped, undefined);\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - stubs before connected', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    }); // Start and send \"connect\", but DON'T get 'connected' quite yet.\n\n    stream.reset(); // initial connection start.\n\n    testGotMessage(test, stream, makeConnectMessage());\n    test.length(stream.sent, 0); // Insert a document. The stub updates \"conn\" directly.\n\n    coll.insert({\n      _id: 'foo',\n      bar: 42\n    }, _.identity);\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(), {\n      _id: 'foo',\n      bar: 42\n    }); // It also sends the method message.\n\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.isUndefined(methodMessage.randomSeed);\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: '/' + collName + '/insert',\n      params: [{\n        _id: 'foo',\n        bar: 42\n      }],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0); // Now receive a connected message. This should not clear the\n    // _documentsWrittenByStub state!\n\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID\n    });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 1); // Now receive the \"updated\" message for the method. This should revert the\n    // insert.\n\n    stream.receive({\n      msg: 'updated',\n      methods: [methodMessage.id]\n    });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 0);\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - method call between reset and quiescence', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      update_value: function () {\n        coll.update('aaa', {\n          value: 222\n        });\n      }\n    }); // Set up test subscription.\n\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {\n      msg: 'sub',\n      name: 'test_data',\n      params: [],\n      id: subMessage.id\n    });\n    test.length(stream.sent, 0);\n    var subDocMessage = {\n      msg: 'added',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        value: 111\n      }\n    };\n    var subReadyMessage = {\n      msg: 'ready',\n      subs: [subMessage.id]\n    };\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.isTrue(coll.findOne('aaa').value == 111); // Initiate reconnect.\n\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    testGotMessage(test, stream, subMessage);\n    stream.receive({\n      msg: 'connected',\n      session: SESSION_ID + 1\n    }); // Now in reconnect, can still see the document.\n\n    test.isTrue(coll.findOne('aaa').value == 111);\n    conn.call('update_value'); // Observe the stub-written value.\n\n    test.isTrue(coll.findOne('aaa').value == 222);\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: 'update_value',\n      params: [],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0);\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage); // By this point quiescence is reached and stores have been reset.\n    // The stub-written value is still there.\n\n    test.isTrue(coll.findOne('aaa').value == 222);\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        value: 333\n      }\n    });\n    stream.receive({\n      msg: 'updated',\n      methods: [methodMessage.id]\n    });\n    stream.receive({\n      msg: 'result',\n      id: methodMessage.id,\n      result: null\n    }); // Server wrote a different value, make sure it's visible now.\n\n    test.isTrue(coll.findOne('aaa').value == 333);\n  });\n  Tinytest.add('livedata stub - buffering and methods interaction', function (test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream, {\n      // A very high values so that all messages are effectively buffered.\n      bufferedWritesInterval: 10000,\n      bufferedWritesMaxAge: 10000\n    });\n    startAndConnect(test, stream);\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, {\n      connection: conn\n    });\n    conn.methods({\n      update_value: function () {\n        var value = coll.findOne('aaa').subscription; // Method should have access to the latest value of the collection.\n\n        coll.update('aaa', {\n          $set: {\n            method: value + 110\n          }\n        });\n      }\n    }); // Set up test subscription.\n\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {\n      msg: 'sub',\n      name: 'test_data',\n      params: [],\n      id: subMessage.id\n    });\n    test.length(stream.sent, 0);\n    var subDocMessage = {\n      msg: 'added',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        subscription: 111\n      }\n    };\n    var subReadyMessage = {\n      msg: 'ready',\n      subs: [subMessage.id]\n    };\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.equal(coll.findOne('aaa').subscription, 111);\n    var subDocChangeMessage = {\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        subscription: 112\n      }\n    };\n    stream.receive(subDocChangeMessage); // Still 111 because buffer has not been flushed.\n\n    test.equal(coll.findOne('aaa').subscription, 111); // Call updates the stub.\n\n    conn.call('update_value'); // Observe the stub-written value.\n\n    test.equal(coll.findOne('aaa').method, 222); // subscription field is updated to the latest value\n    // because of the method call.\n\n    test.equal(coll.findOne('aaa').subscription, 112);\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: 'update_value',\n      params: [],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0); // \"Server-side\" change from the method arrives and method returns.\n    // With potentially fixed value for method field, if stub didn't\n    // use 112 as the subscription field value.\n\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: {\n        method: 222\n      }\n    });\n    stream.receive({\n      msg: 'updated',\n      methods: [methodMessage.id]\n    });\n    stream.receive({\n      msg: 'result',\n      id: methodMessage.id,\n      result: null\n    });\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112); // Buffer should already be flushed because of a non-update message.\n    // And after a flush we really want subscription field to be 112.\n\n    conn._flushBufferedWrites();\n\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n  });\n} // XXX also test:\n// - reconnect, with session resume.\n// - restart on update flag\n// - on_update event\n// - reloading when the app changes, including session migration","map":{"version":3,"sources":["packages/ddp-client/test/livedata_connection_tests.js"],"names":["lolex","module","watch","require","v","DDP","Connection","newConnection","stream","options","_","extend","reloadWithOutstanding","bufferedWritesInterval","makeConnectMessage","session","msg","version","DDPCommon","SUPPORTED_DDP_VERSIONS","support","testGotMessage","test","expected","sent","length","fail","error","undefined","got","shift","JSON","parse","keysWithStarValues","each","k","push","equal","startAndConnect","reset","receive","SESSION_ID","Tinytest","add","StubStream","conn","coll_name","Random","id","collection","fields","a","_updatesForUnknownStores","coll","Mongo","Collection","isUndefined","find","fetch","_id","clock","install","tick","timeout","bufferedWritesMaxAge","testDocCount","count","addDoc","uninstall","callback_fired","sub","subscribe","isFalse","message","name","params","reactivelyReady","autorunHandle","Tracker","autorun","ready","subs","isTrue","flush","stop","id2","notEqual","rFoo","ReactiveVar","rBar","onReadyCount","onReady","tag","has","stopperHandle","completerHandle","get","completerReady","readyAutorunHandle","idFoo1","idBar1","idCompleter","idStopper","completer","set","idFoo2","idStopperAgain","bar1","stopper","unsubMessages","map","unique","pluck","actualIds","expectedIds","sort","fooHandle","fooReady","idFoo3","methods","test_this","isSimulation","unblock","call","identity","randomSeed","method","result","Meteor","isClient","collName","connection","do_something","x","insert","value","counts","added","removed","changed","moved","handle","observe","addedAt","removedAt","changedAt","movedTo","callback1Fired","err","res","docId","findOne","MongoID","idStringify","callback2Fired","message2","mutateArgs","arg","foo","observeCursor","cursor","expectedCounts","clone","bind","expectCallbacks","delta","mod","field","do_something_else","o","newDoc","callbackOutput","subCallbackFired","subMessage","b","methodCallbackFired","apply","wait","methodMessage","c","d","e","waitMethodMessage","laterMethodMessage","firstMethodCallbackFired","firstMethodCallbackErrored","secondMethodCallbackFired","secondMethodCallbackErrored","noRetry","addReconnectTests","testFunc","deprecatedSetOnReconnect","handler","onReconnect","setOnReconnect","reconnectingConn","writeSomething","onResultReceivedOutput","onResultReceived","stubWrittenId","methodId","baz","stubWrittenId2","methodId2","slowMethodId","insertSomething","updateIt","update","$set","insertMethodId","updateMethodId","other","other2","cleared","firstMethodId","waitMethodId","readiedSubs","markAllReady","fooArg","inner","outer","invalidated","invalidate","userId","setUserId","responses","one_message","two_message","y","three_message","four_message","five_message","six_message","_lastSessionId","_outstandingMethodBlocks","block","_message","addAsync","onComplete","getSelfConnectionUrl","supportedDDPVersions","onDDPVersionNegotiationFailure","onConnected","_version","_stream","on","json","done","_debug","disconnect","_permanent","_send","ddpUrl","_relativeToSiteRootUrl","__meteor_runtime_config__","DDP_DEFAULT_CONNECTION_URL","absoluteUrl","isServer","reverse","split","join","testAsyncMulti","expect","self","connect","pollUntil","status","connected","doTest","reconnect","url","matches","reason","loginId","output","halfwayId","reconnectId","onReadyFired","subErrorInStopped","subErrorInError","onStop","onError","Error","instanceOf","onStopFired","bar","update_value","subDocMessage","subReadyMessage","subscription","subDocChangeMessage","_flushBufferedWrites"],"mappings":"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","sourcesContent":["import lolex from 'lolex';\nimport { DDP } from '../common/namespace.js';\nimport { Connection } from '../common/livedata_connection.js';\n\nvar newConnection = function(stream, options) {\n  // Some of these tests leave outstanding methods with no result yet\n  // returned. This should not block us from re-running tests when sources\n  // change.\n  return new Connection(\n    stream,\n    _.extend(\n      {\n        reloadWithOutstanding: true,\n        bufferedWritesInterval: 0\n      },\n      options\n    )\n  );\n};\n\nvar makeConnectMessage = function(session) {\n  var msg = {\n    msg: 'connect',\n    version: DDPCommon.SUPPORTED_DDP_VERSIONS[0],\n    support: DDPCommon.SUPPORTED_DDP_VERSIONS\n  };\n\n  if (session) msg.session = session;\n  return msg;\n};\n\n// Tests that stream got a message that matches expected.\n// Expected is normally an object, and allows a wildcard value of '*',\n// which will then match any value.\n// Returns the message (parsed as a JSON object if expected is an object);\n// which is particularly handy if you want to extract a value that was\n// matched as a wildcard.\nvar testGotMessage = function(test, stream, expected) {\n  if (stream.sent.length === 0) {\n    test.fail({ error: 'no message received', expected: expected });\n    return undefined;\n  }\n\n  var got = stream.sent.shift();\n\n  if (typeof got === 'string' && typeof expected === 'object')\n    got = JSON.parse(got);\n\n  // An expected value of '*' matches any value, and the matching value (or\n  // array of matching values, if there are multiple) is returned from this\n  // function.\n  if (typeof expected === 'object') {\n    var keysWithStarValues = [];\n    _.each(expected, function(v, k) {\n      if (v === '*') keysWithStarValues.push(k);\n    });\n    _.each(keysWithStarValues, function(k) {\n      expected[k] = got[k];\n    });\n  }\n\n  test.equal(got, expected);\n  return got;\n};\n\nvar startAndConnect = function(test, stream) {\n  stream.reset(); // initial connection start.\n\n  testGotMessage(test, stream, makeConnectMessage());\n  test.length(stream.sent, 0);\n\n  stream.receive({ msg: 'connected', session: SESSION_ID });\n  test.length(stream.sent, 0);\n};\n\nvar SESSION_ID = '17';\n\nTinytest.add('livedata stub - receive data', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // data comes in for unknown collection.\n  var coll_name = Random.id();\n  stream.receive({\n    msg: 'added',\n    collection: coll_name,\n    id: '1234',\n    fields: { a: 1 }\n  });\n  // break throught the black box and test internal state\n  test.length(conn._updatesForUnknownStores[coll_name], 1);\n\n  // XXX: Test that the old signature of passing manager directly instead of in\n  // options works.\n  var coll = new Mongo.Collection(coll_name, conn);\n\n  // queue has been emptied and doc is in db.\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n  test.equal(coll.find({}).fetch(), [{ _id: '1234', a: 1 }]);\n\n  // second message. applied directly to the db.\n  stream.receive({\n    msg: 'changed',\n    collection: coll_name,\n    id: '1234',\n    fields: { a: 2 }\n  });\n  test.equal(coll.find({}).fetch(), [{ _id: '1234', a: 2 }]);\n  test.isUndefined(conn._updatesForUnknownStores[coll_name]);\n});\n\nTinytest.add('livedata stub - buffering data', function(test) {\n  // Install special setTimeout that allows tick-by-tick control in tests using sinonjs 'lolex'\n  // This needs to be before the connection is instantiated.\n  const clock = lolex.install();\n  const tick = timeout => clock.tick(timeout);\n\n  const stream = new StubStream();\n  const conn = newConnection(stream, {\n    bufferedWritesInterval: 10,\n    bufferedWritesMaxAge: 40\n  });\n\n  startAndConnect(test, stream);\n\n  const coll_name = Random.id();\n  const coll = new Mongo.Collection(coll_name, conn);\n\n  const testDocCount = count => test.equal(coll.find({}).count(), count);\n\n  const addDoc = () => {\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: Random.id(),\n      fields: {}\n    });\n  };\n\n  // Starting at 0 ticks.  At this point we haven't advanced the fake clock at all.\n\n  addDoc(); // 1st Doc\n  testDocCount(0); // No doc been recognized yet because it's buffered, waiting for more.\n  tick(6); // 6 total ticks\n  testDocCount(0); // Ensure that the doc still hasn't shown up, despite the clock moving forward.\n  tick(4); // 10 total ticks, 1st buffer interval\n  testDocCount(1); // No other docs have arrived, so we 'see' the 1st doc.\n\n  addDoc(); // 2nd doc\n  tick(1); // 11 total ticks (1 since last flush)\n  testDocCount(1); // Again, second doc hasn't arrived because we're waiting for more...\n  tick(9); // 20 total ticks (10 ticks since last flush & the 2nd 10-tick interval)\n  testDocCount(2); // Now we're here and got the second document.\n\n  // Add several docs, frequently enough that we buffer multiple times before the next flush.\n  addDoc(); // 3 docs\n  tick(6); // 26 ticks (6 since last flush)\n  addDoc(); // 4 docs\n  tick(6); // 32 ticks (12 since last flush)\n  addDoc(); // 5 docs\n  tick(6); // 38 ticks (18 since last flush)\n  addDoc(); // 6 docs\n  tick(6); // 44 ticks (24 since last flush)\n  addDoc(); // 7 docs\n  tick(9); // 53 ticks (33 since last flush)\n  addDoc(); // 8 docs\n  tick(9); // 62 ticks! (42 ticks since last flush, over max-age - next interval triggers flush)\n  testDocCount(2); // Still at 2 from before! (Just making sure)\n  tick(1); // Ok, 63 ticks (10 since last doc, so this should cause the flush of all the docs)\n  testDocCount(8); // See all the docs.\n\n  // Put things back how they were.\n  clock.uninstall();\n});\n\nTinytest.add('livedata stub - subscribe', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var callback_fired = false;\n  var sub = conn.subscribe('my_data', function() {\n    callback_fired = true;\n  });\n  test.isFalse(callback_fired);\n\n  test.length(stream.sent, 1);\n  var message = JSON.parse(stream.sent.shift());\n  var id = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'my_data', params: [] });\n\n  var reactivelyReady = false;\n  var autorunHandle = Tracker.autorun(function() {\n    reactivelyReady = sub.ready();\n  });\n  test.isFalse(reactivelyReady);\n\n  // get the sub satisfied. callback fires.\n  stream.receive({ msg: 'ready', subs: [id] });\n  test.isTrue(callback_fired);\n  Tracker.flush();\n  test.isTrue(reactivelyReady);\n\n  // Unsubscribe.\n  sub.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, { msg: 'unsub', id: id });\n  Tracker.flush();\n  test.isFalse(reactivelyReady);\n\n  // Resubscribe.\n  conn.subscribe('my_data');\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  var id2 = message.id;\n  test.notEqual(id, id2);\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'my_data', params: [] });\n});\n\nTinytest.add('livedata stub - reactive subscribe', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var rFoo = new ReactiveVar('foo1');\n  var rBar = new ReactiveVar('bar1');\n\n  var onReadyCount = {};\n  var onReady = function(tag) {\n    return function() {\n      if (_.has(onReadyCount, tag)) ++onReadyCount[tag];\n      else onReadyCount[tag] = 1;\n    };\n  };\n\n  // Subscribe to some subs.\n  var stopperHandle, completerHandle;\n  var autorunHandle = Tracker.autorun(function() {\n    conn.subscribe('foo', rFoo.get(), onReady(rFoo.get()));\n    conn.subscribe('bar', rBar.get(), onReady(rBar.get()));\n    completerHandle = conn.subscribe('completer', onReady('completer'));\n    stopperHandle = conn.subscribe('stopper', onReady('stopper'));\n  });\n\n  var completerReady;\n  var readyAutorunHandle = Tracker.autorun(function() {\n    completerReady = completerHandle.ready();\n  });\n\n  // Check sub messages. (Assume they are sent in the order executed.)\n  test.length(stream.sent, 4);\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo', params: ['foo1'] });\n\n  message = JSON.parse(stream.sent.shift());\n  var idBar1 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'bar', params: ['bar1'] });\n\n  message = JSON.parse(stream.sent.shift());\n  var idCompleter = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'completer', params: [] });\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopper = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'stopper', params: [] });\n\n  // Haven't hit onReady yet.\n  test.equal(onReadyCount, {});\n  Tracker.flush();\n  test.isFalse(completerReady);\n\n  // \"completer\" gets ready now. its callback should fire.\n  stream.receive({ msg: 'ready', subs: [idCompleter] });\n  test.equal(onReadyCount, { completer: 1 });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(completerReady);\n\n  // Stop 'stopper'.\n  stopperHandle.stop();\n  test.length(stream.sent, 1);\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, { msg: 'unsub', id: idStopper });\n\n  test.equal(onReadyCount, { completer: 1 });\n  Tracker.flush();\n  test.isTrue(completerReady);\n\n  // Change the foo subscription and flush. We should sub to the new foo\n  // subscription, re-sub to the stopper subscription, and then unsub from the old\n  // foo subscription. The bar subscription should be unaffected. The completer\n  // subscription should call its new onReady callback, because we always\n  // call onReady for a given reactively-saved subscription.\n  // The completerHandle should have been reestablished to the ready handle.\n  rFoo.set('foo2');\n  Tracker.flush();\n  test.length(stream.sent, 3);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo', params: ['foo2'] });\n\n  message = JSON.parse(stream.sent.shift());\n  var idStopperAgain = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'stopper', params: [] });\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, { msg: 'unsub', id: idFoo1 });\n\n  test.equal(onReadyCount, { completer: 2 });\n  test.isTrue(completerReady);\n\n  // Ready the stopper and bar subs. Completing stopper should call only the\n  // onReady from the new subscription because they were separate subscriptions\n  // started at different times and the first one was explicitly torn down by\n  // the client; completing bar should call the onReady from the new\n  // subscription because we always call onReady for a given reactively-saved\n  // subscription.\n  stream.receive({ msg: 'ready', subs: [idStopperAgain, idBar1] });\n  test.equal(onReadyCount, { completer: 2, bar1: 1, stopper: 1 });\n\n  // Shut down the autorun. This should unsub us from all current subs at flush\n  // time.\n  autorunHandle.stop();\n  Tracker.flush();\n  test.isFalse(completerReady);\n  readyAutorunHandle.stop();\n\n  test.length(stream.sent, 4);\n  // The order of unsubs here is not important.\n  var unsubMessages = _.map(stream.sent, JSON.parse);\n  stream.sent.length = 0;\n  test.equal(_.unique(_.pluck(unsubMessages, 'msg')), ['unsub']);\n  var actualIds = _.pluck(unsubMessages, 'id');\n  var expectedIds = [idFoo2, idBar1, idCompleter, idStopperAgain];\n  actualIds.sort();\n  expectedIds.sort();\n  test.equal(actualIds, expectedIds);\n});\n\nTinytest.add('livedata stub - reactive subscribe handle correct', function(\n  test\n) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var rFoo = new ReactiveVar('foo1');\n\n  // Subscribe to some subs.\n  var fooHandle, fooReady;\n  var autorunHandle = Tracker.autorun(function() {\n    fooHandle = conn.subscribe('foo', rFoo.get());\n    Tracker.autorun(function() {\n      fooReady = fooHandle.ready();\n    });\n  });\n\n  var message = JSON.parse(stream.sent.shift());\n  var idFoo1 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo', params: ['foo1'] });\n\n  // Not ready yet\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, reading the new false value, and\n  // setting up a new dep which goes true soon\n  rFoo.set('foo2');\n  Tracker.flush();\n  test.length(stream.sent, 2);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo2 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo', params: ['foo2'] });\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, { msg: 'unsub', id: idFoo1 });\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // \"foo\" gets ready now. The handle should be ready and the autorun rerun\n  stream.receive({ msg: 'ready', subs: [idFoo2] });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n\n  // change the argument to foo. This will make a new handle, which isn't ready\n  // the ready autorun should invalidate, making fooReady false too\n  rFoo.set('foo3');\n  Tracker.flush();\n  test.length(stream.sent, 2);\n\n  message = JSON.parse(stream.sent.shift());\n  var idFoo3 = message.id;\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo', params: ['foo3'] });\n\n  message = JSON.parse(stream.sent.shift());\n  test.equal(message, { msg: 'unsub', id: idFoo2 });\n\n  Tracker.flush();\n  test.isFalse(fooHandle.ready());\n  test.isFalse(fooReady);\n\n  // \"foo\" gets ready again\n  stream.receive({ msg: 'ready', subs: [idFoo3] });\n  test.length(stream.sent, 0);\n  Tracker.flush();\n  test.isTrue(fooHandle.ready());\n  test.isTrue(fooReady);\n\n  autorunHandle.stop();\n});\n\nTinytest.add('livedata stub - this', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n  conn.methods({\n    test_this: function() {\n      test.isTrue(this.isSimulation);\n      this.unblock(); // should be a no-op\n    }\n  });\n\n  // should throw no exceptions\n  conn.call('test_this', _.identity);\n  // satisfy method, quiesce connection\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'test_this',\n    params: [],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n\n  stream.receive({ msg: 'result', id: message.id, result: null });\n  stream.receive({ msg: 'updated', methods: [message.id] });\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - methods', function(test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, { connection: conn });\n\n    // setup method\n    conn.methods({\n      do_something: function(x) {\n        coll.insert({ value: x });\n      }\n    });\n\n    // setup observers\n    var counts = { added: 0, removed: 0, changed: 0, moved: 0 };\n    var handle = coll.find({}).observe({\n      addedAt: function() {\n        counts.added += 1;\n      },\n      removedAt: function() {\n        counts.removed += 1;\n      },\n      changedAt: function() {\n        counts.changed += 1;\n      },\n      movedTo: function() {\n        counts.moved += 1;\n      }\n    });\n\n    // call method with results callback\n    var callback1Fired = false;\n    conn.call('do_something', 'friday!', function(err, res) {\n      test.isUndefined(err);\n      test.equal(res, '1234');\n      callback1Fired = true;\n    });\n    test.isFalse(callback1Fired);\n\n    // observers saw the method run.\n    test.equal(counts, { added: 1, removed: 0, changed: 0, moved: 0 });\n\n    // get response from server\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: ['friday!'],\n      id: '*',\n      randomSeed: '*'\n    });\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({ value: 'friday!' }).count(), 1);\n    var docId = coll.findOne({ value: 'friday!' })._id;\n\n    // results does not yet result in callback, because data is not\n    // ready.\n    stream.receive({ msg: 'result', id: message.id, result: '1234' });\n    test.isFalse(callback1Fired);\n\n    // result message doesn't affect data\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({ value: 'friday!' }).count(), 1);\n    test.equal(counts, { added: 1, removed: 0, changed: 0, moved: 0 });\n\n    // data methods do not show up (not quiescent yet)\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(docId),\n      fields: { value: 'tuesday' }\n    });\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({ value: 'friday!' }).count(), 1);\n    test.equal(counts, { added: 1, removed: 0, changed: 0, moved: 0 });\n\n    // send another methods (unknown on client)\n    var callback2Fired = false;\n    conn.call('do_something_else', 'monday', function(err, res) {\n      callback2Fired = true;\n    });\n    test.isFalse(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    // test we still send a method request to server\n    var message2 = JSON.parse(stream.sent.shift());\n    test.isUndefined(message2.randomSeed);\n    test.equal(message2, {\n      msg: 'method',\n      method: 'do_something_else',\n      params: ['monday'],\n      id: message2.id\n    });\n\n    // get the first data satisfied message. changes are applied to database even\n    // though another method is outstanding, because the other method didn't have\n    // a stub. and its callback is called.\n    stream.receive({ msg: 'updated', methods: [message.id] });\n    test.isTrue(callback1Fired);\n    test.isFalse(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({ value: 'tuesday' }).count(), 1);\n    test.equal(counts, { added: 1, removed: 0, changed: 1, moved: 0 });\n\n    // second result\n    stream.receive({ msg: 'result', id: message2.id, result: 'bupkis' });\n    test.isFalse(callback2Fired);\n\n    // get second satisfied; no new changes are applied.\n    stream.receive({ msg: 'updated', methods: [message2.id] });\n    test.isTrue(callback2Fired);\n\n    test.equal(coll.find({}).count(), 1);\n    test.equal(coll.find({ value: 'tuesday', _id: docId }).count(), 1);\n    test.equal(counts, { added: 1, removed: 0, changed: 1, moved: 0 });\n\n    handle.stop();\n  });\n}\n\nTinytest.add('livedata stub - mutating method args', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  conn.methods({\n    mutateArgs: function(arg) {\n      arg.foo = 42;\n    }\n  });\n\n  conn.call('mutateArgs', { foo: 50 }, _.identity);\n\n  // Method should be called with original arg, not mutated arg.\n  var message = JSON.parse(stream.sent.shift());\n  test.isUndefined(message.randomSeed);\n  test.equal(message, {\n    msg: 'method',\n    method: 'mutateArgs',\n    params: [{ foo: 50 }],\n    id: message.id\n  });\n  test.length(stream.sent, 0);\n});\n\nvar observeCursor = function(test, cursor) {\n  var counts = { added: 0, removed: 0, changed: 0, moved: 0 };\n  var expectedCounts = _.clone(counts);\n  var handle = cursor.observe({\n    addedAt: function() {\n      counts.added += 1;\n    },\n    removedAt: function() {\n      counts.removed += 1;\n    },\n    changedAt: function() {\n      counts.changed += 1;\n    },\n    movedTo: function() {\n      counts.moved += 1;\n    }\n  });\n  return {\n    stop: _.bind(handle.stop, handle),\n    expectCallbacks: function(delta) {\n      _.each(delta, function(mod, field) {\n        expectedCounts[field] += mod;\n      });\n      test.equal(counts, expectedCounts);\n    }\n  };\n};\n\n// method calls another method in simulation. see not sent.\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - methods calling methods', function(test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var coll_name = Random.id();\n    var coll = new Mongo.Collection(coll_name, { connection: conn });\n\n    // setup methods\n    conn.methods({\n      do_something: function() {\n        conn.call('do_something_else');\n      },\n      do_something_else: function() {\n        coll.insert({ a: 1 });\n      }\n    });\n\n    var o = observeCursor(test, coll.find());\n\n    // call method.\n    conn.call('do_something', _.identity);\n\n    // see we only send message for outer methods\n    var message = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    });\n    test.length(stream.sent, 0);\n\n    // but inner method runs locally.\n    o.expectCallbacks({ added: 1 });\n    test.equal(coll.find().count(), 1);\n    var docId = coll.findOne()._id;\n    test.equal(coll.findOne(), { _id: docId, a: 1 });\n\n    // we get the results\n    stream.receive({ msg: 'result', id: message.id, result: '1234' });\n\n    // get data from the method. data from this doc does not show up yet, but data\n    // from another doc does.\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: MongoID.idStringify(docId),\n      fields: { value: 'tuesday' }\n    });\n    o.expectCallbacks();\n    test.equal(coll.findOne(docId), { _id: docId, a: 1 });\n    stream.receive({\n      msg: 'added',\n      collection: coll_name,\n      id: 'monkey',\n      fields: { value: 'bla' }\n    });\n    o.expectCallbacks({ added: 1 });\n    test.equal(coll.findOne(docId), { _id: docId, a: 1 });\n    var newDoc = coll.findOne({ value: 'bla' });\n    test.isTrue(newDoc);\n    test.equal(newDoc, { _id: newDoc._id, value: 'bla' });\n\n    // get method satisfied. all data shows up. the 'a' field is reverted and\n    // 'value' field is set.\n    stream.receive({ msg: 'updated', methods: [message.id] });\n    o.expectCallbacks({ changed: 1 });\n    test.equal(coll.findOne(docId), { _id: docId, value: 'tuesday' });\n    test.equal(coll.findOne(newDoc._id), { _id: newDoc._id, value: 'bla' });\n\n    o.stop();\n  });\n}\nTinytest.add('livedata stub - method call before connect', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  var callbackOutput = [];\n  conn.call('someMethod', function(err, result) {\n    callbackOutput.push(result);\n  });\n  test.equal(callbackOutput, []);\n\n  // the real stream drops all output pre-connection\n  stream.sent.length = 0;\n\n  // Now connect.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage());\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'someMethod',\n    params: [],\n    id: '*'\n  });\n});\n\nTinytest.add('livedata stub - reconnect', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, { connection: conn });\n\n  var o = observeCursor(test, coll.find());\n\n  // subscribe\n  var subCallbackFired = false;\n  var sub = conn.subscribe('my_data', function() {\n    subCallbackFired = true;\n  });\n  test.isFalse(subCallbackFired);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'my_data',\n    params: [],\n    id: subMessage.id\n  });\n\n  // get some data. it shows up.\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: { a: 1 }\n  });\n\n  test.equal(coll.find({}).count(), 1);\n  o.expectCallbacks({ added: 1 });\n  test.isFalse(subCallbackFired);\n\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: { b: 2 }\n  });\n  stream.receive({\n    msg: 'ready',\n    subs: [subMessage.id] // satisfy sub\n  });\n  test.isTrue(subCallbackFired);\n  subCallbackFired = false; // re-arm for test that it doesn't fire again.\n\n  test.equal(coll.find({ a: 1, b: 2 }).count(), 1);\n  o.expectCallbacks({ changed: 1 });\n\n  // call method.\n  var methodCallbackFired = false;\n  conn.call('do_something', function() {\n    methodCallbackFired = true;\n  });\n\n  conn.apply('do_something_else', [], { wait: true }, _.identity);\n  conn.apply('do_something_later', [], _.identity);\n\n  test.isFalse(methodCallbackFired);\n\n  // The non-wait method should send, but not the wait method.\n  var methodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(methodMessage.randomSeed);\n  test.equal(methodMessage, {\n    msg: 'method',\n    method: 'do_something',\n    params: [],\n    id: methodMessage.id\n  });\n  test.equal(stream.sent.length, 0);\n\n  // more data. shows up immediately because there was no relevant method stub.\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: '1234',\n    fields: { c: 3 }\n  });\n  test.equal(coll.findOne('1234'), { _id: '1234', a: 1, b: 2, c: 3 });\n  o.expectCallbacks({ changed: 1 });\n\n  // stream reset. reconnect!  we send a connect, our pending method, and our\n  // sub. The wait method still is blocked.\n  stream.reset();\n\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, methodMessage);\n  testGotMessage(test, stream, subMessage);\n\n  // reconnect with different session id\n  stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n\n  // resend data. doesn't show up: we're in reconnect quiescence.\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '1234',\n    fields: { a: 1, b: 2, c: 3, d: 4 }\n  });\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: '2345',\n    fields: { e: 5 }\n  });\n  test.equal(coll.findOne('1234'), { _id: '1234', a: 1, b: 2, c: 3 });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // satisfy and return the method\n  stream.receive({\n    msg: 'updated',\n    methods: [methodMessage.id]\n  });\n  test.isFalse(methodCallbackFired);\n  stream.receive({ msg: 'result', id: methodMessage.id, result: 'bupkis' });\n  // The callback still doesn't fire (and we don't send the wait method): we're\n  // still in global quiescence\n  test.isFalse(methodCallbackFired);\n  test.equal(stream.sent.length, 0);\n\n  // still no update.\n  test.equal(coll.findOne('1234'), { _id: '1234', a: 1, b: 2, c: 3 });\n  test.isFalse(coll.findOne('2345'));\n  o.expectCallbacks();\n\n  // re-satisfy sub\n  stream.receive({ msg: 'ready', subs: [subMessage.id] });\n\n  // now the doc changes and method callback is called, and the wait method is\n  // sent. the sub callback isn't re-called.\n  test.isTrue(methodCallbackFired);\n  test.isFalse(subCallbackFired);\n  test.equal(coll.findOne('1234'), { _id: '1234', a: 1, b: 2, c: 3, d: 4 });\n  test.equal(coll.findOne('2345'), { _id: '2345', e: 5 });\n  o.expectCallbacks({ added: 1, changed: 1 });\n\n  var waitMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(waitMethodMessage.randomSeed);\n  test.equal(waitMethodMessage, {\n    msg: 'method',\n    method: 'do_something_else',\n    params: [],\n    id: waitMethodMessage.id\n  });\n  test.equal(stream.sent.length, 0);\n  stream.receive({ msg: 'result', id: waitMethodMessage.id, result: 'bupkis' });\n  test.equal(stream.sent.length, 0);\n  stream.receive({ msg: 'updated', methods: [waitMethodMessage.id] });\n\n  // wait method done means we can send the third method\n  test.equal(stream.sent.length, 1);\n  var laterMethodMessage = JSON.parse(stream.sent.shift());\n  test.isUndefined(laterMethodMessage.randomSeed);\n  test.equal(laterMethodMessage, {\n    msg: 'method',\n    method: 'do_something_later',\n    params: [],\n    id: laterMethodMessage.id\n  });\n\n  o.stop();\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - reconnect non-idempotent method', function(\n    test\n  ) {\n    // This test is for https://github.com/meteor/meteor/issues/6108\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    startAndConnect(test, stream);\n\n    var firstMethodCallbackFired = false;\n    var firstMethodCallbackErrored = false;\n    var secondMethodCallbackFired = false;\n    var secondMethodCallbackErrored = false;\n\n    // call with noRetry true so that the method should fail to retry on reconnect.\n    conn.apply('do_something', [], { noRetry: true }, function(error) {\n      firstMethodCallbackFired = true;\n      // failure on reconnect should trigger an error.\n      if (error && error.error === 'invocation-failed') {\n        firstMethodCallbackErrored = true;\n      }\n    });\n    conn.apply('do_something_else', [], { noRetry: true }, function(error) {\n      secondMethodCallbackFired = true;\n      // failure on reconnect should trigger an error.\n      if (error && error.error === 'invocation-failed') {\n        secondMethodCallbackErrored = true;\n      }\n    });\n\n    // The method has not succeeded yet\n    test.isFalse(firstMethodCallbackFired);\n    test.isFalse(secondMethodCallbackFired);\n\n    // send the methods\n    stream.sent.shift();\n    stream.sent.shift();\n    // reconnect\n    stream.reset();\n\n    // verify that a reconnect message was sent.\n    testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n    // Make sure that the stream triggers connection.\n    stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n\n    //The method callback should fire even though the stream has not sent a response.\n    //the callback should have been fired with an error.\n    test.isTrue(firstMethodCallbackFired);\n    test.isTrue(firstMethodCallbackErrored);\n    test.isTrue(secondMethodCallbackFired);\n    test.isTrue(secondMethodCallbackErrored);\n\n    // verify that the method message was not sent.\n    test.isUndefined(stream.sent.shift());\n  });\n}\n\nfunction addReconnectTests(name, testFunc) {\n  Tinytest.add(name + ' (deprecated)', function(test) {\n    function deprecatedSetOnReconnect(conn, handler) {\n      conn.onReconnect = handler;\n    }\n    testFunc.call(this, test, deprecatedSetOnReconnect);\n  });\n\n  Tinytest.add(name, function(test) {\n    var stopper;\n    function setOnReconnect(conn, handler) {\n      stopper && stopper.stop();\n      stopper = DDP.onReconnect(function(reconnectingConn) {\n        if (reconnectingConn === conn) {\n          handler();\n        }\n      });\n    }\n    testFunc.call(this, test, setOnReconnect);\n    stopper && stopper.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  addReconnectTests(\n    'livedata stub - reconnect method which only got result',\n    function(test, setOnReconnect) {\n      var stream = new StubStream();\n      var conn = newConnection(stream);\n      startAndConnect(test, stream);\n\n      var collName = Random.id();\n      var coll = new Mongo.Collection(collName, { connection: conn });\n      var o = observeCursor(test, coll.find());\n\n      conn.methods({\n        writeSomething: function() {\n          // stub write\n          coll.insert({ foo: 'bar' });\n        }\n      });\n\n      test.equal(coll.find({ foo: 'bar' }).count(), 0);\n\n      // Call a method. We'll get the result but not data-done before reconnect.\n      var callbackOutput = [];\n      var onResultReceivedOutput = [];\n      conn.apply(\n        'writeSomething',\n        [],\n        {\n          onResultReceived: function(err, result) {\n            onResultReceivedOutput.push(result);\n          }\n        },\n        function(err, result) {\n          callbackOutput.push(result);\n        }\n      );\n      // Stub write is visible.\n      test.equal(coll.find({ foo: 'bar' }).count(), 1);\n      var stubWrittenId = coll.findOne({ foo: 'bar' })._id;\n      o.expectCallbacks({ added: 1 });\n      // Callback not called.\n      test.equal(callbackOutput, []);\n      test.equal(onResultReceivedOutput, []);\n      // Method sent.\n      var methodId = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'writeSomething',\n        params: [],\n        id: '*',\n        randomSeed: '*'\n      }).id;\n      test.equal(stream.sent.length, 0);\n\n      // Get some data.\n      stream.receive({\n        msg: 'added',\n        collection: collName,\n        id: MongoID.idStringify(stubWrittenId),\n        fields: { baz: 42 }\n      });\n      // It doesn't show up yet.\n      test.equal(coll.find().count(), 1);\n      test.equal(coll.findOne(stubWrittenId), {\n        _id: stubWrittenId,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n\n      // Get the result.\n      stream.receive({ msg: 'result', id: methodId, result: 'bla' });\n      // Data unaffected.\n      test.equal(coll.find().count(), 1);\n      test.equal(coll.findOne(stubWrittenId), {\n        _id: stubWrittenId,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n      // Callback not called, but onResultReceived is.\n      test.equal(callbackOutput, []);\n      test.equal(onResultReceivedOutput, ['bla']);\n\n      // Reset stream. Method does NOT get resent, because its result is already\n      // in. Reconnect quiescence happens as soon as 'connected' is received because\n      // there are no pending methods or subs in need of revival.\n      stream.reset();\n      testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n      // Still holding out hope for session resumption, so nothing updated yet.\n      test.equal(coll.find().count(), 1);\n      test.equal(coll.findOne(stubWrittenId), {\n        _id: stubWrittenId,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n      test.equal(callbackOutput, []);\n\n      // Receive 'connected': time for reconnect quiescence! Data gets updated\n      // locally (ie, data is reset) and callback gets called.\n      stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n      test.equal(coll.find().count(), 0);\n      o.expectCallbacks({ removed: 1 });\n      test.equal(callbackOutput, ['bla']);\n      test.equal(onResultReceivedOutput, ['bla']);\n      stream.receive({\n        msg: 'added',\n        collection: collName,\n        id: MongoID.idStringify(stubWrittenId),\n        fields: { baz: 42 }\n      });\n      test.equal(coll.findOne(stubWrittenId), { _id: stubWrittenId, baz: 42 });\n      o.expectCallbacks({ added: 1 });\n\n      // Run method again. We're going to do the same thing this time, except we're\n      // also going to use an onReconnect to insert another method at reconnect\n      // time, which will delay reconnect quiescence.\n      conn.apply(\n        'writeSomething',\n        [],\n        {\n          onResultReceived: function(err, result) {\n            onResultReceivedOutput.push(result);\n          }\n        },\n        function(err, result) {\n          callbackOutput.push(result);\n        }\n      );\n      // Stub write is visible.\n      test.equal(coll.find({ foo: 'bar' }).count(), 1);\n      var stubWrittenId2 = coll.findOne({ foo: 'bar' })._id;\n      o.expectCallbacks({ added: 1 });\n      // Callback not called.\n      test.equal(callbackOutput, ['bla']);\n      test.equal(onResultReceivedOutput, ['bla']);\n      // Method sent.\n      var methodId2 = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'writeSomething',\n        params: [],\n        id: '*',\n        randomSeed: '*'\n      }).id;\n      test.equal(stream.sent.length, 0);\n\n      // Get some data.\n      stream.receive({\n        msg: 'added',\n        collection: collName,\n        id: MongoID.idStringify(stubWrittenId2),\n        fields: { baz: 42 }\n      });\n      // It doesn't show up yet.\n      test.equal(coll.find().count(), 2);\n      test.equal(coll.findOne(stubWrittenId2), {\n        _id: stubWrittenId2,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n\n      // Get the result.\n      stream.receive({ msg: 'result', id: methodId2, result: 'blab' });\n      // Data unaffected.\n      test.equal(coll.find().count(), 2);\n      test.equal(coll.findOne(stubWrittenId2), {\n        _id: stubWrittenId2,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n      // Callback not called, but onResultReceived is.\n      test.equal(callbackOutput, ['bla']);\n      test.equal(onResultReceivedOutput, ['bla', 'blab']);\n      setOnReconnect(conn, function() {\n        conn.call('slowMethod', function(err, result) {\n          callbackOutput.push(result);\n        });\n      });\n\n      // Reset stream. Method does NOT get resent, because its result is already in,\n      // but slowMethod gets called via onReconnect. Reconnect quiescence is now\n      // blocking on slowMethod.\n      stream.reset();\n      testGotMessage(test, stream, makeConnectMessage(SESSION_ID + 1));\n      var slowMethodId = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'slowMethod',\n        params: [],\n        id: '*'\n      }).id;\n      // Still holding out hope for session resumption, so nothing updated yet.\n      test.equal(coll.find().count(), 2);\n      test.equal(coll.findOne(stubWrittenId2), {\n        _id: stubWrittenId2,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n      test.equal(callbackOutput, ['bla']);\n\n      // Receive 'connected'... but no reconnect quiescence yet due to slowMethod.\n      stream.receive({ msg: 'connected', session: SESSION_ID + 2 });\n      test.equal(coll.find().count(), 2);\n      test.equal(coll.findOne(stubWrittenId2), {\n        _id: stubWrittenId2,\n        foo: 'bar'\n      });\n      o.expectCallbacks();\n      test.equal(callbackOutput, ['bla']);\n\n      // Receive data matching our stub. It doesn't take effect yet.\n      stream.receive({\n        msg: 'added',\n        collection: collName,\n        id: MongoID.idStringify(stubWrittenId2),\n        fields: { foo: 'bar' }\n      });\n      o.expectCallbacks();\n\n      // slowMethod is done writing, so we get full reconnect quiescence (but no\n      // slowMethod callback)... ie, a reset followed by applying the data we just\n      // got, as well as calling the callback from the method that half-finished\n      // before reset. The net effect is deleting doc 'stubWrittenId'.\n      stream.receive({ msg: 'updated', methods: [slowMethodId] });\n      test.equal(coll.find().count(), 1);\n      test.equal(coll.findOne(stubWrittenId2), {\n        _id: stubWrittenId2,\n        foo: 'bar'\n      });\n      o.expectCallbacks({ removed: 1 });\n      test.equal(callbackOutput, ['bla', 'blab']);\n\n      // slowMethod returns a value now.\n      stream.receive({ msg: 'result', id: slowMethodId, result: 'slow' });\n      o.expectCallbacks();\n      test.equal(callbackOutput, ['bla', 'blab', 'slow']);\n\n      o.stop();\n    }\n  );\n}\nTinytest.add('livedata stub - reconnect method which only got data', function(\n  test\n) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, { connection: conn });\n  var o = observeCursor(test, coll.find());\n\n  // Call a method. We'll get the data-done message but not the result before\n  // reconnect.\n  var callbackOutput = [];\n  var onResultReceivedOutput = [];\n  conn.apply(\n    'doLittle',\n    [],\n    {\n      onResultReceived: function(err, result) {\n        onResultReceivedOutput.push(result);\n      }\n    },\n    function(err, result) {\n      callbackOutput.push(result);\n    }\n  );\n  // Callbacks not called.\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n  // Method sent.\n  var methodId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0);\n\n  // Get some data.\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'photo',\n    fields: { baz: 42 }\n  });\n  // It shows up instantly because the stub didn't write anything.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), { _id: 'photo', baz: 42 });\n  o.expectCallbacks({ added: 1 });\n\n  // Get the data-done message.\n  stream.receive({ msg: 'updated', methods: [methodId] });\n  // Data still here.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), { _id: 'photo', baz: 42 });\n  o.expectCallbacks();\n  // Method callback not called yet (no result yet).\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Reset stream. Method gets resent (with same ID), and blocks reconnect\n  // quiescence.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'doLittle',\n    params: [],\n    id: methodId\n  });\n  // Still holding out hope for session resumption, so nothing updated yet.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), { _id: 'photo', baz: 42 });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive 'connected'. Still blocking on reconnect quiescence.\n  stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('photo'), { _id: 'photo', baz: 42 });\n  o.expectCallbacks();\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, []);\n\n  // Receive method result. onResultReceived is called but the main callback\n  // isn't (ie, we don't get confused by the fact that we got data-done the\n  // *FIRST* time through).\n  stream.receive({ msg: 'result', id: methodId, result: 'res' });\n  test.equal(callbackOutput, []);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  // Now we get data-done. Collection is reset and callback is called.\n  stream.receive({ msg: 'updated', methods: [methodId] });\n  test.equal(coll.find().count(), 0);\n  o.expectCallbacks({ removed: 1 });\n  test.equal(callbackOutput, ['res']);\n  test.equal(onResultReceivedOutput, ['res']);\n\n  o.stop();\n});\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - multiple stubs same doc', function(test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, { connection: conn });\n    var o = observeCursor(test, coll.find());\n\n    conn.methods({\n      insertSomething: function() {\n        // stub write\n        coll.insert({ foo: 'bar' });\n      },\n      updateIt: function(id) {\n        coll.update(id, { $set: { baz: 42 } });\n      }\n    });\n\n    test.equal(coll.find().count(), 0);\n\n    // Call the insert method.\n    conn.call('insertSomething', _.identity);\n    // Stub write is visible.\n    test.equal(coll.find({ foo: 'bar' }).count(), 1);\n    var stubWrittenId = coll.findOne({ foo: 'bar' })._id;\n    o.expectCallbacks({ added: 1 });\n    // Method sent.\n    var insertMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'insertSomething',\n      params: [],\n      id: '*',\n      randomSeed: '*'\n    }).id;\n    test.equal(stream.sent.length, 0);\n\n    // Call update method.\n    conn.call('updateIt', stubWrittenId, _.identity);\n    // This stub write is visible too.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks({ changed: 1 });\n    // Method sent.\n    var updateMethodId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'updateIt',\n      params: [stubWrittenId],\n      id: '*'\n    }).id;\n    test.equal(stream.sent.length, 0);\n\n    // Get some data... slightly different than what we wrote.\n    stream.receive({\n      msg: 'added',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: {\n        foo: 'barb',\n        other: 'field',\n        other2: 'bla'\n      }\n    });\n    // It doesn't show up yet.\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks();\n\n    // And get the first method-done. Still no updates to minimongo: we can't\n    // quiesce the doc until the second method is done.\n    stream.receive({ msg: 'updated', methods: [insertMethodId] });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks();\n\n    // More data. Not quite what we wrote. Also ignored for now.\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: MongoID.idStringify(stubWrittenId),\n      fields: { baz: 43 },\n      cleared: ['other']\n    });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'bar',\n      baz: 42\n    });\n    o.expectCallbacks();\n\n    // Second data-ready. Now everything takes effect!\n    stream.receive({ msg: 'updated', methods: [updateMethodId] });\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(stubWrittenId), {\n      _id: stubWrittenId,\n      foo: 'barb',\n      other2: 'bla',\n      baz: 43\n    });\n    o.expectCallbacks({ changed: 1 });\n\n    o.stop();\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\n    \"livedata stub - unsent methods don't block quiescence\",\n    function(test) {\n      // This test is for https://github.com/meteor/meteor/issues/555\n\n      var stream = new StubStream();\n      var conn = newConnection(stream);\n      startAndConnect(test, stream);\n\n      var collName = Random.id();\n      var coll = new Mongo.Collection(collName, { connection: conn });\n\n      conn.methods({\n        insertSomething: function() {\n          // stub write\n          coll.insert({ foo: 'bar' });\n        }\n      });\n\n      test.equal(coll.find().count(), 0);\n\n      // Call a random method (no-op)\n      conn.call('no-op', _.identity);\n      // Call a wait method\n      conn.apply('no-op', [], { wait: true }, _.identity);\n      // Call a method with a stub that writes.\n      conn.call('insertSomething', _.identity);\n\n      // Stub write is visible.\n      test.equal(coll.find({ foo: 'bar' }).count(), 1);\n      var stubWrittenId = coll.findOne({ foo: 'bar' })._id;\n\n      // first method sent\n      var firstMethodId = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'no-op',\n        params: [],\n        id: '*'\n      }).id;\n      test.equal(stream.sent.length, 0);\n\n      // ack the first method\n      stream.receive({ msg: 'updated', methods: [firstMethodId] });\n      stream.receive({ msg: 'result', id: firstMethodId });\n\n      // Wait method sent.\n      var waitMethodId = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'no-op',\n        params: [],\n        id: '*'\n      }).id;\n      test.equal(stream.sent.length, 0);\n\n      // ack the wait method\n      stream.receive({ msg: 'updated', methods: [waitMethodId] });\n      stream.receive({ msg: 'result', id: waitMethodId });\n\n      // insert method sent.\n      var insertMethodId = testGotMessage(test, stream, {\n        msg: 'method',\n        method: 'insertSomething',\n        params: [],\n        id: '*',\n        randomSeed: '*'\n      }).id;\n      test.equal(stream.sent.length, 0);\n\n      // ack the insert method\n      stream.receive({ msg: 'updated', methods: [insertMethodId] });\n      stream.receive({ msg: 'result', id: insertMethodId });\n\n      // simulation reverted.\n      test.equal(coll.find({ foo: 'bar' }).count(), 0);\n    }\n  );\n}\nTinytest.add('livedata stub - reactive resub', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  var readiedSubs = {};\n  var markAllReady = function() {\n    // synthesize a \"ready\" message in response to any \"sub\"\n    // message with an id we haven't seen before\n    _.each(stream.sent, function(msg) {\n      msg = JSON.parse(msg);\n      if (msg.msg === 'sub' && !_.has(readiedSubs, msg.id)) {\n        stream.receive({ msg: 'ready', subs: [msg.id] });\n        readiedSubs[msg.id] = true;\n      }\n    });\n  };\n\n  var fooArg = new ReactiveVar('A');\n  var fooReady = 0;\n\n  var inner;\n  var outer = Tracker.autorun(function() {\n    inner = Tracker.autorun(function() {\n      conn.subscribe('foo-sub', fooArg.get(), function() {\n        fooReady++;\n      });\n    });\n  });\n\n  markAllReady();\n  var message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo-sub', params: ['A'] });\n  test.equal(fooReady, 1);\n\n  // Rerun the inner autorun with different subscription\n  // arguments.\n  fooArg.set('B');\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo-sub', params: ['B'] });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, { msg: 'unsub' });\n  test.equal(fooReady, 2);\n\n  // Rerun inner again with same args; should be no re-sub.\n  inner.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 3);\n\n  // Rerun outer!  Should still be no re-sub even though\n  // the inner computation is stopped and a new one is\n  // started.\n  outer.invalidate();\n  test.isTrue(inner.invalidated);\n  Tracker.flush();\n  test.isFalse(inner.invalidated);\n  markAllReady();\n  test.isUndefined(stream.sent.shift());\n  test.equal(fooReady, 4);\n\n  // Change the subscription.  Now we should get an onReady.\n  fooArg.set('C');\n  Tracker.flush();\n  markAllReady();\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, { msg: 'sub', name: 'foo-sub', params: ['C'] });\n  message = JSON.parse(stream.sent.shift());\n  delete message.id;\n  test.equal(message, { msg: 'unsub' });\n  test.equal(fooReady, 5);\n});\n\nTinytest.add('livedata connection - reactive userId', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  test.equal(conn.userId(), null);\n  conn.setUserId(1337);\n  test.equal(conn.userId(), 1337);\n});\n\nTinytest.add('livedata connection - two wait methods', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var collName = Random.id();\n  var coll = new Mongo.Collection(collName, { connection: conn });\n\n  // setup method\n  conn.methods({ do_something: function(x) {} });\n\n  var responses = [];\n  conn.apply('do_something', ['one!'], function() {\n    responses.push('one');\n  });\n  var one_message = JSON.parse(stream.sent.shift());\n  test.equal(one_message.params, ['one!']);\n\n  conn.apply('do_something', ['two!'], { wait: true }, function() {\n    responses.push('two');\n  });\n  // 'two!' isn't sent yet, because it's a wait method.\n  test.equal(stream.sent.length, 0);\n\n  conn.apply('do_something', ['three!'], function() {\n    responses.push('three');\n  });\n  conn.apply('do_something', ['four!'], function() {\n    responses.push('four');\n  });\n\n  conn.apply('do_something', ['five!'], { wait: true }, function() {\n    responses.push('five');\n  });\n\n  conn.apply('do_something', ['six!'], function() {\n    responses.push('six');\n  });\n\n  // Verify that we did not send any more methods since we are still waiting on\n  // 'one!'.\n  test.equal(stream.sent.length, 0);\n\n  // Receive some data. \"one\" is not a wait method and there are no stubs, so it\n  // gets applied immediately.\n  test.equal(coll.find().count(), 0);\n  stream.receive({\n    msg: 'added',\n    collection: collName,\n    id: 'foo',\n    fields: { x: 1 }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), { _id: 'foo', x: 1 });\n\n  // Let \"one!\" finish. Both messages are required to fire the callback.\n  stream.receive({ msg: 'result', id: one_message.id });\n  test.equal(responses, []);\n  stream.receive({ msg: 'updated', methods: [one_message.id] });\n  test.equal(responses, ['one']);\n\n  // Now we've send out \"two!\".\n  var two_message = JSON.parse(stream.sent.shift());\n  test.equal(two_message.params, ['two!']);\n\n  // But still haven't sent \"three!\".\n  test.equal(stream.sent.length, 0);\n\n  // Receive more data. \"two\" is a wait method, so the data doesn't get applied\n  // yet.\n  stream.receive({\n    msg: 'changed',\n    collection: collName,\n    id: 'foo',\n    fields: { y: 3 }\n  });\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), { _id: 'foo', x: 1 });\n\n  // Let \"two!\" finish, with its end messages in the opposite order to \"one!\".\n  stream.receive({ msg: 'updated', methods: [two_message.id] });\n  test.equal(responses, ['one']);\n  test.equal(stream.sent.length, 0);\n  // data-done message is enough to allow data to be written.\n  test.equal(coll.find().count(), 1);\n  test.equal(coll.findOne('foo'), { _id: 'foo', x: 1, y: 3 });\n  stream.receive({ msg: 'result', id: two_message.id });\n  test.equal(responses, ['one', 'two']);\n\n  // Verify that we just sent \"three!\" and \"four!\" now that we got\n  // responses for \"one!\" and \"two!\"\n  test.equal(stream.sent.length, 2);\n  var three_message = JSON.parse(stream.sent.shift());\n  test.equal(three_message.params, ['three!']);\n  var four_message = JSON.parse(stream.sent.shift());\n  test.equal(four_message.params, ['four!']);\n\n  // Out of order response is OK for non-wait methods.\n  stream.receive({ msg: 'result', id: three_message.id });\n  stream.receive({ msg: 'result', id: four_message.id });\n  stream.receive({ msg: 'updated', methods: [four_message.id] });\n  test.equal(responses, ['one', 'two', 'four']);\n  test.equal(stream.sent.length, 0);\n\n  // Let three finish too.\n  stream.receive({ msg: 'updated', methods: [three_message.id] });\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Verify that we just sent \"five!\" (the next wait method).\n  test.equal(stream.sent.length, 1);\n  var five_message = JSON.parse(stream.sent.shift());\n  test.equal(five_message.params, ['five!']);\n  test.equal(responses, ['one', 'two', 'four', 'three']);\n\n  // Let five finish.\n  stream.receive({ msg: 'result', id: five_message.id });\n  stream.receive({ msg: 'updated', methods: [five_message.id] });\n  test.equal(responses, ['one', 'two', 'four', 'three', 'five']);\n\n  var six_message = JSON.parse(stream.sent.shift());\n  test.equal(six_message.params, ['six!']);\n});\n\naddReconnectTests(\n  'livedata connection - onReconnect prepends messages correctly with a wait method',\n  function(test, setOnReconnect) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    // setup method\n    conn.methods({ do_something: function(x) {} });\n\n    setOnReconnect(conn, function() {\n      conn.apply('do_something', ['reconnect zero'], _.identity);\n      conn.apply('do_something', ['reconnect one'], _.identity);\n      conn.apply('do_something', ['reconnect two'], { wait: true }, _.identity);\n      conn.apply('do_something', ['reconnect three'], _.identity);\n    });\n\n    conn.apply('do_something', ['one'], _.identity);\n    conn.apply('do_something', ['two'], { wait: true }, _.identity);\n    conn.apply('do_something', ['three'], _.identity);\n\n    // reconnect\n    stream.sent = [];\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n    // Test that we sent what we expect to send, and we're blocked on\n    // what we expect to be blocked. The subsequent logic to correctly\n    // read the wait flag is tested separately.\n    test.equal(\n      _.map(stream.sent, function(msg) {\n        return JSON.parse(msg).params[0];\n      }),\n      ['reconnect zero', 'reconnect one']\n    );\n\n    // white-box test:\n    test.equal(\n      _.map(conn._outstandingMethodBlocks, function(block) {\n        return [\n          block.wait,\n          _.map(block.methods, function(method) {\n            return method._message.params[0];\n          })\n        ];\n      }),\n      [\n        [false, ['reconnect zero', 'reconnect one']],\n        [true, ['reconnect two']],\n        [false, ['reconnect three', 'one']],\n        [true, ['two']],\n        [false, ['three']]\n      ]\n    );\n  }\n);\n\nTinytest.add('livedata connection - ping without id', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  stream.receive({ msg: 'ping' });\n  testGotMessage(test, stream, { msg: 'pong' });\n});\n\nTinytest.add('livedata connection - ping with id', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var id = Random.id();\n  stream.receive({ msg: 'ping', id: id });\n  testGotMessage(test, stream, { msg: 'pong', id: id });\n});\n\n_.each(DDPCommon.SUPPORTED_DDP_VERSIONS, function(version) {\n  Tinytest.addAsync('livedata connection - ping from ' + version, function(\n    test,\n    onComplete\n  ) {\n    var connection = new Connection(getSelfConnectionUrl(), {\n      reloadWithOutstanding: true,\n      supportedDDPVersions: [version],\n      onDDPVersionNegotiationFailure: function() {\n        test.fail();\n        onComplete();\n      },\n      onConnected: function() {\n        test.equal(connection._version, version);\n        // It's a little naughty to access _stream and _send, but it works...\n        connection._stream.on('message', function(json) {\n          var msg = JSON.parse(json);\n          var done = false;\n          if (msg.msg === 'pong') {\n            test.notEqual(version, 'pre1');\n            done = true;\n          } else if (msg.msg === 'error') {\n            // Version pre1 does not play ping-pong\n            test.equal(version, 'pre1');\n            done = true;\n          } else {\n            Meteor._debug('Got unexpected message: ' + json);\n          }\n          if (done) {\n            connection._stream.disconnect({ _permanent: true });\n            onComplete();\n          }\n        });\n        connection._send({ msg: 'ping' });\n      }\n    });\n  });\n});\n\nvar getSelfConnectionUrl = function() {\n  if (Meteor.isClient) {\n    var ddpUrl = Meteor._relativeToSiteRootUrl('/');\n    if (typeof __meteor_runtime_config__ !== 'undefined') {\n      if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)\n        ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n    }\n    return ddpUrl;\n  } else {\n    return Meteor.absoluteUrl();\n  }\n};\n\nif (Meteor.isServer) {\n  Meteor.methods({\n    reverse: function(arg) {\n      // Return something notably different from reverse.meteor.com.\n      return (\n        arg\n          .split('')\n          .reverse()\n          .join('') + ' LOCAL'\n      );\n    }\n  });\n}\n\ntestAsyncMulti('livedata connection - reconnect to a different server', [\n  function(test, expect) {\n    var self = this;\n    self.conn = DDP.connect('reverse.meteor.com');\n    pollUntil(\n      expect,\n      function() {\n        return self.conn.status().connected;\n      },\n      5000,\n      100,\n      false\n    );\n  },\n  function(test, expect) {\n    var self = this;\n    self.doTest = self.conn.status().connected;\n    if (self.doTest) {\n      self.conn.call(\n        'reverse',\n        'foo',\n        expect(function(err, res) {\n          test.equal(res, 'oof');\n        })\n      );\n    }\n  },\n  function(test, expect) {\n    var self = this;\n    if (self.doTest) {\n      self.conn.reconnect({ url: getSelfConnectionUrl() });\n      self.conn.call(\n        'reverse',\n        'bar',\n        expect(function(err, res) {\n          test.equal(res, 'rab LOCAL');\n        })\n      );\n    }\n  }\n]);\n\nTinytest.addAsync(\n  'livedata connection - version negotiation requires renegotiating',\n  function(test, onComplete) {\n    var connection = new Connection(getSelfConnectionUrl(), {\n      reloadWithOutstanding: true,\n      supportedDDPVersions: ['garbled', DDPCommon.SUPPORTED_DDP_VERSIONS[0]],\n      onDDPVersionNegotiationFailure: function() {\n        test.fail();\n        onComplete();\n      },\n      onConnected: function() {\n        test.equal(connection._version, DDPCommon.SUPPORTED_DDP_VERSIONS[0]);\n        connection._stream.disconnect({ _permanent: true });\n        onComplete();\n      }\n    });\n  }\n);\n\nTinytest.addAsync('livedata connection - version negotiation error', function(\n  test,\n  onComplete\n) {\n  var connection = new Connection(getSelfConnectionUrl(), {\n    reloadWithOutstanding: true,\n    supportedDDPVersions: ['garbled', 'more garbled'],\n    onDDPVersionNegotiationFailure: function() {\n      test.equal(connection.status().status, 'failed');\n      test.matches(\n        connection.status().reason,\n        /DDP version negotiation failed/\n      );\n      test.isFalse(connection.status().connected);\n      onComplete();\n    },\n    onConnected: function() {\n      test.fail();\n      onComplete();\n    }\n  });\n});\n\naddReconnectTests(\n  'livedata connection - onReconnect prepends messages correctly without a wait method',\n  function(test, setOnReconnect) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    // setup method\n    conn.methods({ do_something: function(x) {} });\n\n    setOnReconnect(conn, function() {\n      conn.apply('do_something', ['reconnect one'], _.identity);\n      conn.apply('do_something', ['reconnect two'], _.identity);\n      conn.apply('do_something', ['reconnect three'], _.identity);\n    });\n\n    conn.apply('do_something', ['one'], _.identity);\n    conn.apply('do_something', ['two'], { wait: true }, _.identity);\n    conn.apply('do_something', ['three'], { wait: true }, _.identity);\n    conn.apply('do_something', ['four'], _.identity);\n\n    // reconnect\n    stream.sent = [];\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n    // Test that we sent what we expect to send, and we're blocked on\n    // what we expect to be blocked. The subsequent logic to correctly\n    // read the wait flag is tested separately.\n    test.equal(\n      _.map(stream.sent, function(msg) {\n        return JSON.parse(msg).params[0];\n      }),\n      ['reconnect one', 'reconnect two', 'reconnect three', 'one']\n    );\n\n    // white-box test:\n    test.equal(\n      _.map(conn._outstandingMethodBlocks, function(block) {\n        return [\n          block.wait,\n          _.map(block.methods, function(method) {\n            return method._message.params[0];\n          })\n        ];\n      }),\n      [\n        [false, ['reconnect one', 'reconnect two', 'reconnect three', 'one']],\n        [true, ['two']],\n        [true, ['three']],\n        [false, ['four']]\n      ]\n    );\n  }\n);\n\naddReconnectTests(\n  'livedata connection - onReconnect with sent messages',\n  function(test, setOnReconnect) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n    startAndConnect(test, stream);\n\n    // setup method\n    conn.methods({ do_something: function(x) {} });\n\n    setOnReconnect(conn, function() {\n      conn.apply('do_something', ['login'], { wait: true }, _.identity);\n    });\n\n    conn.apply('do_something', ['one'], _.identity);\n\n    // initial connect\n    stream.sent = [];\n    stream.reset();\n    testGotMessage(test, stream, makeConnectMessage(conn._lastSessionId));\n\n    // Test that we sent just the login message.\n    var loginId = testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: ['login'],\n      id: '*'\n    }).id;\n\n    // we connect.\n    stream.receive({ msg: 'connected', session: Random.id() });\n    test.length(stream.sent, 0);\n\n    // login got result (but not yet data)\n    stream.receive({ msg: 'result', id: loginId, result: 'foo' });\n    test.length(stream.sent, 0);\n\n    // login got data. now we send next method.\n    stream.receive({ msg: 'updated', methods: [loginId] });\n\n    testGotMessage(test, stream, {\n      msg: 'method',\n      method: 'do_something',\n      params: ['one'],\n      id: '*'\n    }).id;\n  }\n);\n\naddReconnectTests('livedata stub - reconnect double wait method', function(\n  test,\n  setOnReconnect\n) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n  startAndConnect(test, stream);\n\n  var output = [];\n  setOnReconnect(conn, function() {\n    conn.apply('reconnectMethod', [], { wait: true }, function(err, result) {\n      output.push('reconnect');\n    });\n  });\n\n  conn.apply('halfwayMethod', [], { wait: true }, function(err, result) {\n    output.push('halfway');\n  });\n\n  test.equal(output, []);\n  // Method sent.\n  var halfwayId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'halfwayMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.equal(stream.sent.length, 0);\n\n  // Get the result. This means it will not be resent.\n  stream.receive({ msg: 'result', id: halfwayId, result: 'bla' });\n  // Callback not called.\n  test.equal(output, []);\n\n  // Reset stream. halfwayMethod does NOT get resent, but reconnectMethod does!\n  // Reconnect quiescence happens when reconnectMethod is done.\n  stream.reset();\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  var reconnectId = testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'reconnectMethod',\n    params: [],\n    id: '*'\n  }).id;\n  test.length(stream.sent, 0);\n  // Still holding out hope for session resumption, so no callbacks yet.\n  test.equal(output, []);\n\n  // Receive 'connected', but reconnect quiescence is blocking on\n  // reconnectMethod.\n  stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n  test.equal(output, []);\n\n  // Data-done for reconnectMethod. This gets us to reconnect quiescence, so\n  // halfwayMethod's callback fires. reconnectMethod's is still waiting on its\n  // result.\n  stream.receive({ msg: 'updated', methods: [reconnectId] });\n  test.equal(output.shift(), 'halfway');\n  test.equal(output, []);\n\n  // Get result of reconnectMethod. Its callback fires.\n  stream.receive({ msg: 'result', id: reconnectId, result: 'foo' });\n  test.equal(output.shift(), 'reconnect');\n  test.equal(output, []);\n\n  // Call another method. It should be delivered immediately. This is a\n  // regression test for a case where it never got delivered because there was\n  // an empty block in _outstandingMethodBlocks blocking it from being sent.\n  conn.call('lastMethod', _.identity);\n  testGotMessage(test, stream, {\n    msg: 'method',\n    method: 'lastMethod',\n    params: [],\n    id: '*'\n  });\n});\n\nTinytest.add('livedata stub - subscribe errors', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var onReadyFired = false;\n  var subErrorInStopped = null;\n  var subErrorInError = null;\n\n  conn.subscribe('unknownSub', {\n    onReady: function() {\n      onReadyFired = true;\n    },\n\n    // We now have two ways to get the error from a subscription:\n    // 1. onStop, which is called no matter what when the subscription is\n    //    stopped (a lifecycle callback)\n    // 2. onError, which is deprecated and is called only if there is an\n    //    error\n    onStop: function(error) {\n      subErrorInStopped = error;\n    },\n    onError: function(error) {\n      subErrorInError = error;\n    }\n  });\n\n  test.isFalse(onReadyFired);\n  test.equal(subErrorInStopped, null);\n\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n  test.equal(subErrorInError, null);\n\n  var subMessage = JSON.parse(stream.sent.shift());\n  test.equal(subMessage, {\n    msg: 'sub',\n    name: 'unknownSub',\n    params: [],\n    id: subMessage.id\n  });\n\n  // Reject the sub.\n  stream.receive({\n    msg: 'nosub',\n    id: subMessage.id,\n    error: new Meteor.Error(404, 'Subscription not found')\n  });\n  test.isFalse(onReadyFired);\n\n  // Check the error passed to the stopped callback was correct\n  test.instanceOf(subErrorInStopped, Meteor.Error);\n  test.equal(subErrorInStopped.error, 404);\n  test.equal(subErrorInStopped.reason, 'Subscription not found');\n\n  // Check the error passed to the error callback was correct\n  // XXX COMPAT WITH 1.0.3.1 #errorCallback\n  test.instanceOf(subErrorInError, Meteor.Error);\n  test.equal(subErrorInError.error, 404);\n  test.equal(subErrorInError.reason, 'Subscription not found');\n\n  // stream reset: reconnect!\n  stream.reset();\n  // We send a connect.\n  testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n  // We should NOT re-sub to the sub, because we processed the error.\n  test.length(stream.sent, 0);\n  test.isFalse(onReadyFired);\n});\n\nTinytest.add('livedata stub - subscribe stop', function(test) {\n  var stream = new StubStream();\n  var conn = newConnection(stream);\n\n  startAndConnect(test, stream);\n\n  // subscribe\n  var onReadyFired = false;\n  var onStopFired = false;\n  var subErrorInStopped = null;\n\n  var sub = conn.subscribe('my_data', {\n    onStop: function(error) {\n      onStopFired = true;\n      subErrorInStopped = error;\n    }\n  });\n\n  test.equal(subErrorInStopped, null);\n\n  sub.stop();\n\n  test.isTrue(onStopFired);\n  test.equal(subErrorInStopped, undefined);\n});\n\nif (Meteor.isClient) {\n  Tinytest.add('livedata stub - stubs before connected', function(test) {\n    var stream = new StubStream();\n    var conn = newConnection(stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, { connection: conn });\n\n    // Start and send \"connect\", but DON'T get 'connected' quite yet.\n    stream.reset(); // initial connection start.\n\n    testGotMessage(test, stream, makeConnectMessage());\n    test.length(stream.sent, 0);\n\n    // Insert a document. The stub updates \"conn\" directly.\n    coll.insert({ _id: 'foo', bar: 42 }, _.identity);\n    test.equal(coll.find().count(), 1);\n    test.equal(coll.findOne(), { _id: 'foo', bar: 42 });\n    // It also sends the method message.\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.isUndefined(methodMessage.randomSeed);\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: '/' + collName + '/insert',\n      params: [{ _id: 'foo', bar: 42 }],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0);\n\n    // Now receive a connected message. This should not clear the\n    // _documentsWrittenByStub state!\n    stream.receive({ msg: 'connected', session: SESSION_ID });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 1);\n\n    // Now receive the \"updated\" message for the method. This should revert the\n    // insert.\n    stream.receive({ msg: 'updated', methods: [methodMessage.id] });\n    test.length(stream.sent, 0);\n    test.equal(coll.find().count(), 0);\n  });\n}\n\nif (Meteor.isClient) {\n  Tinytest.add(\n    'livedata stub - method call between reset and quiescence',\n    function(test) {\n      var stream = new StubStream();\n      var conn = newConnection(stream);\n\n      startAndConnect(test, stream);\n\n      var collName = Random.id();\n      var coll = new Mongo.Collection(collName, { connection: conn });\n\n      conn.methods({\n        update_value: function() {\n          coll.update('aaa', { value: 222 });\n        }\n      });\n\n      // Set up test subscription.\n      var sub = conn.subscribe('test_data');\n      var subMessage = JSON.parse(stream.sent.shift());\n      test.equal(subMessage, {\n        msg: 'sub',\n        name: 'test_data',\n        params: [],\n        id: subMessage.id\n      });\n      test.length(stream.sent, 0);\n\n      var subDocMessage = {\n        msg: 'added',\n        collection: collName,\n        id: 'aaa',\n        fields: { value: 111 }\n      };\n\n      var subReadyMessage = { msg: 'ready', subs: [subMessage.id] };\n\n      stream.receive(subDocMessage);\n      stream.receive(subReadyMessage);\n      test.isTrue(coll.findOne('aaa').value == 111);\n\n      // Initiate reconnect.\n      stream.reset();\n      testGotMessage(test, stream, makeConnectMessage(SESSION_ID));\n      testGotMessage(test, stream, subMessage);\n      stream.receive({ msg: 'connected', session: SESSION_ID + 1 });\n\n      // Now in reconnect, can still see the document.\n      test.isTrue(coll.findOne('aaa').value == 111);\n\n      conn.call('update_value');\n\n      // Observe the stub-written value.\n      test.isTrue(coll.findOne('aaa').value == 222);\n\n      var methodMessage = JSON.parse(stream.sent.shift());\n      test.equal(methodMessage, {\n        msg: 'method',\n        method: 'update_value',\n        params: [],\n        id: methodMessage.id\n      });\n      test.length(stream.sent, 0);\n\n      stream.receive(subDocMessage);\n      stream.receive(subReadyMessage);\n\n      // By this point quiescence is reached and stores have been reset.\n\n      // The stub-written value is still there.\n      test.isTrue(coll.findOne('aaa').value == 222);\n\n      stream.receive({\n        msg: 'changed',\n        collection: collName,\n        id: 'aaa',\n        fields: { value: 333 }\n      });\n      stream.receive({ msg: 'updated', methods: [methodMessage.id] });\n      stream.receive({ msg: 'result', id: methodMessage.id, result: null });\n\n      // Server wrote a different value, make sure it's visible now.\n      test.isTrue(coll.findOne('aaa').value == 333);\n    }\n  );\n\n  Tinytest.add('livedata stub - buffering and methods interaction', function(\n    test\n  ) {\n    var stream = new StubStream();\n    var conn = newConnection(stream, {\n      // A very high values so that all messages are effectively buffered.\n      bufferedWritesInterval: 10000,\n      bufferedWritesMaxAge: 10000\n    });\n\n    startAndConnect(test, stream);\n\n    var collName = Random.id();\n    var coll = new Mongo.Collection(collName, { connection: conn });\n\n    conn.methods({\n      update_value: function() {\n        const value = coll.findOne('aaa').subscription;\n        // Method should have access to the latest value of the collection.\n        coll.update('aaa', { $set: { method: value + 110 } });\n      }\n    });\n\n    // Set up test subscription.\n    var sub = conn.subscribe('test_data');\n    var subMessage = JSON.parse(stream.sent.shift());\n    test.equal(subMessage, {\n      msg: 'sub',\n      name: 'test_data',\n      params: [],\n      id: subMessage.id\n    });\n    test.length(stream.sent, 0);\n\n    var subDocMessage = {\n      msg: 'added',\n      collection: collName,\n      id: 'aaa',\n      fields: { subscription: 111 }\n    };\n\n    var subReadyMessage = { msg: 'ready', subs: [subMessage.id] };\n\n    stream.receive(subDocMessage);\n    stream.receive(subReadyMessage);\n    test.equal(coll.findOne('aaa').subscription, 111);\n\n    var subDocChangeMessage = {\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: { subscription: 112 }\n    };\n\n    stream.receive(subDocChangeMessage);\n    // Still 111 because buffer has not been flushed.\n    test.equal(coll.findOne('aaa').subscription, 111);\n\n    // Call updates the stub.\n    conn.call('update_value');\n\n    // Observe the stub-written value.\n    test.equal(coll.findOne('aaa').method, 222);\n    // subscription field is updated to the latest value\n    // because of the method call.\n    test.equal(coll.findOne('aaa').subscription, 112);\n\n    var methodMessage = JSON.parse(stream.sent.shift());\n    test.equal(methodMessage, {\n      msg: 'method',\n      method: 'update_value',\n      params: [],\n      id: methodMessage.id\n    });\n    test.length(stream.sent, 0);\n\n    // \"Server-side\" change from the method arrives and method returns.\n    // With potentially fixed value for method field, if stub didn't\n    // use 112 as the subscription field value.\n    stream.receive({\n      msg: 'changed',\n      collection: collName,\n      id: 'aaa',\n      fields: { method: 222 }\n    });\n    stream.receive({ msg: 'updated', methods: [methodMessage.id] });\n    stream.receive({ msg: 'result', id: methodMessage.id, result: null });\n\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n\n    // Buffer should already be flushed because of a non-update message.\n    // And after a flush we really want subscription field to be 112.\n    conn._flushBufferedWrites();\n    test.equal(coll.findOne('aaa').method, 222);\n    test.equal(coll.findOne('aaa').subscription, 112);\n  });\n}\n\n// XXX also test:\n// - reconnect, with session resume.\n// - restart on update flag\n// - on_update event\n// - reloading when the app changes, including session migration\n"]},"sourceType":"script","hash":"d21738f46932ebcc6f7f0d9d380764b503d6d3d2"}
