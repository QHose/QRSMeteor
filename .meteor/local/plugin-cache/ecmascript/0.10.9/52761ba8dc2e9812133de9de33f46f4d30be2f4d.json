{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/mongo/polling_observe_driver.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/mongo/polling_observe_driver.js","filename":"packages/mongo/polling_observe_driver.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","generatorOpts":{"filename":"packages/mongo/polling_observe_driver.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/polling_observe_driver.js"}},"code":"PollingObserveDriver = function (options) {\n  var self = this;\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription); // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n\n  self._results = null; // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n\n  self._ensurePollIsScheduled = _.throttle(self._unthrottledEnsurePollIsScheduled, self._cursorDescription.options.pollingThrottleMs || 50\n  /* ms */\n  ); // XXX figure out if we still need a queue\n\n  self._taskQueue = new Meteor._SynchronousQueue();\n  var listenersHandle = listenAll(self._cursorDescription, function (notification) {\n    // When someone does a transaction that might affect us, schedule a poll\n    // of the database. If that transaction happens inside of a write fence,\n    // block the fence until we've polled and notified observers.\n    var fence = DDPServer._CurrentWriteFence.get();\n\n    if (fence) self._pendingWrites.push(fence.beginWrite()); // Ensure a poll is scheduled... but if we already know that one is,\n    // don't hit the throttled _ensurePollIsScheduled function (which might\n    // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n\n    if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled();\n  });\n\n  self._stopCallbacks.push(function () {\n    listenersHandle.stop();\n  }); // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n\n\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval = self._cursorDescription.options.pollingIntervalMs || self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n    10 * 1000;\n    var intervalHandle = Meteor.setInterval(_.bind(self._ensurePollIsScheduled, self), pollingInterval);\n\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  } // Make sure we actually poll soon!\n\n\n  self._unthrottledEnsurePollIsScheduled();\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0) return;\n    ++self._pollsScheduledButNotStarted;\n\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function () {\n    var self = this; // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n\n    ++self._pollsScheduledButNotStarted; // Now block until all currently running or scheduled polls are done.\n\n    self._taskQueue.runTask(function () {}); // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n\n\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function () {\n    var self = this; // We should be in the same state as in the end of _suspendPolling.\n\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted); // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n    if (self._stopped) return;\n    var first = false;\n    var newResults;\n    var oldResults = self._results;\n\n    if (!oldResults) {\n      first = true; // XXX maybe use OrderedDict instead?\n\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap();\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback(); // Save the list of pending writes which this round will commit.\n\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = []; // Get the new query results. (This yields.)\n\n    try {\n      newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof e.code === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n\n        return;\n      } // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n\n\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n\n      Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription), e);\n\n      return;\n    } // Run diffs.\n\n\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer);\n    } // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n\n\n    if (first) self._multiplexer.ready(); // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n\n    self._results = newResults; // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n\n    _.each(self._stopCallbacks, function (c) {\n      c();\n    }); // Release any write fences that are waiting on us.\n\n\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});","map":{"version":3,"sources":["packages/mongo/polling_observe_driver.js"],"names":["PollingObserveDriver","options","self","_cursorDescription","cursorDescription","_mongoHandle","mongoHandle","_ordered","ordered","_multiplexer","multiplexer","_stopCallbacks","_stopped","_synchronousCursor","_createSynchronousCursor","_results","_pollsScheduledButNotStarted","_pendingWrites","_ensurePollIsScheduled","_","throttle","_unthrottledEnsurePollIsScheduled","pollingThrottleMs","_taskQueue","Meteor","_SynchronousQueue","listenersHandle","listenAll","notification","fence","DDPServer","_CurrentWriteFence","get","push","beginWrite","stop","_testOnlyPollCallback","pollingInterval","pollingIntervalMs","_pollingInterval","intervalHandle","setInterval","bind","clearInterval","Package","Facts","incrementServerFact","extend","prototype","queueTask","_pollMongo","_suspendPolling","runTask","Error","_resumePolling","first","newResults","oldResults","LocalCollection","_IdMap","writesForCycle","getRawObjects","e","code","queryError","JSON","stringify","message","Array","apply","_debug","_diffQueryChanges","ready","onFlush","each","w","committed","c"],"mappings":"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","sourcesContent":["PollingObserveDriver = function (options) {\n  var self = this;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(\n    self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = _.throttle(\n    self._unthrottledEnsurePollIsScheduled,\n    self._cursorDescription.options.pollingThrottleMs || 50 /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._SynchronousQueue();\n\n  var listenersHandle = listenAll(\n    self._cursorDescription, function (notification) {\n      // When someone does a transaction that might affect us, schedule a poll\n      // of the database. If that transaction happens inside of a write fence,\n      // block the fence until we've polled and notified observers.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (fence)\n        self._pendingWrites.push(fence.beginWrite());\n      // Ensure a poll is scheduled... but if we already know that one is,\n      // don't hit the throttled _ensurePollIsScheduled function (which might\n      // lead to us calling it unnecessarily in <pollingThrottleMs> ms).\n      if (self._pollsScheduledButNotStarted === 0)\n        self._ensurePollIsScheduled();\n    }\n  );\n  self._stopCallbacks.push(function () { listenersHandle.stop(); });\n\n  // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval =\n          self._cursorDescription.options.pollingIntervalMs ||\n          self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n          10 * 1000;\n    var intervalHandle = Meteor.setInterval(\n      _.bind(self._ensurePollIsScheduled, self), pollingInterval);\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  }\n\n  // Make sure we actually poll soon!\n  self._unthrottledEnsurePollIsScheduled();\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0)\n      return;\n    ++self._pollsScheduledButNotStarted;\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function() {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function() {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function() {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n\n    if (self._stopped)\n      return;\n\n    var first = false;\n    var newResults;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof(e.code) === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(\n          new Error(\n            \"Exception while polling query \" +\n              JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" +\n                    JSON.stringify(self._cursorDescription), e);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(\n        self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first)\n      self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    _.each(self._stopCallbacks, function (c) { c(); });\n    // Release any write fences that are waiting on us.\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});\n"]},"sourceType":"script","hash":"52761ba8dc2e9812133de9de33f46f4d30be2f4d"}
