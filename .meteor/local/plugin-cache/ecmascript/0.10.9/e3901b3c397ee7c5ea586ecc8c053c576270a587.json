{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"imports/api/server/QPSFunctions.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"imports/api/server/QPSFunctions.js","filename":"imports/api/server/QPSFunctions.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"imports/api/server/QPSFunctions.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/api/server/QPSFunctions.js"}},"code":"const module1 = module;\nmodule1.export({\n  createVirtualProxies: () => createVirtualProxies,\n  getVirtualProxies: () => getVirtualProxies,\n  logoutUser: () => logoutUser,\n  getRedirectURL: () => getRedirectURL\n});\nlet Meteor;\nmodule1.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Customers, dummyCustomers, dummyCustomer;\nmodule1.watch(require(\"/imports/api/customers\"), {\n  Customers(v) {\n    Customers = v;\n  },\n\n  dummyCustomers(v) {\n    dummyCustomers = v;\n  },\n\n  dummyCustomer(v) {\n    dummyCustomer = v;\n  }\n\n}, 1);\nlet REST_Log;\nmodule1.watch(require(\"/imports/api/APILogs\"), {\n  REST_Log(v) {\n    REST_Log = v;\n  }\n\n}, 2);\nlet gitHubLinks;\nmodule1.watch(require(\"/imports/ui/UIHelpers\"), {\n  gitHubLinks(v) {\n    gitHubLinks = v;\n  }\n\n}, 3);\nlet senseConfig, authHeaders, qliksrv, configCerticates, validateJSON;\nmodule1.watch(require(\"/imports/api/config.js\"), {\n  senseConfig(v) {\n    senseConfig = v;\n  },\n\n  authHeaders(v) {\n    authHeaders = v;\n  },\n\n  qrsSrv(v) {\n    qliksrv = v;\n  },\n\n  configCerticates(v) {\n    configCerticates = v;\n  },\n\n  validateJSON(v) {\n    validateJSON = v;\n  }\n\n}, 4);\nlet lodash;\nmodule1.watch(require(\"lodash\"), {\n  default(v) {\n    lodash = v;\n  }\n\n}, 5);\n\nvar fs = require(\"fs-extra\");\n\nconst path = require(\"path\");\n\nvar os = require(\"os\");\n\nvar ip = require(\"ip\"); // const token = require(\"./token\");\n\n\nconst {\n  v4: uuidv4\n} = require(\"uuid\"); //\n// ─── IMPORT CONFIG FOR QLIK SENSE QRS ───────────────────────────────────────────\n//\n\n\n_ = lodash; //\n// ─── CREATE VIRTUAL PROXIES ─────────────────────────────────────────────────────\n//\n// http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-Virtual-Proxy-Create.htm\n\nfunction createVirtualProxies() {\n  return Promise.asyncApply(() => {\n    console.log(\"------------------------------------\");\n    console.log(\"CREATE VIRTUAL PROXIES\");\n    console.log(\"------------------------------------\");\n    var file = path.join(Meteor.settings.broker.automationBaseFolder, \"proxy\", \"import\", \"virtualProxySettings.json\");\n\n    try {\n      // READ THE PROXY FILE\n      var proxySettings = Promise.await(fs.readJson(file));\n\n      try {\n        validateJSON(proxySettings);\n      } catch (err) {\n        throw new Error(\"Cant read the virtual proxy definitions file: virtualProxySettings.json in your automation folder\");\n      } //FOR EACH PROXY FOUND IN THE INPUTFILE (vpToCreate), CREATE IT IN SENSE. We also put the current ip/host in the list of sense since in most cases this tool runs on the same machine as sense.\n\n\n      for (var vpToCreate of proxySettings) {\n        if (vpToCreate.websocketCrossOriginWhiteList) {\n          vpToCreate.websocketCrossOriginWhiteList.push(Meteor.settings.public.qlikSenseHost);\n          vpToCreate.websocketCrossOriginWhiteList.push(ip.address());\n          vpToCreate.websocketCrossOriginWhiteList.push(os.hostname());\n        }\n\n        var existingProxies = getVirtualProxies(); // CHECK IF VIRT. PROXY ALREADY EXISTS IN SENSE\n\n        var found = existingProxies.some(function (existingVP) {\n          return existingVP.prefix === vpToCreate.prefix;\n        });\n\n        if (!found) {\n          var virtualProxy = createVirtualProxy(vpToCreate); // THE VIRTUAL PROXY HAS BEEN CREATED, NOW LINK IT TO THE CENTRAL PROXY\n\n          linkVirtualProxyToProxy(virtualProxy);\n        } else {\n          console.log(\"Virtual proxy \" + vpToCreate.prefix + \" already existed. We do not update existing ones.\");\n        }\n      }\n    } catch (err) {\n      console.error(err);\n      throw new Error(\"unable to create virtual proxies\", err);\n    }\n\n    function createVirtualProxy(virtualProxy) {\n      // get id of local node so we can link the virtual proxy to a load balancing node\n      virtualProxy.loadBalancingServerNodes = [{\n        id: getServerNodeConfiguration().id\n      }];\n\n      try {\n        check(virtualProxy, Object);\n        console.log(\"------CREATE VIRTUAL PROXY: \", virtualProxy.prefix);\n        var request = qliksrv + \"/qrs/virtualproxyconfig/\";\n        response = HTTP.call(\"POST\", request, {\n          params: {\n            xrfkey: senseConfig.xrfkey\n          },\n          npmRequestOptions: configCerticates,\n          data: virtualProxy\n        });\n        return response.data;\n      } catch (err) {\n        console.error(\"create virtual proxy failed\", err);\n      } // }\n\n    }\n  });\n}\n\n// http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-Virtual-Proxy-Link.htm\nfunction linkVirtualProxyToProxy(virtualProxy) {\n  // console.log('linkVirtualProxyToProxy', virtualProxy.id);\n  // GET ID OF PROXY ON THIS HOST\n  var proxyId = getProxyId(); // GET THE CONFIG OF THE PROXY (WHICH CONTAINS VIRTUAL PROXIES)\n\n  var proxyConfig = getProxyServiceConfiguration(proxyId); // ADD THE NEW VIRTUAL PROXY TO THE EXISTING PROXY LIST\n\n  proxyConfig.settings.virtualProxies.push(virtualProxy);\n\n  try {\n    check(Meteor.settings.public.qlikSensePort, Number);\n    check(Meteor.settings.public.qlikSensePortSecure, Number);\n    check(Meteor.settings.broker.qlikSense.proxyAllowHTTP, Boolean);\n  } catch (error) {\n    console.error(\"settings file incomplete, your are missing the qliksenseport, qlikSensePortSecure or proxyAllowHTTP\");\n  } //UPDATE SOME PROXY SETTINGS\n\n\n  console.log(\"UPDATE SOME PROXY SETTINGS...\");\n  proxyConfig.settings.unencryptedListenPort = Meteor.settings.public.qlikSensePort; //HTTP\n\n  proxyConfig.settings.listenPort = Meteor.settings.public.qlikSensePortSecure; //HTTPS\n\n  proxyConfig.settings.allowHttp = Meteor.settings.broker.qlikSense.proxyAllowHTTP; //OVERWRITE THE SETTINGS WITH THE COMPLETE UPDATED OBJECT.\n\n  updateProxy(proxyId, proxyConfig);\n}\n\nfunction updateProxy(proxyId, proxyConfig) {\n  try {\n    check(proxyId, String);\n    check(proxyConfig, Object); // console.log('proxyConfig', proxyConfig.settings.virtualProxies)\n\n    var request = qliksrv + \"/qrs/proxyservice/\" + proxyId;\n    response = HTTP.call(\"PUT\", request, {\n      params: {\n        xrfkey: senseConfig.xrfkey\n      },\n      npmRequestOptions: configCerticates,\n      data: proxyConfig\n    });\n  } catch (err) {\n    console.error(\"update proxy failed\", err);\n  }\n}\n\nfunction getProxyId() {\n  try {\n    var request = qliksrv + \"/qrs/proxyservice/?xrfkey=\" + senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates\n    });\n    return response.data[0].id;\n  } catch (err) {\n    console.error(\"get proxyId failed\", err);\n  }\n}\n\nfunction getProxyServiceConfiguration(proxyId) {\n  try {\n    check(proxyId, String);\n    var request = qliksrv + \"/qrs/proxyservice/\" + proxyId + \"?xrfkey=\" + senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates\n    }); //SAVE RPOXY CONFIG TO THE EXPORT FOLDER\n\n    var file = path.join(Meteor.settings.broker.automationBaseFolder, \"proxy\", \"export\", \"proxyServiceConfiguration.json\");\n    fs.outputFile(file, JSON.stringify(response.data, null, 2), \"utf-8\");\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n}\n\nfunction getVirtualProxies() {\n  // console.log('--------------------------GET VIRTUAL PROXIES');//\n  try {\n    var request = qliksrv + \"/qrs/virtualproxyconfig/\";\n    response = HTTP.call(\"GET\", request, {\n      params: {\n        xrfkey: senseConfig.xrfkey\n      },\n      npmRequestOptions: configCerticates\n    });\n    var file = path.join(Meteor.settings.broker.automationBaseFolder, \"proxy\", \"export\", \"virtualProxyServiceConfiguration.json\"); // SAVE PROXY FILE TO DISK\n\n    fs.outputFile(file, JSON.stringify(response.data, null, 2), \"utf-8\");\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n}\n\n// function getCentralProxy() {\n//     console.log('getCentralProxy: GET /qrs/ServerNodeConfiguration?filter=isCentral')\n// }\nfunction getServerNodeConfiguration() {\n  try {\n    var request = qliksrv + \"/qrs/servernodeconfiguration/local?xrfkey=\" + senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates\n    });\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n} //\n// ─── METEOR METHODS ─────────────────────────────────────────────────────────────\n//\n\n\nMeteor.methods({\n  currentlyLoggedInUser() {\n    // console.log(\"Meteor will now look which user is currently logged in, and request a ticket for this ID, and add his group memberships.\");\n    var call = {};\n    call.action = \"STEP 3: Server received request to create ticket\";\n    call.request = \"Meteor server received a incoming method call from the browser. The meteor server will now look which user is currently logged in, and create a ticket for this ID, and add his group memberships.\";\n    REST_Log(call, Meteor.userId()); // first find the customers that have a logged in users (mongo returns a complete document)\n\n    var customer = Customers.findOne({\n      generationUserId: Meteor.userId(),\n      \"users.currentlyLoggedIn\": true\n    }); // console.log('In our local database we can find the customer with the currentlyLoggedIn set to true for user: ' + loggedInUser + ', the customer which contains the user that the user selected with the dropdown: ', customer);\n    // now we have the document, we can look in the array of users, to find the one that is logged in.\n\n    var user;\n\n    if (!customer) {\n      // if no user is selected, just insert john as a dummy\n      // const error = 'You have not selected a user you want to simulate the Single Sign on with. For demo purposes we now selected John for you. You can also select your own user in step 4 of the SaaS demo';\n      var response = {}; // console.log('dummyCustomer :', dummyCustomer);\n\n      response.user = dummyCustomer.user;\n      response.customer = dummyCustomer; // throw new Meteor.Warning('No user', error);\n    } else {\n      var user = _.find(customer.users, {\n        currentlyLoggedIn: true\n      });\n\n      var response = {};\n      response.user = user;\n      response.customer = customer;\n    } // console.log('the response is: ', response);\n\n\n    return response;\n  },\n\n  getRedirectUrl(proxyRestUri, targetId, loggedInUser) {\n    var response = Meteor.call(\"currentlyLoggedInUser\");\n    var customer = response.customer;\n    var user = response.user;\n    console.log(\"UserID currently logged in in the demo platform: \" + loggedInUser + \". Meteor server side thinks the meteor.userId is \" + Meteor.userId() + \". We use this as the UDC name\"); // Create a paspoort (ticket) request: user directory, user identity and attributes\n\n    var passport = {\n      UserDirectory: Meteor.userId(),\n      // Specify a dummy value to ensure userID's are unique E.g. \"Dummy\", or in my case, I use the logged in user, so each user who uses the demo can logout only his users, or the name of the customer domain if you need a Virtual proxy per customer\n      UserId: user.name,\n      // the current user that we are going to login with\n      Attributes: [{\n        group: customer.name.toUpperCase()\n      }, // attributes supply the group membership from the source system to Qlik Sense\n      {\n        group: user.country.toUpperCase()\n      }, {\n        group: user.group.toUpperCase()\n      }]\n    };\n    console.log('Request ticket for this user passport\": ', passport); // logging only\n\n    var call = {};\n    call.action = \"STEP 4: User and group information received from customer database, now we can request a ticket\";\n    call.url = gitHubLinks.createpassport;\n    call.request = 'Request ticket for this user and his groups (an array of values which you can use in the security rules): \": ' + JSON.stringify(passport);\n    REST_Log(call, Meteor.userId());\n    return getRedirectURL(passport, proxyRestUri, targetId, Meteor.userId());\n  },\n\n  getTicketNumber(userProperties, virtualProxy) {\n    // only get a ticket number for a SPECIFIC virtual proxy\n    console.log('getTicketNumber using properties:');\n    console.log('virtualProxy', virtualProxy);\n    console.log('userProperties', userProperties);\n\n    try {\n      check(userProperties.group, String);\n      check(virtualProxy, String);\n      check(Meteor.userId(), String);\n    } catch (err) {\n      throw new Meteor.Error(\"Failed to login into Qlik Sense via a ticket\", \"We could not request a ticket because the userId or groups (technical, generic) or virtual proxy, or UDC (your Meteor userId, are you not yet logged into Meteor?) are not provided\");\n    }\n\n    var passport = {\n      UserDirectory: Meteor.userId(),\n      // Specify a dummy value to ensure userID's are unique E.g. \"Dummy\", or in my case, I use the logged in user, so each user who uses the demo can logout only his users, or the name of the customer domain if you need a Virtual proxy per customer\n      UserId: Meteor.userId(),\n      // the current user that we are going to login with\n      Attributes: [{\n        group: \"slideGenerator\"\n      }, // attributes supply the group membership from the source system to Qlik Sense\n      {\n        group: userProperties.group\n      }, {\n        group: \"ITALY\"\n      }]\n    }; //get the ticket number and return it to the client\n\n    return Meteor.call(\"requestTicketWithPassport\", virtualProxy, passport);\n  },\n\n  //only for demo purposes! never supply groups from the client...\n  requestTicketWithPassport(virtualProxy, passport) {\n    console.log('getTicketNumber passport', passport); // var rootCas = require(\"ssl-root-cas\").create();//\n    // default for all https requests\n    // (whether using https directly, request, or another module)\n    // require(\"https\").globalAgent.options.ca = rootCas;\n    // http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/ProxyServiceAPI/Content/ProxyServiceAPI/ProxyServiceAPI-ProxyServiceAPI-Authentication-Ticket-Add.htm\n\n    var proxyGetTicketURI = \"https://\" + senseConfig.SenseServerInternalLanIP + \":\" + Meteor.settings.private.proxyPort + \"/qps/\" + virtualProxy + \"/ticket\"; // \"proxyRestUri\": \"https://ip-172-31-22-22.eu-central-1.compute.internal:4243/qps/meteor/\",\n    // console.log('proxyGetTicketURI', proxyGetTicketURI)\n\n    try {\n      var response = HTTP.call(\"POST\", proxyGetTicketURI, {\n        npmRequestOptions: configCerticates,\n        headers: authHeaders,\n        params: {\n          xrfkey: senseConfig.xrfkey\n        },\n        data: passport // the user and group info for which we want to create a ticket\n\n      });\n    } catch (err) {\n      console.error(\"REST call to request a ticket failed. PLEASE EXPORT AND IMPORT CERTIFICATES FROM QMC FOR THE CORRECT HOSTNAME\", err);\n      throw new Meteor.Error(\"Request ticket failed\", err.message);\n    }\n\n    return response.data.Ticket;\n  },\n\n  //https://qlik.dev/authenticate/jwt/create-signed-tokens-for-jwt-authorization\n  getJWTToken(passport) {\n    console.log(\"get JWT with passport\", passport);\n\n    try {\n      const uuid = uuidv4();\n      const sub = `sub_${uuid}`;\n      const name = passport.UserId;\n      const email = `${uuid}@demo.anon`;\n      const groups = passport.Groups;\n      const genT = token.generate(sub, name, email, groups);\n      console.log(\"🚀 ~ file: QPSFunctions.js:423 ~ getJWTToken ~ genT:\", genT);\n      return genT;\n    } catch (err) {\n      console.error(\"unable to generate JWT token, did you supply the correct public.pem and private.pem in the dir: \" + Meteor.settings.private.certificatesDirectory, err);\n      throw new Meteor.Error(\"generate jwt token failed\", err.message);\n    }\n  },\n\n  resetLoggedInUser() {\n    // console.log(\"***Method resetLoggedInUsers\");\n    // console.log('call the QPS logout api, to invalidate the session cookie for each user in our local database');\n    // reset the local database. set all users to not logged in. We need this code because we do a simulation of the login and not a real end user login.\n    Customers.find({\n      generationUserId: Meteor.userId()\n    }).forEach(function (customer) {\n      var updatedUsers = _.map(customer.users, function (user) {\n        if (user) {\n          user.currentlyLoggedIn = false;\n        } // and just logout everybody in the user list\n\n\n        logoutUser(Meteor.userId(), user.name);\n        return user;\n      });\n\n      Customers.update(customer._id, {\n        $set: {\n          users: updatedUsers\n        }\n      });\n    }); // logoutUser(Meteor.userId(), Meteor.userId()); //logout the user for the slide generator\n  },\n\n  logoutPresentationUser(UDC, name) {\n    console.log(\"logoutPresentationUser(UDC, name)\", UDC, name);\n    logoutUser(UDC, name, Meteor.settings.public.slideGenerator.virtualProxy);\n  },\n\n  logoutVirtualProxyClientUsageUser(UDC, name) {\n    console.log(\"logout virtual proxy client usuage User(UDC, name)\", UDC, name);\n    logoutUser(UDC, name, Meteor.settings.public.virtualProxyClientUsage);\n  },\n\n  simulateUserLogin(name) {\n    check(name, String);\n    Meteor.call(\"resetLoggedInUser\"); // console.log('*** Reset all logged in user done, now write in our local database the name for the current simulated user: generationUserId: ' + Meteor.userId() + ' & users.name:' + name);\n\n    var query = [{\n      generationUserId: Meteor.userId(),\n      \"users.name\": name\n    }, {\n      $set: {\n        \"users.$.currentlyLoggedIn\": true\n      }\n    }];\n    Customers.update({\n      generationUserId: Meteor.userId(),\n      \"users.name\": name\n    }, {\n      $set: {\n        \"users.$.currentlyLoggedIn\": true\n      }\n    }, {}, function (error, numberAffectedDocuments) {\n      if (numberAffectedDocuments === 0) {\n        // if nothing is updated, insert some dummy customers\n        // console.log('simulateUserLogin numberAffectedDocuments: ', numberAffectedDocuments);\n        // name does not yet exist in the customers created by the current demo user. So insert our dummy customers.numberAffectedDocuments\n        insertDummyCustomers(Meteor.userId());\n        Customers.update({\n          generationUserId: Meteor.userId(),\n          \"users.name\": name\n        }, {\n          $set: {\n            \"users.$.currentlyLoggedIn\": true\n          }\n        });\n      }\n    });\n  }\n\n});\nMeteor.methods({\n  resetPasswordOrCreateUser(user) {\n    try {\n      // console.log('reset the password of the user before logging him in');\n      check(user.email, String);\n      check(user.password, String);\n    } catch (err) {\n      throw new Meteor.Error(\"Missing Qlik.com user data\", \"The user misses important information from its Qlik.com account\");\n    }\n\n    const userExists = Accounts.findUserByEmail(user.email);\n    var userId = {};\n\n    if (userExists) {\n      // console.log('########### found user, now reset his password: ', userExists);\n      userId = userExists._id;\n      Accounts.setPassword(userId, user.password);\n    } else {\n      userId = Accounts.createUser(user);\n      Roles.addUsersToRoles(userId, [\"untrusted\"], \"GLOBAL\"); // https://github.com/alanning/meteor-roles\n    }\n\n    return userId;\n  }\n\n});\n\nfunction insertDummyCustomers(generationUserId) {\n  // console.log('insertDummyCustomers called for generationUserId: ', generationUserId);\n  _.each(dummyCustomers, function (customer) {\n    customer.generationUserId = generationUserId;\n    Customers.insert(customer);\n  });\n} //Each proxy has its own session cookie, so you have to logout the users per proxy used.\n\n\nfunction logoutUser(UDC, name, proxy) {\n  if (!proxy) {\n    proxy = senseConfig.virtualProxyClientUsage;\n  } // use use the proxy for the dummy users from step 4\n  // console.log('******** QPS Functions: logout the current: ' + name + ' on proxy: ' + proxy);\n\n\n  if (name) {\n    // //console.log('Make QPS-logout call, We authenticate to Sense using the options (including a certificate) object in the HTTPs call: '); //, configCerticates);\n    // //console.log('Meteor tries to logout the user on this URL: https://' + senseConfig.SenseServerInternalLanIP + ':4243/qps/' + senseConfig.virtualProxyClientUsage + '/user/' + senseConfig.UDC + '/' + name);\n    try {\n      const call = {};\n      call.action = \"Logout user: \" + name;\n      call.url = gitHubLinks.logoutUser;\n      call.request = \"https://\" + senseConfig.SenseServerInternalLanIP + \":4243/qps/\" + proxy + \"/user/\" + UDC + \"/\" + name + \"?xrfkey=\" + senseConfig.xrfkey;\n      call.response = HTTP.call(\"DELETE\", call.request, {\n        npmRequestOptions: configCerticates\n      });\n      REST_Log(call, UDC); // the UDC is the by definition the userId of meteor in our approach...\n      // console.log('The HTTP REQUEST to Sense QPS API:', call.request);\n      // console.log('The HTTP RESPONSE from Sense QPS API: ', call.response);\n    } catch (err) {\n      console.error(err);\n      throw new Meteor.Error(\"Logout user failed\", err.message);\n    }\n  }\n}\n\nfunction getRedirectURL(passport, proxyRestUri, targetId, generationUserId) {\n  try {\n    check(passport, Object);\n    check(proxyRestUri, String);\n    check(targetId, String);\n    check(generationUserId, String);\n  } catch (error) {\n    throw new Meteor.error(\"Request ticket failed\", \"You did not specify a pasport, proxyUri, targetId  or generationUserID\", error);\n  } // console.log('entered server side requestTicket module for user and passport', passport, proxyRestUri);\n  // see https://help.qlik.com/en-US/sense-developer/3.0/Subsystems/ProxyServiceAPI/Content/ProxyServiceAPI/ProxyServiceAPI-ProxyServiceAPI-Authentication-Ticket-Add.htm\n\n\n  var ticketRequestBody = passport;\n  ticketRequestBody.TargetId = targetId; // console.log('The passport for requesting a ticket: ', passport);\n\n  try {\n    var call = {};\n    call.action = \"STEP 5: Request ticket at endpoint received from Sense\";\n    call.request = proxyRestUri + \"ticket\"; // we use the proxy rest uri which we got from the redirect from the proxy (the first bounce)\n\n    call.url = gitHubLinks.requestTicket;\n    call.response = HTTP.call(\"POST\", call.request, {\n      npmRequestOptions: configCerticates,\n      headers: authHeaders,\n      params: {\n        xrfkey: senseConfig.xrfkey\n      },\n      data: passport // the user and group info for which we want to create a ticket\n\n    });\n    REST_Log(call, generationUserId);\n  } catch (err) {\n    console.error(\"REST call to request a ticket failed\", err);\n    throw new Meteor.Error(\"Request ticket failed via getRedirectURL\", err.message);\n  }\n\n  console.log(\"The HTTP REQUEST to Sense QPS API:\", call.request);\n  console.log(\"The HTTP RESPONSE from Sense QPS API: \", call.response);\n  var ticketResponse = call.response.data;\n  call.action = \"STEP 6: Use response from our ticket request to create redirect url\";\n  call.request = \"Use the redirect url we got back and the ticket string to make a redirect url for the client. Format: \" + ticketResponse.TargetUri + \"?QlikTicket=\" + ticketResponse.Ticket + \". JSON received: \" + ticketResponse; // REST_Log(call);\n  // Build redirect URL for the client including the ticket\n\n  if (ticketResponse.TargetUri.indexOf(\"?\") > 0) {\n    redirectURI = ticketResponse.TargetUri + \"&QlikTicket=\" + ticketResponse.Ticket;\n  } else {\n    redirectURI = ticketResponse.TargetUri + \"?QlikTicket=\" + ticketResponse.Ticket;\n  }\n\n  if (!redirectURI) {\n    if (Meteor.settings.public.useSSL) {\n      redirectURI = \"https://\" + senseConfig.host + \":\" + senseConfig.qlikSensePortSecure + \"/\" + senseConfig.virtualProxyClientUsage + \"/\" + hub;\n    } else {\n      redirectURI = \"http://\" + senseConfig.host + \":\" + senseConfig.port + \"/\" + senseConfig.virtualProxyClientUsage + \"/\" + hub;\n    }\n  }\n\n  console.log(\"Meteor server side created this redirect url: \", redirectURI);\n  return redirectURI;\n}","map":{"version":3,"sources":["imports/api/server/QPSFunctions.js"],"names":["module1","module","export","createVirtualProxies","getVirtualProxies","logoutUser","getRedirectURL","Meteor","watch","require","v","Customers","dummyCustomers","dummyCustomer","REST_Log","gitHubLinks","senseConfig","authHeaders","qliksrv","configCerticates","validateJSON","qrsSrv","lodash","default","fs","path","os","ip","v4","uuidv4","_","console","log","file","join","settings","broker","automationBaseFolder","proxySettings","readJson","err","Error","vpToCreate","websocketCrossOriginWhiteList","push","public","qlikSenseHost","address","hostname","existingProxies","found","some","existingVP","prefix","virtualProxy","createVirtualProxy","linkVirtualProxyToProxy","error","loadBalancingServerNodes","id","getServerNodeConfiguration","check","Object","request","response","HTTP","call","params","xrfkey","npmRequestOptions","data","proxyId","getProxyId","proxyConfig","getProxyServiceConfiguration","virtualProxies","qlikSensePort","Number","qlikSensePortSecure","qlikSense","proxyAllowHTTP","Boolean","unencryptedListenPort","listenPort","allowHttp","updateProxy","String","outputFile","JSON","stringify","methods","currentlyLoggedInUser","action","userId","customer","findOne","generationUserId","user","find","users","currentlyLoggedIn","getRedirectUrl","proxyRestUri","targetId","loggedInUser","passport","UserDirectory","UserId","name","Attributes","group","toUpperCase","country","url","createpassport","getTicketNumber","userProperties","requestTicketWithPassport","proxyGetTicketURI","SenseServerInternalLanIP","private","proxyPort","headers","message","Ticket","getJWTToken","uuid","sub","email","groups","Groups","genT","token","generate","certificatesDirectory","resetLoggedInUser","forEach","updatedUsers","map","update","_id","$set","logoutPresentationUser","UDC","slideGenerator","logoutVirtualProxyClientUsageUser","virtualProxyClientUsage","simulateUserLogin","query","numberAffectedDocuments","insertDummyCustomers","resetPasswordOrCreateUser","password","userExists","Accounts","findUserByEmail","setPassword","createUser","Roles","addUsersToRoles","each","insert","proxy","ticketRequestBody","TargetId","requestTicket","ticketResponse","TargetUri","indexOf","redirectURI","useSSL","host","hub","port"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport {\n  Customers,\n  dummyCustomers,\n  dummyCustomer,\n} from \"/imports/api/customers\";\nimport { REST_Log } from \"/imports/api/APILogs\";\nimport { gitHubLinks } from \"/imports/ui/UIHelpers\";\nvar fs = require(\"fs-extra\");\nconst path = require(\"path\");\nvar os = require(\"os\");\nvar ip = require(\"ip\");\n// const token = require(\"./token\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\n\n//\n// ─── IMPORT CONFIG FOR QLIK SENSE QRS ───────────────────────────────────────────\n//\n\nimport {\n  senseConfig,\n  authHeaders,\n  qrsSrv as qliksrv,\n  configCerticates,\n  validateJSON,\n} from \"/imports/api/config.js\";\nimport lodash from \"lodash\";\n_ = lodash;\n\n//\n// ─── CREATE VIRTUAL PROXIES ─────────────────────────────────────────────────────\n//\n\n// http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-Virtual-Proxy-Create.htm\nexport async function createVirtualProxies() {\n  console.log(\"------------------------------------\");\n  console.log(\"CREATE VIRTUAL PROXIES\");\n  console.log(\"------------------------------------\");\n  var file = path.join(\n    Meteor.settings.broker.automationBaseFolder,\n    \"proxy\",\n    \"import\",\n    \"virtualProxySettings.json\"\n  );\n  try {\n    // READ THE PROXY FILE\n    var proxySettings = await fs.readJson(file);\n    try {\n      validateJSON(proxySettings);\n    } catch (err) {\n      throw new Error(\n        \"Cant read the virtual proxy definitions file: virtualProxySettings.json in your automation folder\"\n      );\n    }\n\n    //FOR EACH PROXY FOUND IN THE INPUTFILE (vpToCreate), CREATE IT IN SENSE. We also put the current ip/host in the list of sense since in most cases this tool runs on the same machine as sense.\n    for (var vpToCreate of proxySettings) {\n      if (vpToCreate.websocketCrossOriginWhiteList) {\n        vpToCreate.websocketCrossOriginWhiteList.push(\n          Meteor.settings.public.qlikSenseHost\n        );\n        vpToCreate.websocketCrossOriginWhiteList.push(ip.address());\n        vpToCreate.websocketCrossOriginWhiteList.push(os.hostname());\n      }\n      var existingProxies = getVirtualProxies();\n\n      // CHECK IF VIRT. PROXY ALREADY EXISTS IN SENSE\n      var found = existingProxies.some(function (existingVP) {\n        return existingVP.prefix === vpToCreate.prefix;\n      });\n      if (!found) {\n        var virtualProxy = createVirtualProxy(vpToCreate);\n        // THE VIRTUAL PROXY HAS BEEN CREATED, NOW LINK IT TO THE CENTRAL PROXY\n        linkVirtualProxyToProxy(virtualProxy);\n      } else {\n        console.log(\n          \"Virtual proxy \" +\n            vpToCreate.prefix +\n            \" already existed. We do not update existing ones.\"\n        );\n      }\n    }\n  } catch (err) {\n    console.error(err);\n    throw new Error(\"unable to create virtual proxies\", err);\n  }\n\n  function createVirtualProxy(virtualProxy) {\n    // get id of local node so we can link the virtual proxy to a load balancing node\n    virtualProxy.loadBalancingServerNodes = [\n      {\n        id: getServerNodeConfiguration().id,\n      },\n    ];\n    try {\n      check(virtualProxy, Object);\n      console.log(\"------CREATE VIRTUAL PROXY: \", virtualProxy.prefix);\n\n      var request = qliksrv + \"/qrs/virtualproxyconfig/\";\n      response = HTTP.call(\"POST\", request, {\n        params: {\n          xrfkey: senseConfig.xrfkey,\n        },\n        npmRequestOptions: configCerticates,\n        data: virtualProxy,\n      });\n      return response.data;\n    } catch (err) {\n      console.error(\"create virtual proxy failed\", err);\n    }\n    // }\n  }\n}\n\n// http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/RepositoryServiceAPI/Content/RepositoryServiceAPI/RepositoryServiceAPI-Virtual-Proxy-Link.htm\nfunction linkVirtualProxyToProxy(virtualProxy) {\n  // console.log('linkVirtualProxyToProxy', virtualProxy.id);\n\n  // GET ID OF PROXY ON THIS HOST\n  var proxyId = getProxyId();\n  // GET THE CONFIG OF THE PROXY (WHICH CONTAINS VIRTUAL PROXIES)\n  var proxyConfig = getProxyServiceConfiguration(proxyId);\n  // ADD THE NEW VIRTUAL PROXY TO THE EXISTING PROXY LIST\n  proxyConfig.settings.virtualProxies.push(virtualProxy);\n\n  try {\n    check(Meteor.settings.public.qlikSensePort, Number);\n    check(Meteor.settings.public.qlikSensePortSecure, Number);\n    check(Meteor.settings.broker.qlikSense.proxyAllowHTTP, Boolean);\n  } catch (error) {\n    console.error(\n      \"settings file incomplete, your are missing the qliksenseport, qlikSensePortSecure or proxyAllowHTTP\"\n    );\n  }\n\n  //UPDATE SOME PROXY SETTINGS\n  console.log(\"UPDATE SOME PROXY SETTINGS...\");\n  proxyConfig.settings.unencryptedListenPort =\n    Meteor.settings.public.qlikSensePort; //HTTP\n  proxyConfig.settings.listenPort = Meteor.settings.public.qlikSensePortSecure; //HTTPS\n  proxyConfig.settings.allowHttp =\n    Meteor.settings.broker.qlikSense.proxyAllowHTTP;\n\n  //OVERWRITE THE SETTINGS WITH THE COMPLETE UPDATED OBJECT.\n  updateProxy(proxyId, proxyConfig);\n}\n\nfunction updateProxy(proxyId, proxyConfig) {\n  try {\n    check(proxyId, String);\n    check(proxyConfig, Object);\n    // console.log('proxyConfig', proxyConfig.settings.virtualProxies)\n\n    var request = qliksrv + \"/qrs/proxyservice/\" + proxyId;\n    response = HTTP.call(\"PUT\", request, {\n      params: {\n        xrfkey: senseConfig.xrfkey,\n      },\n      npmRequestOptions: configCerticates,\n      data: proxyConfig,\n    });\n  } catch (err) {\n    console.error(\"update proxy failed\", err);\n  }\n}\n\nfunction getProxyId() {\n  try {\n    var request = qliksrv + \"/qrs/proxyservice/?xrfkey=\" + senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates,\n    });\n    return response.data[0].id;\n  } catch (err) {\n    console.error(\"get proxyId failed\", err);\n  }\n}\n\nfunction getProxyServiceConfiguration(proxyId) {\n  try {\n    check(proxyId, String);\n\n    var request =\n      qliksrv +\n      \"/qrs/proxyservice/\" +\n      proxyId +\n      \"?xrfkey=\" +\n      senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates,\n    });\n\n    //SAVE RPOXY CONFIG TO THE EXPORT FOLDER\n    var file = path.join(\n      Meteor.settings.broker.automationBaseFolder,\n      \"proxy\",\n      \"export\",\n      \"proxyServiceConfiguration.json\"\n    );\n    fs.outputFile(file, JSON.stringify(response.data, null, 2), \"utf-8\");\n\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n}\n\nexport function getVirtualProxies() {\n  // console.log('--------------------------GET VIRTUAL PROXIES');//\n  try {\n    var request = qliksrv + \"/qrs/virtualproxyconfig/\";\n    response = HTTP.call(\"GET\", request, {\n      params: {\n        xrfkey: senseConfig.xrfkey,\n      },\n      npmRequestOptions: configCerticates,\n    });\n\n    var file = path.join(\n      Meteor.settings.broker.automationBaseFolder,\n      \"proxy\",\n      \"export\",\n      \"virtualProxyServiceConfiguration.json\"\n    );\n\n    // SAVE PROXY FILE TO DISK\n    fs.outputFile(file, JSON.stringify(response.data, null, 2), \"utf-8\");\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n}\n\n// function getCentralProxy() {\n//     console.log('getCentralProxy: GET /qrs/ServerNodeConfiguration?filter=isCentral')\n// }\n\nfunction getServerNodeConfiguration() {\n  try {\n    var request =\n      qliksrv +\n      \"/qrs/servernodeconfiguration/local?xrfkey=\" +\n      senseConfig.xrfkey;\n    response = HTTP.call(\"GET\", request, {\n      npmRequestOptions: configCerticates,\n    });\n    return response.data;\n  } catch (err) {\n    console.error(\"create virtual proxy failed\", err);\n  }\n}\n\n//\n// ─── METEOR METHODS ─────────────────────────────────────────────────────────────\n//\n\nMeteor.methods({\n  currentlyLoggedInUser() {\n    // console.log(\"Meteor will now look which user is currently logged in, and request a ticket for this ID, and add his group memberships.\");\n    var call = {};\n    call.action = \"STEP 3: Server received request to create ticket\";\n    call.request =\n      \"Meteor server received a incoming method call from the browser. The meteor server will now look which user is currently logged in, and create a ticket for this ID, and add his group memberships.\";\n    REST_Log(call, Meteor.userId());\n\n    // first find the customers that have a logged in users (mongo returns a complete document)\n    var customer = Customers.findOne({\n      generationUserId: Meteor.userId(),\n      \"users.currentlyLoggedIn\": true,\n    });\n    // console.log('In our local database we can find the customer with the currentlyLoggedIn set to true for user: ' + loggedInUser + ', the customer which contains the user that the user selected with the dropdown: ', customer);\n\n    // now we have the document, we can look in the array of users, to find the one that is logged in.\n    var user;\n    if (!customer) {\n      // if no user is selected, just insert john as a dummy\n      // const error = 'You have not selected a user you want to simulate the Single Sign on with. For demo purposes we now selected John for you. You can also select your own user in step 4 of the SaaS demo';\n      var response = {};\n      // console.log('dummyCustomer :', dummyCustomer);\n      response.user = dummyCustomer.user;\n      response.customer = dummyCustomer;\n      // throw new Meteor.Warning('No user', error);\n    } else {\n      var user = _.find(customer.users, {\n        currentlyLoggedIn: true,\n      });\n      var response = {};\n      response.user = user;\n      response.customer = customer;\n    }\n    // console.log('the response is: ', response);\n    return response;\n  },\n  getRedirectUrl(proxyRestUri, targetId, loggedInUser) {\n    var response = Meteor.call(\"currentlyLoggedInUser\");\n    var customer = response.customer;\n    var user = response.user;\n\n    console.log(\n      \"UserID currently logged in in the demo platform: \" +\n        loggedInUser +\n        \". Meteor server side thinks the meteor.userId is \" +\n        Meteor.userId() +\n        \". We use this as the UDC name\"\n    );\n    // Create a paspoort (ticket) request: user directory, user identity and attributes\n    var passport = {\n      UserDirectory: Meteor.userId(), // Specify a dummy value to ensure userID's are unique E.g. \"Dummy\", or in my case, I use the logged in user, so each user who uses the demo can logout only his users, or the name of the customer domain if you need a Virtual proxy per customer\n      UserId: user.name, // the current user that we are going to login with\n      Attributes: [\n        {\n          group: customer.name.toUpperCase(),\n        }, // attributes supply the group membership from the source system to Qlik Sense\n        {\n          group: user.country.toUpperCase(),\n        },\n        {\n          group: user.group.toUpperCase(),\n        },\n      ],\n    };\n    console.log('Request ticket for this user passport\": ', passport);\n\n    // logging only\n    var call = {};\n    call.action =\n      \"STEP 4: User and group information received from customer database, now we can request a ticket\";\n    call.url = gitHubLinks.createpassport;\n    call.request =\n      'Request ticket for this user and his groups (an array of values which you can use in the security rules): \": ' +\n      JSON.stringify(passport);\n    REST_Log(call, Meteor.userId());\n\n    return getRedirectURL(passport, proxyRestUri, targetId, Meteor.userId());\n  },\n  getTicketNumber(userProperties, virtualProxy) {\n    // only get a ticket number for a SPECIFIC virtual proxy\n    console.log('getTicketNumber using properties:')\n    console.log('virtualProxy', virtualProxy)\n    console.log('userProperties', userProperties)\n    try {\n      check(userProperties.group, String);\n      check(virtualProxy, String);\n      check(Meteor.userId(), String);\n    } catch (err) {\n      throw new Meteor.Error(\n        \"Failed to login into Qlik Sense via a ticket\",\n        \"We could not request a ticket because the userId or groups (technical, generic) or virtual proxy, or UDC (your Meteor userId, are you not yet logged into Meteor?) are not provided\"\n      );\n    }\n    var passport = {\n      UserDirectory: Meteor.userId(), // Specify a dummy value to ensure userID's are unique E.g. \"Dummy\", or in my case, I use the logged in user, so each user who uses the demo can logout only his users, or the name of the customer domain if you need a Virtual proxy per customer\n      UserId: Meteor.userId(), // the current user that we are going to login with\n      Attributes: [\n        {\n          group: \"slideGenerator\",\n        }, // attributes supply the group membership from the source system to Qlik Sense\n        {\n          group: userProperties.group,\n        },\n        {\n          group: \"ITALY\",\n        }, // make sure the row level demo works by passing this\n      ],\n    };\n    //get the ticket number and return it to the client\n    return Meteor.call(\"requestTicketWithPassport\", virtualProxy, passport);\n  },\n  //only for demo purposes! never supply groups from the client...\n  requestTicketWithPassport(virtualProxy, passport) {\n    console.log('getTicketNumber passport', passport);\n    // var rootCas = require(\"ssl-root-cas\").create();//\n\n    // default for all https requests\n\n    // (whether using https directly, request, or another module)\n    // require(\"https\").globalAgent.options.ca = rootCas;\n\n    // http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/ProxyServiceAPI/Content/ProxyServiceAPI/ProxyServiceAPI-ProxyServiceAPI-Authentication-Ticket-Add.htm\n    var proxyGetTicketURI =\n      \"https://\" +\n      senseConfig.SenseServerInternalLanIP +\n      \":\" +\n      Meteor.settings.private.proxyPort +\n      \"/qps/\" +\n      virtualProxy +\n      \"/ticket\"; // \"proxyRestUri\": \"https://ip-172-31-22-22.eu-central-1.compute.internal:4243/qps/meteor/\",\n    // console.log('proxyGetTicketURI', proxyGetTicketURI)\n    try {\n      var response = HTTP.call(\"POST\", proxyGetTicketURI, {\n        npmRequestOptions: configCerticates,\n        headers: authHeaders,\n        params: {\n          xrfkey: senseConfig.xrfkey,\n        },\n        data: passport, // the user and group info for which we want to create a ticket\n      });\n    } catch (err) {\n      console.error(\n        \"REST call to request a ticket failed. PLEASE EXPORT AND IMPORT CERTIFICATES FROM QMC FOR THE CORRECT HOSTNAME\",\n        err\n      );\n      throw new Meteor.Error(\"Request ticket failed\", err.message);\n    }\n    return response.data.Ticket;\n  },\n  //https://qlik.dev/authenticate/jwt/create-signed-tokens-for-jwt-authorization\n  getJWTToken(passport) {\n    console.log(\"get JWT with passport\", passport);\n\n    try {\n      const uuid = uuidv4();\n      const sub = `sub_${uuid}`;\n      const name = passport.UserId;\n      const email = `${uuid}@demo.anon`;\n      const groups = passport.Groups;\n\n      const genT = token.generate(sub, name, email, groups);\n      console.log(\"🚀 ~ file: QPSFunctions.js:423 ~ getJWTToken ~ genT:\", genT)\n      return genT;\n    } catch (err) {\n      console.error(\n        \"unable to generate JWT token, did you supply the correct public.pem and private.pem in the dir: \"+Meteor.settings.private.certificatesDirectory,\n        err\n      );\n      throw new Meteor.Error(\"generate jwt token failed\", err.message);\n    }\n  },\n  resetLoggedInUser() {\n    // console.log(\"***Method resetLoggedInUsers\");\n    // console.log('call the QPS logout api, to invalidate the session cookie for each user in our local database');\n\n    // reset the local database. set all users to not logged in. We need this code because we do a simulation of the login and not a real end user login.\n    Customers.find({\n      generationUserId: Meteor.userId(),\n    }).forEach(function (customer) {\n      var updatedUsers = _.map(customer.users, function (user) {\n        if (user) {\n          user.currentlyLoggedIn = false;\n        }\n\n        // and just logout everybody in the user list\n        logoutUser(Meteor.userId(), user.name);\n        return user;\n      });\n\n      Customers.update(customer._id, {\n        $set: {\n          users: updatedUsers,\n        },\n      });\n    });\n    // logoutUser(Meteor.userId(), Meteor.userId()); //logout the user for the slide generator\n  },\n  logoutPresentationUser(UDC, name) {\n    console.log(\"logoutPresentationUser(UDC, name)\", UDC, name);\n    logoutUser(UDC, name, Meteor.settings.public.slideGenerator.virtualProxy);\n  },\n  logoutVirtualProxyClientUsageUser(UDC, name) {\n    console.log(\n      \"logout virtual proxy client usuage User(UDC, name)\",\n      UDC,\n      name\n    );\n    logoutUser(UDC, name, Meteor.settings.public.virtualProxyClientUsage);\n  },\n  simulateUserLogin(name) {\n    check(name, String);\n    Meteor.call(\"resetLoggedInUser\");\n    // console.log('*** Reset all logged in user done, now write in our local database the name for the current simulated user: generationUserId: ' + Meteor.userId() + ' & users.name:' + name);\n    var query = [\n      {\n        generationUserId: Meteor.userId(),\n        \"users.name\": name,\n      },\n      {\n        $set: {\n          \"users.$.currentlyLoggedIn\": true,\n        },\n      },\n    ];\n\n    Customers.update(\n      {\n        generationUserId: Meteor.userId(),\n        \"users.name\": name,\n      },\n      {\n        $set: {\n          \"users.$.currentlyLoggedIn\": true,\n        },\n      },\n      {},\n      function (error, numberAffectedDocuments) {\n        if (numberAffectedDocuments === 0) {\n          // if nothing is updated, insert some dummy customers\n          // console.log('simulateUserLogin numberAffectedDocuments: ', numberAffectedDocuments);\n          // name does not yet exist in the customers created by the current demo user. So insert our dummy customers.numberAffectedDocuments\n          insertDummyCustomers(Meteor.userId());\n          Customers.update(\n            {\n              generationUserId: Meteor.userId(),\n              \"users.name\": name,\n            },\n            {\n              $set: {\n                \"users.$.currentlyLoggedIn\": true,\n              },\n            }\n          );\n        }\n      }\n    );\n  },\n});\n\nMeteor.methods({\n  resetPasswordOrCreateUser(user) {\n    try {\n      // console.log('reset the password of the user before logging him in');\n      check(user.email, String);\n      check(user.password, String);\n    } catch (err) {\n      throw new Meteor.Error(\n        \"Missing Qlik.com user data\",\n        \"The user misses important information from its Qlik.com account\"\n      );\n    }\n    const userExists = Accounts.findUserByEmail(user.email);\n    var userId = {};\n\n    if (userExists) {\n      // console.log('########### found user, now reset his password: ', userExists);\n      userId = userExists._id;\n      Accounts.setPassword(userId, user.password);\n    } else {\n      userId = Accounts.createUser(user);\n      Roles.addUsersToRoles(userId, [\"untrusted\"], \"GLOBAL\"); // https://github.com/alanning/meteor-roles\n    }\n    return userId;\n  },\n});\n\nfunction insertDummyCustomers(generationUserId) {\n  // console.log('insertDummyCustomers called for generationUserId: ', generationUserId);\n  _.each(dummyCustomers, function (customer) {\n    customer.generationUserId = generationUserId;\n    Customers.insert(customer);\n  });\n}\n\n//Each proxy has its own session cookie, so you have to logout the users per proxy used.\nexport function logoutUser(UDC, name, proxy) {\n  if (!proxy) {\n    proxy = senseConfig.virtualProxyClientUsage;\n  } // use use the proxy for the dummy users from step 4\n  // console.log('******** QPS Functions: logout the current: ' + name + ' on proxy: ' + proxy);\n\n  if (name) {\n    // //console.log('Make QPS-logout call, We authenticate to Sense using the options (including a certificate) object in the HTTPs call: '); //, configCerticates);\n    // //console.log('Meteor tries to logout the user on this URL: https://' + senseConfig.SenseServerInternalLanIP + ':4243/qps/' + senseConfig.virtualProxyClientUsage + '/user/' + senseConfig.UDC + '/' + name);\n    try {\n      const call = {};\n      call.action = \"Logout user: \" + name;\n      call.url = gitHubLinks.logoutUser;\n      call.request =\n        \"https://\" +\n        senseConfig.SenseServerInternalLanIP +\n        \":4243/qps/\" +\n        proxy +\n        \"/user/\" +\n        UDC +\n        \"/\" +\n        name +\n        \"?xrfkey=\" +\n        senseConfig.xrfkey;\n      call.response = HTTP.call(\"DELETE\", call.request, {\n        npmRequestOptions: configCerticates,\n      });\n\n      REST_Log(call, UDC); // the UDC is the by definition the userId of meteor in our approach...\n      // console.log('The HTTP REQUEST to Sense QPS API:', call.request);\n      // console.log('The HTTP RESPONSE from Sense QPS API: ', call.response);\n    } catch (err) {\n      console.error(err);\n      throw new Meteor.Error(\"Logout user failed\", err.message);\n    }\n  }\n}\n\n// based on Rikard Braathen's QlikAuth module\nexport function getRedirectURL(\n  passport,\n  proxyRestUri,\n  targetId,\n  generationUserId\n) {\n  try {\n    check(passport, Object);\n    check(proxyRestUri, String);\n    check(targetId, String);\n    check(generationUserId, String);\n  } catch (error) {\n    throw new Meteor.error(\n      \"Request ticket failed\",\n      \"You did not specify a pasport, proxyUri, targetId  or generationUserID\",\n      error\n    );\n  }\n\n  // console.log('entered server side requestTicket module for user and passport', passport, proxyRestUri);\n  // see https://help.qlik.com/en-US/sense-developer/3.0/Subsystems/ProxyServiceAPI/Content/ProxyServiceAPI/ProxyServiceAPI-ProxyServiceAPI-Authentication-Ticket-Add.htm\n\n  var ticketRequestBody = passport;\n  ticketRequestBody.TargetId = targetId;\n  // console.log('The passport for requesting a ticket: ', passport);\n\n  try {\n    var call = {};\n    call.action = \"STEP 5: Request ticket at endpoint received from Sense\";\n    call.request = proxyRestUri + \"ticket\"; // we use the proxy rest uri which we got from the redirect from the proxy (the first bounce)\n    call.url = gitHubLinks.requestTicket;\n    call.response = HTTP.call(\"POST\", call.request, {\n      npmRequestOptions: configCerticates,\n      headers: authHeaders,\n      params: {\n        xrfkey: senseConfig.xrfkey,\n      },\n      data: passport, // the user and group info for which we want to create a ticket\n    });\n    REST_Log(call, generationUserId);\n  } catch (err) {\n    console.error(\"REST call to request a ticket failed\", err);\n    throw new Meteor.Error(\n      \"Request ticket failed via getRedirectURL\",\n      err.message\n    );\n  }\n\n  console.log(\"The HTTP REQUEST to Sense QPS API:\", call.request);\n  console.log(\"The HTTP RESPONSE from Sense QPS API: \", call.response);\n  var ticketResponse = call.response.data;\n  call.action =\n    \"STEP 6: Use response from our ticket request to create redirect url\";\n  call.request =\n    \"Use the redirect url we got back and the ticket string to make a redirect url for the client. Format: \" +\n    ticketResponse.TargetUri +\n    \"?QlikTicket=\" +\n    ticketResponse.Ticket +\n    \". JSON received: \" +\n    ticketResponse;\n  // REST_Log(call);\n\n  // Build redirect URL for the client including the ticket\n  if (ticketResponse.TargetUri.indexOf(\"?\") > 0) {\n    redirectURI =\n      ticketResponse.TargetUri + \"&QlikTicket=\" + ticketResponse.Ticket;\n  } else {\n    redirectURI =\n      ticketResponse.TargetUri + \"?QlikTicket=\" + ticketResponse.Ticket;\n  }\n\n  if (!redirectURI) {\n    if (Meteor.settings.public.useSSL) {\n      redirectURI =\n        \"https://\" +\n        senseConfig.host +\n        \":\" +\n        senseConfig.qlikSensePortSecure +\n        \"/\" +\n        senseConfig.virtualProxyClientUsage +\n        \"/\" +\n        hub;\n    } else {\n      redirectURI =\n        \"http://\" +\n        senseConfig.host +\n        \":\" +\n        senseConfig.port +\n        \"/\" +\n        senseConfig.virtualProxyClientUsage +\n        \"/\" +\n        hub;\n    }\n  }\n  console.log(\"Meteor server side created this redirect url: \", redirectURI);\n  return redirectURI;\n}\n"]},"sourceType":"script","hash":"e3901b3c397ee7c5ea586ecc8c053c576270a587"}
