{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"packages/accounts-base/accounts_tests.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/accounts-base/accounts_tests.js","filename":"packages/accounts-base/accounts_tests.js","sourceMaps":true,"passPerPreset":false,"envName":"development","cwd":"/home/martijn/Documents/GitHub/QRSMeteor","root":"/home/martijn/Documents/GitHub/QRSMeteor","presets":[],"generatorOpts":{"filename":"packages/accounts-base/accounts_tests.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-base/accounts_tests.js"}},"code":"Meteor.methods({\n  getCurrentLoginToken: function () {\n    return Accounts._getLoginToken(this.connection.id);\n  }\n}); // XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\n\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({\n      foo: \"bar\"\n    });\n  });\n});\nTinytest.add('accounts - config - token lifetime', function (test) {\n  const loginExpirationInDays = Accounts._options.loginExpirationInDays;\n  Accounts._options.loginExpirationInDays = 2;\n  test.equal(Accounts._getTokenLifetimeMs(), 2 * 24 * 60 * 60 * 1000);\n  Accounts._options.loginExpirationInDays = loginExpirationInDays;\n});\nTinytest.add('accounts - config - unexpiring tokens', function (test) {\n  const loginExpirationInDays = Accounts._options.loginExpirationInDays; // When setting loginExpirationInDays to null in the global Accounts\n  // config object, make sure the returned token lifetime represents an\n  // unexpiring token date (is very far into the future).\n\n  Accounts._options.loginExpirationInDays = null;\n  test.equal(Accounts._getTokenLifetimeMs(), Accounts.LOGIN_UNEXPIRING_TOKEN_DAYS * 24 * 60 * 60 * 1000); // Verify token expiration date retrieval returns a Date.\n  // (verifies https://github.com/meteor/meteor/issues/9066)\n\n  test.isTrue(!isNaN(Accounts._tokenExpiration(new Date())), 'Returned token expiration should be a Date'); // Verify the token expiration check works properly.\n  // (verifies https://github.com/meteor/meteor/issues/9066)\n\n  const futureDate = new Date();\n  futureDate.setDate(futureDate.getDate() + 200);\n  test.isFalse(Accounts._tokenExpiresSoon(futureDate));\n  Accounts._options.loginExpirationInDays = loginExpirationInDays;\n});\nTinytest.add('accounts - config - default token lifetime', function (test) {\n  const options = Accounts._options;\n  Accounts._options = {};\n  test.equal(Accounts._getTokenLifetimeMs(), Accounts.DEFAULT_LOGIN_EXPIRATION_DAYS * 24 * 60 * 60 * 1000);\n  Accounts._options = options;\n});\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', {\n    id: Random.id()\n  }).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id(); // create an account with facebook\n\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('facebook', {\n    id: facebookId,\n    monkey: 42\n  }, {\n    profile: {\n      foo: 1\n    }\n  }).id;\n  var users = Meteor.users.find({\n    \"services.facebook.id\": facebookId\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42); // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('facebook', {\n    id: facebookId,\n    llama: 50\n  }, {\n    profile: {\n      foo: 1000,\n      bar: 2\n    }\n  }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\n    \"services.facebook.id\": facebookId\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50); // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n\n  test.equal(users[0].services.facebook.monkey, 42); // cleanup\n\n  Meteor.users.remove(uid1);\n});\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id(); // users that have different service ids get different users\n\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('weibo', {\n    id: weiboId1\n  }, {\n    profile: {\n      foo: 1\n    }\n  }).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('weibo', {\n    id: weiboId2\n  }, {\n    profile: {\n      bar: 2\n    }\n  }).id;\n  test.equal(Meteor.users.find({\n    \"services.weibo.id\": {\n      $in: [weiboId1, weiboId2]\n    }\n  }).count(), 2);\n  test.equal(Meteor.users.findOne({\n    \"services.weibo.id\": weiboId1\n  }).profile.foo, 1);\n  test.equal(Meteor.users.findOne({\n    \"services.weibo.id\": weiboId1\n  }).emails, undefined);\n  test.equal(Meteor.users.findOne({\n    \"services.weibo.id\": weiboId2\n  }).profile.bar, 2);\n  test.equal(Meteor.users.findOne({\n    \"services.weibo.id\": weiboId2\n  }).emails, undefined); // cleanup\n\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = '' + twitterIdOld; // create an account with twitter using the old ID format of integer\n\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('twitter', {\n    id: twitterIdOld,\n    monkey: 42\n  }, {\n    profile: {\n      foo: 1\n    }\n  }).id;\n  var users = Meteor.users.find({\n    \"services.twitter.id\": twitterIdOld\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42); // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('twitter', {\n    id: twitterIdNew,\n    monkey: 42\n  }, {\n    profile: {\n      foo: 1\n    }\n  }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\n    \"services.twitter.id\": twitterIdNew\n  }).fetch();\n  test.length(users, 1); // cleanup\n\n  Meteor.users.remove(uid1);\n});\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  }; // user does not already exist. create a user object with fields set.\n\n  var userId = Accounts.insertUserDoc({\n    profile: {\n      name: 'Foo Bar'\n    }\n  }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username); // run the hook again. now the user exists, so it throws an error.\n\n  test.throws(function () {\n    Accounts.insertUserDoc({\n      profile: {\n        name: 'Foo Bar'\n      }\n    }, userIn);\n  }, 'Username already exists.'); // cleanup\n\n  Meteor.users.remove(userId);\n});\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{\n      address: email1,\n      verified: false\n    }, {\n      address: email2,\n      verified: true\n    }]\n  }; // user does not already exist. create a user object with fields set.\n\n  var userId = Accounts.insertUserDoc({\n    profile: {\n      name: 'Foo Bar'\n    }\n  }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails); // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n\n  test.throws(function () {\n    Accounts.insertUserDoc({\n      profile: {\n        name: 'Foo Bar'\n      }\n    }, userIn);\n  }, 'Email already exists.'); // now with only one of them.\n\n  test.throws(function () {\n    Accounts.insertUserDoc({}, {\n      emails: [{\n        address: email1\n      }]\n    });\n  }, 'Email already exists.');\n  test.throws(function () {\n    Accounts.insertUserDoc({}, {\n      emails: [{\n        address: email2\n      }]\n    });\n  }, 'Email already exists.'); // a third email works.\n\n  var userId3 = Accounts.insertUserDoc({}, {\n    emails: [{\n      address: email3\n    }]\n  });\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal(typeof user3.createdAt, 'object'); // cleanup\n\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n}); // More token expiration tests are in accounts-password\n\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = {\n    username: Random.id()\n  };\n  var userId = Accounts.insertUserDoc({\n    profile: {\n      name: 'Foo Bar'\n    }\n  }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function (newUser) {\n      if (newUser.services && newUser.services.resume && _.isEmpty(newUser.services.resume.loginTokens)) {\n        observe.stop();\n        onComplete();\n      }\n    }\n  });\n\n  Accounts._expireTokens(new Date(), userId);\n}); // Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\n\nvar insertUnhashedLoginToken = function (userId, stampedToken) {\n  Meteor.users.update(userId, {\n    $push: {\n      'services.resume.loginTokens': stampedToken\n    }\n  });\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n\n  var stampedToken = Accounts._generateStampedLoginToken();\n\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {\n    resume: stampedToken.token\n  });\n  connection.disconnect(); // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n\n  var userId2 = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {\n    resume: stolenToken\n  });\n  connection.disconnect(); // Now do the same thing, this time with a stolen hashed token.\n\n  var userId3 = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl()); // evil plan foiled\n\n  test.throws(function () {\n    connection.call('login', {\n      resume: stolenToken\n    });\n  }, /You\\'ve been logged out by the server/);\n  connection.disconnect(); // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n\n  var userId4 = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n\n  var stampedToken = Accounts._generateStampedLoginToken();\n\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {\n    resume: stampedToken.token\n  });\n  connection.disconnect(); // The token is no longer available to be stolen.\n\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken); // After the upgrade, the client can still login with their original\n  // unhashed login token.\n\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {\n    resume: stampedToken.token\n  });\n  connection.disconnect();\n  onComplete();\n});\nTinytest.addAsync('accounts - connection data cleaned up', function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // onClose callbacks are called in order, so we run after the\n    // close callback in accounts.\n    serverConn.onClose(function () {\n      test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n      onComplete();\n    });\n    test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n    serverConn.close();\n  }, onComplete);\n});\nTinytest.add('accounts - get new token', function (test) {\n  // Test that the `getNewToken` method returns us a valid token, with\n  // the same expiration as our original token.\n  var userId = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n\n  var stampedToken = Accounts._generateStampedLoginToken();\n\n  Accounts._insertLoginToken(userId, stampedToken);\n\n  var conn = DDP.connect(Meteor.absoluteUrl());\n  conn.call('login', {\n    resume: stampedToken.token\n  });\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedToken.token));\n  var newTokenResult = conn.call('getNewToken');\n  test.equal(newTokenResult.tokenExpires, Accounts._tokenExpiration(stampedToken.when));\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(newTokenResult.token));\n  conn.disconnect(); // A second connection should be able to log in with the new token\n  // we got.\n\n  var secondConn = DDP.connect(Meteor.absoluteUrl());\n  secondConn.call('login', {\n    resume: newTokenResult.token\n  });\n  secondConn.disconnect();\n});\nTinytest.addAsync('accounts - remove other tokens', function (test, onComplete) {\n  // Test that the `removeOtherTokens` method removes all tokens other\n  // than the caller's token, thereby logging out and closing other\n  // connections.\n  var userId = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n  var stampedTokens = [];\n  var conns = [];\n\n  _.times(2, function (i) {\n    stampedTokens.push(Accounts._generateStampedLoginToken());\n\n    Accounts._insertLoginToken(userId, stampedTokens[i]);\n\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', {\n      resume: stampedTokens[i].token\n    });\n    test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedTokens[i].token));\n    conns.push(conn);\n  });\n\n  conns[0].call('removeOtherTokens');\n  simplePoll(function () {\n    var tokens = _.map(conns, function (conn) {\n      return conn.call('getCurrentLoginToken');\n    });\n\n    return !tokens[1] && tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n  }, function () {\n    // success\n    _.each(conns, function (conn) {\n      conn.disconnect();\n    });\n\n    onComplete();\n  }, function () {\n    // timed out\n    throw new Error(\"accounts - remove other tokens timed out\");\n  });\n});\nTinytest.add('accounts - hook callbacks can access Meteor.userId()', function (test) {\n  var userId = Accounts.insertUserDoc({}, {\n    username: Random.id()\n  });\n\n  var stampedToken = Accounts._generateStampedLoginToken();\n\n  Accounts._insertLoginToken(userId, stampedToken);\n\n  var validateStopper = Accounts.validateLoginAttempt(function (attempt) {\n    test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n    return true;\n  });\n  var onLoginStopper = Accounts.onLogin(function (attempt) {\n    test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n  });\n  var onLogoutStopper = Accounts.onLogout(function (logoutContext) {\n    test.equal(logoutContext.user._id, onLogoutExpectedUserId, \"onLogout\");\n    test.instanceOf(logoutContext.connection, Object);\n  });\n  var onLoginFailureStopper = Accounts.onLoginFailure(function (attempt) {\n    test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n  });\n  var conn = DDP.connect(Meteor.absoluteUrl()); // On a new connection, Meteor.userId() should be null until logged in.\n\n  var validateAttemptExpectedUserId = null;\n  var onLoginExpectedUserId = userId;\n  conn.call('login', {\n    resume: stampedToken.token\n  }); // Now that the user is logged in on the connection, Meteor.userId() should\n  // return that user.\n\n  validateAttemptExpectedUserId = userId;\n  conn.call('login', {\n    resume: stampedToken.token\n  }); // Trigger onLoginFailure callbacks\n\n  var onLoginFailureExpectedUserId = userId;\n  test.throws(function () {\n    conn.call('login', {\n      resume: \"bogus\"\n    });\n  }, '403'); // Trigger onLogout callbacks\n\n  var onLogoutExpectedUserId = userId;\n  conn.call('logout');\n  conn.disconnect();\n  validateStopper.stop();\n  onLoginStopper.stop();\n  onLogoutStopper.stop();\n  onLoginFailureStopper.stop();\n});\nTinytest.add('accounts - verify onExternalLogin hook can update oauth user profiles', function (test) {\n  // Verify user profile data is saved properly when not using the\n  // onExternalLogin hook.\n  let facebookId = Random.id();\n  const uid1 = Accounts.updateOrCreateUserFromExternalService('facebook', {\n    id: facebookId\n  }, {\n    profile: {\n      foo: 1\n    }\n  }).id;\n  let users = Meteor.users.find({\n    'services.facebook.id': facebookId\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1); // Verify user profile data can be modified using the onExternalLogin\n  // hook, for existing users.\n\n  Accounts.onExternalLogin(options => {\n    options.profile.foo = 2;\n    return options;\n  });\n  Accounts.updateOrCreateUserFromExternalService('facebook', {\n    id: facebookId\n  }, {\n    profile: {\n      foo: 1\n    }\n  });\n  users = Meteor.users.find({\n    'services.facebook.id': facebookId\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 2); // Verify user profile data can be modified using the onExternalLogin\n  // hook, for new users.\n\n  facebookId = Random.id();\n  const uid2 = Accounts.updateOrCreateUserFromExternalService('facebook', {\n    id: facebookId\n  }, {\n    profile: {\n      foo: 3\n    }\n  }).id;\n  users = Meteor.users.find({\n    'services.facebook.id': facebookId\n  }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 2); // Cleanup\n\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n  Accounts._onExternalLoginHook = null;\n});","map":{"version":3,"sources":["packages/accounts-base/accounts_tests.js"],"names":["Meteor","methods","getCurrentLoginToken","Accounts","_getLoginToken","connection","id","Tinytest","add","test","throws","config","foo","loginExpirationInDays","_options","equal","_getTokenLifetimeMs","LOGIN_UNEXPIRING_TOKEN_DAYS","isTrue","isNaN","_tokenExpiration","Date","futureDate","setDate","getDate","isFalse","_tokenExpiresSoon","options","DEFAULT_LOGIN_EXPIRATION_DAYS","idsInValidateNewUser","validateNewUser","user","_id","newUserId","updateOrCreateUserFromExternalService","Random","userId","facebookId","uid1","monkey","profile","users","find","fetch","length","services","facebook","uid2","llama","bar","undefined","remove","weiboId1","weiboId2","$in","count","findOne","emails","twitterIdOld","parseInt","hexString","twitterIdNew","twitter","userIn","username","insertUserDoc","name","userOut","createdAt","email1","email2","email3","address","verified","userId3","user3","addAsync","onComplete","date","update","$set","hashedToken","when","observe","changed","newUser","resume","_","isEmpty","loginTokens","stop","_expireTokens","insertUnhashedLoginToken","stampedToken","$push","userId1","_generateStampedLoginToken","DDP","connect","absoluteUrl","call","token","disconnect","userId2","stolenToken","_insertLoginToken","userId4","makeTestConnection","clientConn","serverConn","onClose","_getAccountData","close","conn","_hashLoginToken","newTokenResult","tokenExpires","secondConn","stampedTokens","conns","times","i","push","simplePoll","tokens","map","each","Error","validateStopper","validateLoginAttempt","attempt","validateAttemptExpectedUserId","onLoginStopper","onLogin","onLoginExpectedUserId","onLogoutStopper","onLogout","logoutContext","onLogoutExpectedUserId","instanceOf","Object","onLoginFailureStopper","onLoginFailure","onLoginFailureExpectedUserId","onExternalLogin","_onExternalLoginHook"],"mappings":"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","sourcesContent":["Meteor.methods({\n  getCurrentLoginToken: function () {\n    return Accounts._getLoginToken(this.connection.id);\n  }\n});\n\n// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({foo: \"bar\"});\n  });\n});\n\nTinytest.add('accounts - config - token lifetime', function (test) {\n  const loginExpirationInDays = Accounts._options.loginExpirationInDays;\n  Accounts._options.loginExpirationInDays = 2;\n  test.equal(Accounts._getTokenLifetimeMs(), 2 * 24 * 60 * 60 * 1000);\n  Accounts._options.loginExpirationInDays = loginExpirationInDays;\n});\n\nTinytest.add('accounts - config - unexpiring tokens', function (test) {\n  const loginExpirationInDays = Accounts._options.loginExpirationInDays;\n\n  // When setting loginExpirationInDays to null in the global Accounts\n  // config object, make sure the returned token lifetime represents an\n  // unexpiring token date (is very far into the future).\n  Accounts._options.loginExpirationInDays = null;\n  test.equal(\n    Accounts._getTokenLifetimeMs(),\n    Accounts.LOGIN_UNEXPIRING_TOKEN_DAYS * 24 * 60 * 60 * 1000,\n  );\n\n  // Verify token expiration date retrieval returns a Date.\n  // (verifies https://github.com/meteor/meteor/issues/9066)\n  test.isTrue(\n    !isNaN(Accounts._tokenExpiration(new Date())),\n    'Returned token expiration should be a Date',\n  );\n\n  // Verify the token expiration check works properly.\n  // (verifies https://github.com/meteor/meteor/issues/9066)\n  const futureDate = new Date();\n  futureDate.setDate(futureDate.getDate() + 200);\n  test.isFalse(Accounts._tokenExpiresSoon(futureDate));\n\n  Accounts._options.loginExpirationInDays = loginExpirationInDays;\n});\n\nTinytest.add('accounts - config - default token lifetime', function (test) {\n  const options = Accounts._options;\n  Accounts._options = {};\n  test.equal(\n    Accounts._getTokenLifetimeMs(),\n    Accounts.DEFAULT_LOGIN_EXPIRATION_DAYS * 24 * 60 * 60 * 1000,\n  );\n  Accounts._options = options;\n});\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', {id: Random.id()}).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, llama: 50},\n    {profile: {foo: 1000, bar: 2}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId1}, {profile: {foo: 1}}).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId2}, {profile: {bar: 2}}).id;\n  test.equal(Meteor.users.find({\"services.weibo.id\": {$in: [weiboId1, weiboId2]}}).count(), 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).profile.foo, 1);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).emails, undefined);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).profile.bar, 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = ''+twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdOld, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.twitter.id\": twitterIdOld}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdNew, monkey: 42}, {profile: {foo: 1}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.twitter.id\": twitterIdNew}).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Username already exists.');\n\n  // cleanup\n  Meteor.users.remove(userId);\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{address: email1, verified: false},\n             {address: email2, verified: true}]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Email already exists.');\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email1}]}\n    );\n  }, 'Email already exists.');\n\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email2}]}\n    );\n  }, 'Email already exists.');\n\n\n  // a third email works.\n  var userId3 = Accounts.insertUserDoc(\n      {}, {emails: [{address: email3}]}\n  );\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal(typeof user3.createdAt, 'object');\n\n  // cleanup\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var userId = Accounts.insertUserDoc({ profile: {\n    name: 'Foo Bar'\n  } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function (newUser) {\n      if (newUser.services && newUser.services.resume &&\n          _.isEmpty(newUser.services.resume.loginTokens)) {\n        observe.stop();\n        onComplete();\n      }\n    }\n  });\n  Accounts._expireTokens(new Date(), userId);\n});\n\n\n// Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\nvar insertUnhashedLoginToken = function (userId, stampedToken) {\n  Meteor.users.update(\n    userId,\n    {$push: {'services.resume.loginTokens': stampedToken}}\n  );\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n  var userId2 = Accounts.insertUserDoc({}, {username: Random.id()});\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stolenToken});\n  connection.disconnect();\n\n  // Now do the same thing, this time with a stolen hashed token.\n  var userId3 = Accounts.insertUserDoc({}, {username: Random.id()});\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  // evil plan foiled\n  test.throws(\n    function () {\n      connection.call('login', {resume: stolenToken});\n    },\n    /You\\'ve been logged out by the server/\n  );\n  connection.disconnect();\n\n  // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n  var userId4 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // The token is no longer available to be stolen.\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken);\n\n  // After the upgrade, the client can still login with their original\n  // unhashed login token.\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  onComplete();\n});\n\nTinytest.addAsync(\n  'accounts - connection data cleaned up',\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // onClose callbacks are called in order, so we run after the\n        // close callback in accounts.\n        serverConn.onClose(function () {\n          test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n          onComplete();\n        });\n\n        test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - get new token',\n  function (test) {\n    // Test that the `getNewToken` method returns us a valid token, with\n    // the same expiration as our original token.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', { resume: stampedToken.token });\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(stampedToken.token));\n\n    var newTokenResult = conn.call('getNewToken');\n    test.equal(newTokenResult.tokenExpires,\n               Accounts._tokenExpiration(stampedToken.when));\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(newTokenResult.token));\n    conn.disconnect();\n\n    // A second connection should be able to log in with the new token\n    // we got.\n    var secondConn = DDP.connect(Meteor.absoluteUrl());\n    secondConn.call('login', { resume: newTokenResult.token });\n    secondConn.disconnect();\n  }\n);\n\nTinytest.addAsync(\n  'accounts - remove other tokens',\n  function (test, onComplete) {\n    // Test that the `removeOtherTokens` method removes all tokens other\n    // than the caller's token, thereby logging out and closing other\n    // connections.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedTokens = [];\n    var conns = [];\n\n    _.times(2, function (i) {\n      stampedTokens.push(Accounts._generateStampedLoginToken());\n      Accounts._insertLoginToken(userId, stampedTokens[i]);\n      var conn = DDP.connect(Meteor.absoluteUrl());\n      conn.call('login', { resume: stampedTokens[i].token });\n      test.equal(conn.call('getCurrentLoginToken'),\n                 Accounts._hashLoginToken(stampedTokens[i].token));\n      conns.push(conn);\n    });\n\n    conns[0].call('removeOtherTokens');\n    simplePoll(\n      function () {\n        var tokens = _.map(conns, function (conn) {\n          return conn.call('getCurrentLoginToken');\n        });\n        return ! tokens[1] &&\n          tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n      },\n      function () { // success\n        _.each(conns, function (conn) {\n          conn.disconnect();\n        });\n        onComplete();\n      },\n      function () { // timed out\n        throw new Error(\"accounts - remove other tokens timed out\");\n      }\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - hook callbacks can access Meteor.userId()',\n  function (test) {\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n\n    var validateStopper = Accounts.validateLoginAttempt(function(attempt) {\n      test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n      return true;\n    });\n    var onLoginStopper = Accounts.onLogin(function(attempt) {\n      test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n    });\n    var onLogoutStopper = Accounts.onLogout(function(logoutContext) {\n      test.equal(logoutContext.user._id, onLogoutExpectedUserId, \"onLogout\");\n      test.instanceOf(logoutContext.connection, Object);\n    });\n    var onLoginFailureStopper = Accounts.onLoginFailure(function(attempt) {\n      test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n    });\n\n    var conn = DDP.connect(Meteor.absoluteUrl());\n\n    // On a new connection, Meteor.userId() should be null until logged in.\n    var validateAttemptExpectedUserId = null;\n    var onLoginExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Now that the user is logged in on the connection, Meteor.userId() should\n    // return that user.\n    validateAttemptExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Trigger onLoginFailure callbacks\n    var onLoginFailureExpectedUserId = userId;\n    test.throws(function() { conn.call('login', { resume: \"bogus\" }) }, '403');\n\n    // Trigger onLogout callbacks\n    var onLogoutExpectedUserId = userId;\n    conn.call('logout');\n\n    conn.disconnect();\n    validateStopper.stop();\n    onLoginStopper.stop();\n    onLogoutStopper.stop();\n    onLoginFailureStopper.stop();\n  }\n);\n\nTinytest.add(\n  'accounts - verify onExternalLogin hook can update oauth user profiles',\n  function (test) {\n    // Verify user profile data is saved properly when not using the\n    // onExternalLogin hook.\n    let facebookId = Random.id();\n    const uid1 = Accounts.updateOrCreateUserFromExternalService(\n      'facebook',\n      { id: facebookId },\n      { profile: { foo: 1 } },\n    ).id;\n    let users =\n      Meteor.users.find({ 'services.facebook.id': facebookId }).fetch();\n    test.length(users, 1);\n    test.equal(users[0].profile.foo, 1);\n\n    // Verify user profile data can be modified using the onExternalLogin\n    // hook, for existing users.\n    Accounts.onExternalLogin((options) => {\n      options.profile.foo = 2;\n      return options;\n    });\n    Accounts.updateOrCreateUserFromExternalService(\n      'facebook',\n      { id: facebookId },\n      { profile: { foo: 1 } },\n    );\n    users = Meteor.users.find({ 'services.facebook.id': facebookId }).fetch();\n    test.length(users, 1);\n    test.equal(users[0].profile.foo, 2);\n\n    // Verify user profile data can be modified using the onExternalLogin\n    // hook, for new users.\n    facebookId = Random.id();\n    const uid2 = Accounts.updateOrCreateUserFromExternalService(\n      'facebook',\n      { id: facebookId },\n      { profile: { foo: 3 } },\n    ).id;\n    users = Meteor.users.find({ 'services.facebook.id': facebookId }).fetch();\n    test.length(users, 1);\n    test.equal(users[0].profile.foo, 2);\n\n    // Cleanup\n    Meteor.users.remove(uid1);\n    Meteor.users.remove(uid2);\n    Accounts._onExternalLoginHook = null;\n  }\n);\n"]},"sourceType":"script","hash":"4e69047a10829bbfbb1c2aa5e1bf6721fc48ac07"}
